[
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql/rdbms-basics/",
	"title": "1. Database Basics",
	"tags": [],
	"description": "",
	"content": "Een database is niet meer dan een verzameling van gegevens. Een DBMS (DataBase Management System) is de software waarmee databases beheerd of aangemaakt kunnen worden.\n1. Waarom een database gebruiken? Een database wordt ook maar gewoon opgeslagen op een file system. Dus waarom kan ik dan niet zelf files gebruiken om mijn data op te slaan?\nDatabases bieden een aantal key features:\n Performant (index management) Betere integratie met andere applicaties Uniform DBMS voor bewerken of ophalen van data Concurrency ondersteuning Security \u0026amp; Privacy van data \u0026hellip;  In het tweedejaarsvak Besturingssystemen en C leerde je dat IO manipulatie heel dure operaties zijn. Een erg groot bestand openen of een seek() operatie uitvoeren daarop, duizenden bestanden tegelijkertijd openen voor data access, \u0026hellip;\u0026mdash;allemaal voorbeelden van nadelen waar een database de oplossing kan bieden. Achterliggend werkt het DBMS systeem nog steeds met files, maar dat is supergeoptimaliseerd door bijvoorbeeld gebruik te maken van verschillende niveaus van caching, file chunking, gedistribueerde modellen, \u0026hellip; De theorie en implementatie van een DBMS gaan we niet behandelen in deze cursus: de focus ligt op het gebruik van bestaande systemen.\n2. Database Model De data die zich in een database bevindt wordt op een specifieke manier opgeslagen. De structuur waarop deze data bijgehouden wordt, noemen we het database model.\nEen database model bestaat uit meerdere data modellen. Een data model beschrijft één specifiek object.\nWe zien hetzeflde eigenlijk terug als we denken aan Java of Kotlin. We definiëren hoe een klasse eruit ziet. Bijvoorbeeld volgende klasse:\ndata class Book(val isbn: string, val title: string, val author: string, val price: double) public class Book { String isbn; String title; String author; double price; public Book(isbn, title, author, price) { this.isbn = isbn; this.title = title; this.author = author; this.price = price; } }  Dit kunnen we ook in een database bepalen. Daar zou het data model van de tabel Book er bijvoorbeeld als volgt kunnen uitzien:\nclassDiagram class Book{ isbn: NVARCHAR(50) title: NVARCHAR (500) author: NVARCHAR (500) price: DECIMAL(10,4) }  Net als we in code state kunnen hebben wanneer we onze klasses instantiëren:\nvar book = Book(\u0026#34;0765326353\u0026#34;, \u0026#34;The Way of Kings\u0026#34;, \u0026#34;Brandon Sanderson\u0026#34;, 24.99) var book = new Book(\u0026#34;0765326353\u0026#34;, \u0026#34;The Way of Kings\u0026#34;, \u0026#34;Brandon Sanderson\u0026#34;, 24.99);  Zo kunnen we ook state hebben in onze database:\n   isbn title author price     0765326353 The Way of Kings Brandon Sanderson 24.99    Elk data model kan een aantal properties bevatten, zoals bovenstaande isbn en title, waarbij een type moet gedefiniëerd worden, zoals bovenstaande NVARCHAR(x). Dit zijn datatype namen die specifiek zijn voor elk DBMS.\nIn de oefeningen gaan wij SQLite gebruiken: zie ook datatypes in SQLite. SQLite\u0026rsquo;s types zijn loosely typed, wat wil zeggen dat er geen verschil is tussen VARCHAR (MSSQL\u0026rsquo;s ASCII) en NVARCHAR (MSSQL\u0026rsquo;s Unicode, UTF-16). Intern worden beide types gemapped naar TEXT. Raadpleeg dus telkens de manual om te controleren welke DBMS welke types ondersteund, en wat deze precies betekenen! Een Java/Kotlin String mapt dus niet altijd 100% op een RDBMS teksttype.\nEen voorbeeld van een simpel database model voor de inventaris van een bibliotheek zou er ongeveer als volgt kunnen uitzien:\nclassDiagram Book \"0..*\" -- \"1..*\" Genre Book \"1..*\" -- \"1\" Author class Author{ id: INT name: NVARCHAR firstName: NVARCHAR } class Genre{ id: INT description: NVARCHAR } class Book{ isbn: NVARCHAR title: NVARCHAR author: INT price: DECIMAL genre: INT }  Merk op dat we hier relaties gebruiken: de DBMS systemen die we eerst behandelen, SQL-varianten, zijn RDBMS systemen: relationele database management systemen. De author in Book is een nummer dat verwijst naar de id van Author in een ander model of tabel. Op deze manier is het mogelijk om, voor elke rij in Author, meerdere Book rijen aan te maken:\ndata class Author(val id: int, val name: string, val books: List\u0026lt;Book\u0026gt;) public class Author { private final int id; private final String name; private final List\u0026lt;Book\u0026gt; books; public Author(int id, int name) { this.id = id; this.name = name; this.books = new ArrayList\u0026lt;\u0026gt;(); } }  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql-ddl-dml/ddl/",
	"title": "1. DDL",
	"tags": [],
	"description": "",
	"content": "Data Defintion Language is de taal die we gebruiken om de structuur van onze database te veranderen. We kunnen hiermee tabellen aanmaken, wijzigen of verwijderen. Maar ook indexen, views, triggers of stored procedures worden hiermee aangemaakt.\nZowat elke RDBMS heeft tooling om DDL te doen via een handige interface, in plaats van dit zelf uit te schrijven. In de praktijk ga je waarschijnlijk met beiden in contact komen. We gaan DB Browser for SQLite gebruiken tijdens onze lessen.\nKijk naar de Chinook database en maak een schematische voorstelling van hoe deze database eruit ziet. Je kan hiervoor Mermaid gebruiken, of een eigen tool of pen en papier.\n  Tabellen aanmaken en wijzigen Met DDL definiëer je structuur in SQL. Met DML wijzig of manipuleer je de inhoud ervan. De Chinook database bevat natuurlijk reeds tabellen, maar alles begint met een CREATE TABLE statement. Je kan in SQLite Browser rechtsklikken op tabellen en Copy Create Statement kiezen om te reverse-engineeren hoe de tabellen aangemaakt werden.\nBijvoorbeeld, voor albums:\nCREATE TABLE \u0026#34;albums\u0026#34; ( [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, [Title] NVARCHAR(160) NOT NULL, [ArtistId] INTEGER NOT NULL, FOREIGN KEY ([ArtistId]) REFERENCES \u0026#34;artists\u0026#34; ([ArtistId]) ON DELETE NO ACTION ON UPDATE NO ACTION ) Rekening houdend met de vereenvoudigde datatypes van SQLite, zou je het zelf waarschijnlijk ongeveer zo schrijven:\nCREATE TABLE album ( AlbumId INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, Title TEXT NOT NULL, ArtistId INTEGER NOT NULL, FOREIGN KEY ArtistId REFERENCES artists (ArtistId) ) De NO ACTION statements zijn nutteloos. Namen hoeven, afhankelijk van het dialect, al dan niet escaped als [naam] of \u0026quot;naam\u0026quot;. Merk ook op dat bovenstaande SQL zal falen als de tabel artists niet eerst gemaakt wordt, anders kan de DB geen foreign key constraint controle uitvoeren. Meerdere statements worden gebruikelijk gescheiden door puntkomma ;.\nMerk op dat in SQL DDL we keywords met HOOFDLETTER schrijven en tabel of kolomnamen met kleine letter.\n  Probleem met je structuur? Geen probleem: DROP TABLE album. Als hier data in zit ben je die ook onherroepelijk kwijt! Kolom vergeten? Geen probleem: ALTER TABLE album ADD COLUMN blah TEXT. Kolom te veel? Geen probleem: ALTER TABLE album DROP COLUMN blah. Not null constraint vergeten? Geen probleem: ALTER TABLE album ALTER COLUMN blah NOT NULL. Oei, syntaxfoutje? SQLite ondersteunt geen alter in alter, andere vendors wel. Check constraint vergeten? Geen probleem: ALTER TABLE album ADD CONSTRAINT my_constraint CHECK(len(blah) \u0026gt; 9) Oei, syntaxfoutje? Zelfde probleem\u0026mdash;enkel op te lossen door DROP en re-create.  De CREATE en DROP statements kunnen ook gebruikt worden\u0026mdash;afhankelijk van de compatibiliteit van je RDBMS\u0026mdash;om indexen, aliases, tablespaces, synoniemen, sequenties, \u0026hellip; aan te maken en te verwijderen.\nMaak twee nieuwe tabellen aan: een licenses tabel, die per album (en dus ook artiest) licenties en hun kostprijs opslaat, en een memorabelia tabel die merchandise voor artiesten bevat om te verkopen. Denk goed na over het gebruik van constraints. Voeg daarna met ALTER TABLE kolommen toe om het (variërend) BTW percentage voor beide tabellen te bewaren.\n  Views aanmaken Een view is eigenlijk een specifieke query die we een vaste naam geven.\nAls ik een view wil maken van alle tracks van het Rock genre, dan doe ik dat als volgt:\nCREATE VIEW rock_tracks AS SELECT * FROM tracks WHERE GenreId = 1 Vanaf dit punt kan ik in een nieuwe query het volgende uitvoeren:\nSELECT * FROM rock_tracks Merk op dat we vaak geen idee hebben welke ID het genre Rock heeft:\nSELECT * FROM genres WHERE Name = \u0026#39;Rock\u0026#39; In plaats van de resultaten te limiteren op GenreId, kunnen we beide tabellen joinen:\nCREATE VIEW rock_tracks AS SELECT tracks.* FROM tracks INNER JOIN genres ON genres.GenreId = tracks.GenreId WHERE genres.Name = \u0026#39;Rock\u0026#39; Dit kan ook met behulp van een subquery. Zie ook: DDML - JOIN operator en verder, subqueries.\nSchrijf een view die de naam van elke track geeft, alsook de naam van het album en de artiest, gesorteerd op artiest, album en dan track.\n  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql/rdbms-components/",
	"title": "2. Database Componenten",
	"tags": [],
	"description": "",
	"content": "1. Three Layer Architecture Logical Layer De Logical Layer is waar we bepalen hoe onze data gestructureerd wordt. Hier bepalen we wat voor data we bijhouden, hoe die data eruitziet en hoe die zich gedraagt ten op zichte van onze andere datamodellen.\nEnkele voorbeelden hiervan zijn:\n Een BOEK mag door maximum 0 of 1 PERSONEN ontleend worden. Een PERSOON mag meerdere BOEKEN ontlenen. Een PERSOON is een subtype van een GEBRUIKER.  Oefening  Hoe zou een database model van een bibliotheek eruit zien? Teken zelf eens uit hoe dit gemodelleerd zou kunnen worden. Hoe houdt ik bij dat een boek uitgeleend werd? Wat als ik ook andere dingen wil uitlenen uit de bibliotheek, zoals DVD\u0026rsquo;s of eBooks?  Internal Layer De Internal Layer houdt zich bezig met alle details over hoe de data bewaard wordt. Sommige van de concepten die hier aan bod komen zijn de volgenden:\n Index management Constraint definities (uniek, referentieel, \u0026hellip;) Gepartitioneerde tabellen \u0026hellip;  Deze technologieën hebben allemaal te maken met performantie of data integriteit. We willen onze data op een zo\u0026rsquo;n performante manier opslaan én nog belangrijker op een zo performante manier terug ophalen.\nIndexatie Data wordt ongestructureerd bijgehouden in een tabel. Een tabel is eigenlijk niet meer dan een ongesorteerde lijst van gegevens. Bij elke nieuw element wordt dat aan het eind van de lijst toegevoegd.\nWat als we nu uit een lijst van miljoenen boeken de verzamelde werken van Tolkien willen ophalen? In plaats van door de hele lijst één voor één te gaan zoeken, kunnen we gelukkig gebruik maken van indexen.\nEen index is een inhoudstafel die we bijhouden van een bepaald aantal velden van onze tabel. Stel we hebben een Book tabel met miljoenen rijen, waaronder de volgende:\n   id isbn title author price     1345 0765326353 The Way of Kings Brandon Sanderson 24.99   6789 0395177111 The Hobbit J.R.R. Tolkien 24.99   3240 0812511816 The Eye of the World Robert Jordan 24.99   8939 0358439191 The Lord of the Rings J.R.R. Tolkien 24.99   1230 0143111582 Dune Frank Herbert 24.99    Als we een index zouden leggen op de author kolom dan zou die volgende informatie kunnen bevatten:\n   author id     Brandon Sanderson 1345   Frank Herbert 1230   J.R.R. Tolkien 6789   J.R.R. Tolkien 8939   Robert Jordan 3240    Een index houdt een mini-tabel bij van de velden die aan de index worden toegevoegd in combinatie met het identity1 veld. Deze tabel is wel gesorteerd op de velden uit de index, wat zoekopdrachten versnelt.\nConstraints We kunnen onze tabellen behoeden van corrupte data te bevatten door constraints te gebruiken. Het ISBN veld is bijvoorbeeld een uniek veld en mag nooit een waarde bevatten die al gekend is in onze database. Hiervoor kunnen we een unique constraint toevoegen. Bij data insertion gaat de database zelf nakijken of deze value al bestaat en zo ja wordt het toevoegen van de record geblokkeerd. Zo behouden we onze data integriteit.\nAndere voorbeelden van constraints kunnen zijn:\n De prijs van een boek moet groter dan 0 zijn Een boek kan niet verwijderd worden als het ooit werd uitgeleend Het ISBN-13 nummer moet 13 karakters hebben Het ISBN nummer moet - een aantal keren bevatten Een naam veld mag niet NULL (niet ingevuld) zijn Een email veld moet @ bevatten \u0026hellip;  Hoe constraints in de praktijk worden toegevoegd aan data modellen wordt behandeld in het hoofdstuk SQL DDL \u0026amp; DML. Zie ook SQLite table-constraint syntax.\nGepartitioneerde tabellen Sommige tabellen in productie omgevingen bevatten immense hoeveelheden aan data. We spreken over een grootorde van meerdere miljarden rijen. Hoe groter een tabel wordt, hoe trager het wordt om data op te halen. Het maakt niet uit hoeveel indexen we hebben gelegd, of welke SSD schijven we onderliggend op de fysieke storage hebben zitten. Meer data gaat altijd gelijk staan aan tragere data retrieval.\nOm tegen te gaan dat we tabellen krijgen die té groot worden en we daar niet meer zinvol data van kunnen ophalen bestaan hier een paar oplossingen voor. Het partitioneren van tabellen is er eentje van. Archivatie is een andere oplossing.\nNeem als voorbeeld een bank, die elke overschrijving van een rekening moet bewaren. De overschrijving tabel zou kunnen gepartitioneerd worden op jaar. Zodat er nog steeds 1 tabel overschrijving is, maar waarbij we die op de fysieke schijf opsplitsen per jaar, en elke op bijvoorbeeld de recentste 3 jaren index management voor bijhouden. De andere jaren kunnen nog steeds opgevraagd worden maar niet met dezelfde performantie als de meest recente data.\nExternal Layer De External Layer is wat we van onze database laten zien aan de buitenwereld. Dit zijn views van data. Een view is een virtuele representatie van data. We schrijven een query op onze tabellen en bewaren deze query als een view. Op deze manier kunnen we garanderen aan integrerende applicaties dat onze data er steeds hetzelfde gaat uitzien en tevens beschermen van informatie die voor het integrerende systeem niet relevant is.\nIn onze bibliotheek kunnen we een aantal views osptellen op basis van de noden van de verschillende applicaties. In het online platform waar je boeken kan uitlenen is het niet nodig de informatie over een auteur als een aparte entiteit weer te geven. We kunnen de tabel van Authors dus verbergen en enkel een view aanbieden op niveau van Books die er als volgt zou uitzien:\nclassDiagram class LendingAppBooks{ isbn: NVARCHAR title: NVARCHAR author: NVARCHAR price: DECIMAL genre: NVARCHAR }  Voor de inventaris applicatie moeten we wel in staat zijn om nieuwe boeken en auteurs toe te voegen. Daar kunnen de views er dan als volgt uitzien:\nclassDiagram InventoryBooks \"1..*\" -- \"1\" InventoryAuthors class InventoryAuthors{ id: INT name: NVARCHAR firstName: NVARCHAR } class InventoryBooks{ isbn: NVARCHAR title: NVARCHAR author: INT price: DECIMAL }  2. Catalog Dit is het hart van de de database. Dit bevat alle metadata die zich in de database bevindt. Onder andere, de tabellen; views; stored procedures; \u0026hellip;\nDe SQL standaard om deze informatie in te bewaren is in INFORMATION_SCHEMA. Niet alle SQL Database providers voldoen hier echter aan. SQLite doet dit niet en daar vind je die informatie in de tabel sqlite_master.\n3. Database Languages SQL is onderverdeeld in twee verschillende talen. Enerzijds heb je DDL (Data Definition Language). Dit gebruik je om de database structuur te wijzigen. Nieuwe tabellen toevoegen, indexen aanmaken, views verwijderen, \u0026hellip;\nAnderzijds heb je DML (Data Manipulation Language). Dit gebruik je voor alle CRUD (Create, Read, Update, Delete) acties op data. Hier gaan we in een volgend hoofdstuk verder op in gaan.\n  Eigenlijk niet het Identity veld, maar het veld dat in de Clustered Index zit van de tabel. Als er dan in de query meer informatie nodig is om op te halen kan die via die manier de rest van de data ophalen. \u0026#x21a9;\u0026#xfe0e;\n   "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql-ddl-dml/",
	"title": "2. SQL DDL &amp; DML",
	"tags": [],
	"description": "",
	"content": "SQL DDL \u0026amp; DML Zie menu links.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql/",
	"title": "1. RDBMS",
	"tags": [],
	"description": "",
	"content": "RDBMS Zie menu links.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/",
	"title": "Index",
	"tags": [],
	"description": "",
	"content": " Databases  Laatste aanpassingen voor academiejaar 2023\u0026mdash;2024.\n Planning    nr datum onderwerp     01 vr 16-02-2024 RDBMS \u0026amp; SQL: Basics, DB Componenten   02 vr 23-02-2024 ER-schema   03 di 27-02-2024 ACID \u0026amp; SQL Deel 1   04 vr 08-03-2024 SQL deel 2   05 vr 15-03-2024 RDBMS transacties: basics, concurrency control   06 vr 22-03-2024 DB APIs: basics, JDBC, JDBI   07 di 26-03-2024 DB APIs: JPA \u0026amp; Hibernate   08 di 16-04-2024 Re Transacties: rollbacks, concurrency in practice   09 vr 26-04-2024 NoSQL 1: intro HC, key/value en document stores   10 vr 03-05-2024 NoSQL 2: advanced concepts, case studies   11 vr 17-05-2024 XML Data Storage, Big Data \u0026amp; Analytics   12 do 23-05-2024 Reserve    Cursus noties Er worden telkens blokken van 3 uur ingepland voor dit vak. Er zijn geen traditionele hoorcolleges voorzien. Alle noties zijn via deze website te raadplegen (tenzij anders vermeld):\nInhoudsopgave  SQL:  Database Basics DB Componenten [ER-schema] (/sql/er-schema) Transacties I: ACID SQL: DDL SQL: DML   SQL DB APIs:  API Basics \u0026amp; layered tiers JDBC en JDBI JPA en Hibernate Extra oefeningen   Transacties:  Transacties II: Management Basics Concurrency control Failures/Rollbacks Transacties III: in de praktijk   NoSQL:  NoSQL Basics Key/Value stores Document stores Advanced map/reduce queries Replication   XML \u0026amp; Big Data Storage  XML Basics XSD Schemas XPath Queries Big Data Basics Big Data: Warehousing \u0026amp; BI    Syllabus  Lesgevers:  Coördinerend Verantwoordelijke: prof. dr. Kris Aerts (kris.aerts@kuleuven.be) assistent lesgever: ing. Arne Duyver (arne.duyver@kuleuven.be)   Kantoor: Technologiecentrum Diepenbeek, Groep ACRO.  Cursusbeschrijving Dit opleidingsonderdeel focust enerzijds op drie soorten databases:\n relationele databases de NoSQL-alternatieven XML databases  En anderzijds op twee toepassingen:\n programmeren van database-gestuurde applicaties via API\u0026rsquo;s een inleiding in Big Data  Vereiste voorkennis  Basiskennis van een Object-Geörienteerde programmeertaal als Java of C# Basiskennis van het UNIX systeem, werken met commandline  Doelstellingen Zie ook Studiegids UHasselt\nDe context en het overzicht worden aangereikt in de eerste lessen van dit vak.\nAls practicum wordt een grotere probleemstelling als project uitgewerkt. Alle aan te leren aspecten van databases komen in dit project aan bod. Studenten kunnen facultatief buiten het practicum extra thematische oefeningen oplossen.\nKalender Zie Mytimetable UHasselt.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]