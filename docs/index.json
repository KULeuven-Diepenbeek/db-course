[
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql/rdbms-basics/",
	"title": "1. Database Basics",
	"tags": [],
	"description": "",
	"content": "Een database is niet meer dan een verzameling van gegevens. Een DBMS (DataBase Management System) is de software waarmee databases beheerd of aangemaakt kunnen worden.\n1. Waarom een database gebruiken? Een database wordt ook maar gewoon opgeslagen op een file system. Dus waarom kan ik dan niet zelf files gebruiken om mijn data op te slaan?\nDatabases bieden een aantal key features:\nPerformant (index management) Betere integratie met andere applicaties Uniform DBMS voor bewerken of ophalen van data Concurrency ondersteuning Security \u0026amp; Privacy van data \u0026hellip; In het tweedejaarsvak Besturingssystemen en C leerde je dat IO manipulatie heel dure operaties zijn. Een erg groot bestand openen of een seek() operatie uitvoeren daarop, duizenden bestanden tegelijkertijd openen voor data access, \u0026hellip;\u0026mdash;allemaal voorbeelden van nadelen waar een database de oplossing kan bieden. Achterliggend werkt het DBMS systeem nog steeds met files, maar dat is supergeoptimaliseerd door bijvoorbeeld gebruik te maken van verschillende niveaus van caching, file chunking, gedistribueerde modellen, \u0026hellip; De theorie en implementatie van een DBMS gaan we niet behandelen in deze cursus: de focus ligt op het gebruik van bestaande systemen.\n2. Database Model De data die zich in een database bevindt wordt op een specifieke manier opgeslagen. De structuur waarop deze data bijgehouden wordt, noemen we het database model.\nEen database model bestaat uit meerdere data modellen. Een data model beschrijft één specifiek object.\nWe zien hetzeflde eigenlijk terug als we denken aan Java of Kotlin. We definiëren hoe een klasse eruit ziet. Bijvoorbeeld volgende klasse:\ndata class Book(val isbn: string, val title: string, val author: string, val price: double) public class Book { String isbn; String title; String author; double price; public Book(isbn, title, author, price) { this.isbn = isbn; this.title = title; this.author = author; this.price = price; } } Dit kunnen we ook in een database bepalen. Daar zou het data model van de tabel Book er bijvoorbeeld als volgt kunnen uitzien:\nclassDiagram\rclass Book{\risbn: NVARCHAR(50)\rtitle: NVARCHAR (500)\rauthor: NVARCHAR (500)\rprice: DECIMAL(10,4)\r}\rNet als we in code state kunnen hebben wanneer we onze klasses instantiëren:\nvar book = Book(\u0026#34;0765326353\u0026#34;, \u0026#34;The Way of Kings\u0026#34;, \u0026#34;Brandon Sanderson\u0026#34;, 24.99) var book = new Book(\u0026#34;0765326353\u0026#34;, \u0026#34;The Way of Kings\u0026#34;, \u0026#34;Brandon Sanderson\u0026#34;, 24.99); Zo kunnen we ook state hebben in onze database:\nisbn title author price 0765326353 The Way of Kings Brandon Sanderson 24.99 Elk data model kan een aantal properties bevatten, zoals bovenstaande isbn en title, waarbij een type moet gedefiniëerd worden, zoals bovenstaande NVARCHAR(x). Dit zijn datatype namen die specifiek zijn voor elk DBMS.\nIn de oefeningen gaan wij SQLite gebruiken: zie ook datatypes in SQLite. SQLite\u0026rsquo;s types zijn loosely typed, wat wil zeggen dat er geen verschil is tussen VARCHAR (MSSQL\u0026rsquo;s ASCII) en NVARCHAR (MSSQL\u0026rsquo;s Unicode, UTF-16). Intern worden beide types gemapped naar TEXT. Raadpleeg dus telkens de manual om te controleren welke DBMS welke types ondersteund, en wat deze precies betekenen! Een Java/Kotlin String mapt dus niet altijd 100% op een RDBMS teksttype.\nEen voorbeeld van een simpel database model voor de inventaris van een bibliotheek zou er ongeveer als volgt kunnen uitzien:\nclassDiagram\rBook \"0..*\" --\u003e \"1..*\" Genre\rBook \"1..*\" --\u003e \"1\" Author\rclass Author{\rid: INT\rname: NVARCHAR\rfirstName: NVARCHAR\r}\rclass Genre{\rid: INT\rdescription: NVARCHAR\r}\rclass Book{\risbn: NVARCHAR\rtitle: NVARCHAR\rauthor: INT\rprice: DECIMAL\rgenre: INT\r}\rMerk op dat we hier relaties gebruiken: de DBMS systemen die we eerst behandelen, SQL-varianten, zijn RDBMS systemen: relationele database management systemen. De author in Book is een nummer dat verwijst naar de id van Author in een ander model of tabel. Op deze manier is het mogelijk om, voor elke rij in Author, meerdere Book rijen aan te maken:\ndata class Author(val id: int, val name: string, val books: List\u0026lt;Book\u0026gt;) public class Author { private final int id; private final String name; private final List\u0026lt;Book\u0026gt; books; public Author(int id, int name) { this.id = id; this.name = name; this.books = new ArrayList\u0026lt;\u0026gt;(); } } "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql-ddl-dml/ddl/",
	"title": "1. DDL",
	"tags": [],
	"description": "",
	"content": "Data Defintion Language is de taal die we gebruiken om de structuur van onze database te veranderen. We kunnen hiermee tabellen aanmaken, wijzigen of verwijderen. Maar ook indexen, views, triggers of stored procedures worden hiermee aangemaakt.\nZowat elke RDBMS heeft tooling om DDL te doen via een handige interface, in plaats van dit zelf uit te schrijven. In de praktijk ga je waarschijnlijk met beiden in contact komen. We gaan DB Browser for SQLite gebruiken tijdens onze lessen.\nKijk naar de Chinook database en maak een schematische voorstelling van hoe deze database eruit ziet. Je kan hiervoor Mermaid gebruiken, of een eigen tool of pen en papier.\nTabellen aanmaken en wijzigen Met DDL definiëer je structuur in SQL. Met DML wijzig of manipuleer je de inhoud ervan. De Chinook database bevat natuurlijk reeds tabellen, maar alles begint met een CREATE TABLE statement. Je kan in SQLite Browser rechtsklikken op tabellen en Copy Create Statement kiezen om te reverse-engineeren hoe de tabellen aangemaakt werden.\nBijvoorbeeld, voor albums:\nCREATE TABLE \u0026#34;albums\u0026#34; ( [AlbumId] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, [Title] NVARCHAR(160) NOT NULL, [ArtistId] INTEGER NOT NULL, FOREIGN KEY ([ArtistId]) REFERENCES \u0026#34;artists\u0026#34; ([ArtistId]) ON DELETE NO ACTION ON UPDATE NO ACTION ) Rekening houdend met de vereenvoudigde datatypes van SQLite, zou je het zelf waarschijnlijk ongeveer zo schrijven:\nCREATE TABLE album ( AlbumId INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, Title TEXT NOT NULL, ArtistId INTEGER NOT NULL, FOREIGN KEY ArtistId REFERENCES artists (ArtistId) ) De NO ACTION statements zijn nutteloos. Namen hoeven, afhankelijk van het dialect, al dan niet escaped als [naam] of \u0026quot;naam\u0026quot;. Merk ook op dat bovenstaande SQL zal falen als de tabel artists niet eerst gemaakt wordt, anders kan de DB geen foreign key constraint controle uitvoeren. Meerdere statements worden gebruikelijk gescheiden door puntkomma ;.\nMerk op dat in SQL DDL we keywords met HOOFDLETTER schrijven en tabel of kolomnamen met kleine letter.\nProbleem met je structuur? Geen probleem: DROP TABLE album. Als hier data in zit ben je die ook onherroepelijk kwijt! Kolom vergeten? Geen probleem: ALTER TABLE album ADD COLUMN blah TEXT. Kolom te veel? Geen probleem: ALTER TABLE album DROP COLUMN blah. Not null constraint vergeten? Geen probleem: ALTER TABLE album ALTER COLUMN blah NOT NULL. Oei, syntaxfoutje? SQLite ondersteunt geen alter in alter, andere vendors wel. Check constraint vergeten? Geen probleem: ALTER TABLE album ADD CONSTRAINT my_constraint CHECK(len(blah) \u0026gt; 9) Oei, syntaxfoutje? Zelfde probleem\u0026mdash;enkel op te lossen door DROP en re-create. De CREATE en DROP statements kunnen ook gebruikt worden\u0026mdash;afhankelijk van de compatibiliteit van je RDBMS\u0026mdash;om indexen, aliases, tablespaces, synoniemen, sequenties, \u0026hellip; aan te maken en te verwijderen.\nMaak twee nieuwe tabellen aan: een licenses tabel, die per album (en dus ook artiest) licenties en hun kostprijs opslaat, en een memorabelia tabel die merchandise voor artiesten bevat om te verkopen. Denk goed na over het gebruik van constraints. Voeg daarna met ALTER TABLE kolommen toe om het (variërend) BTW percentage voor beide tabellen te bewaren.\nViews aanmaken Een view is eigenlijk een specifieke query die we een vaste naam geven.\nAls ik een view wil maken van alle tracks van het Rock genre, dan doe ik dat als volgt:\nCREATE VIEW rock_tracks AS SELECT * FROM tracks WHERE GenreId = 1 Vanaf dit punt kan ik in een nieuwe query het volgende uitvoeren:\nSELECT * FROM rock_tracks Merk op dat we vaak geen idee hebben welke ID het genre Rock heeft:\nSELECT * FROM genres WHERE Name = \u0026#39;Rock\u0026#39; In plaats van de resultaten te limiteren op GenreId, kunnen we beide tabellen joinen:\nCREATE VIEW rock_tracks AS SELECT tracks.* FROM tracks INNER JOIN genres ON genres.GenreId = tracks.GenreId WHERE genres.Name = \u0026#39;Rock\u0026#39; Dit kan ook met behulp van een subquery. Zie ook: DDML - JOIN operator en verder, subqueries.\nSchrijf een view die de naam van elke track geeft, alsook de naam van het album en de artiest, gesorteerd op artiest, album en dan track.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql/",
	"title": "1. RDBMS",
	"tags": [],
	"description": "",
	"content": "RDBMS Zie menu links.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/transacties/basics/",
	"title": "1. Transaction Mgmt. Basics",
	"tags": [],
	"description": "",
	"content": "SQL DBMS systemen zijn eerst en vooral multi-user systemen. Om zowel verschillende gebruikers te kunnen behandelen als nog steeds de ACID regels ondersteunen, is er een systeem nodig dat soms gebruikers \u0026ldquo;in wacht\u0026rdquo; zet. Stel je voor dat Jens en Jolien tegelijkertijd data lezen én updaten\u0026mdash;in dezelfde tabel, hetzelfde record. Jens leest uit \u0026ldquo;de rekening staat op 100 EUR\u0026rdquo; en Jolien haalt er 10 EUR vanaf. Wie mag eerst? Kan dit tegelijkertijd? Jens krijgt te horen dat er 100 EUR op de rekening staat, terwijl in werkelijkheid dit 10 EUR minder is.\n0. Waarom transacties? Heel simpel. Dit is het verkeer zonder transacties:\nDit met:\nOm Atomicity, Consistency, Isolation, Durability te garanderen is er dus een transactie manager nodig die alles in goede banen leidt op het moment dat verschillende gebruikers data gaan raadplegen en/of manipuleren. Dit principe is ruwweg hetzelfde als task management van het vak Besturingssystemen en C\u0026mdash;maar dan op database-applicatie niveau.\n1. Wat is een transactie? Een transactie is een set van database operaties (bij relationele databases dus een aantal SQL operaties), dat door één gebruiker of applicatie als één unit of work aanzien wordt. Bijvoorbeeld, Jens wilt geld overschrijven van zijn rekening naar die van Jolien. Dit gaat meestal in verschillende stappen:\nHaal €10 van balans van Jens; Stort €10 op balans van Jolien. graph LR;\rJN[Rekening van Jens]\rJL[Rekening van Jolien]\rJN --\u003e|10 EUR| JL\rDit is één transactie\u0026mdash;het zou nooit mogen gebeuren dat er €10 verdwijnt van Jens\u0026rsquo; account zonder dat Jolien dat geld ontvangt. Met andere woorden, er kan niets tussen stap 1 en stap 2 komen: geen systeem crash, geen andere gebruiker (bijvoorbeeld Marianne die Jens €20 voor zijn verjaardag stort op de rekening). Dit is één \u0026ldquo;unit of work\u0026rdquo;: als er iets misloopt zou alles teruggedraaid moeten worden. Dus, een transactie heeft als resultaat ofwel success, ofwel failure, maar niets tussenin. Indien dit succesvol wordt afgerond zou het DBMS systeem moeten garanderen dat het geld effectief op Jolien\u0026rsquo;s rekening staat. Indien het faalde zou het DBMS systeem moeten garanderen dat Jens zijn geld niet kwijt is.\nIn de praktijk worden veel verschillende transacties tegelijkertijd uitgevoerd\u0026mdash;eventueel door verschillende gebruikers. Er moet dus iemand zijn die dit beheert, en dat is de transactie manager. Wie beslist of Jens eerst zijn geld mag afhalen, of dat Marianne eerst zijn verjaardagscadeau mag overmaken op de rekening? Wie beslist dat tussen stap 1 en 2 bij de transfer van het geld van Jens naar Jolien niemand mag tussenkomen? Juist: de transactie manager. Hier zijn verschillende strategieën voor, zoals we later zullen zien in Concurrency Control.\n2. Het beheren van transacties Formeel gezien wordt er een transactie afgelijnd door aan te kondigen wanneer een transactie begint en wanneer hij stopt, zodat de manager de juiste acties kan doorvoeren. De gebruiker kan met SQL ook zelf een transactie terugdraaien als er een programmafout voorkomt, bijvoorbeeld met een try { ... } catch(Exception ex) { rollback }. Meer hierover in sectie failures/rollbacks.\nDe transactie manager, die afgelijnde transacties ontvangt, kan dit dan in een schedule zetten, om te beslissen welke (delen van) transacties wanneer moeten worden uitgevoerd, net zoals Round Robin CPU scheduling algoritmes. Uiteindelijk wordt er een status toegekend aan een transactie:\nCommitted\u0026mdash;het is gelukt en de data is permanent gepersisteerd. Aborted\u0026mdash;Een error tijdens het uitvoeren van de transactie. Indien er halverwege de abort data is gewijzigd moet dit worden teruggezet, of worden rollbacked. Vorige versies van data moet dus ook worden bijgehouden. Jens\u0026rsquo; rekening kan bijvoorbeeld €90 zijn initieel, hij haalt er €10 af om over te maken wat dit tot €80 maakt, maar er loopt iets mis: de rollback triggert het terugdraaien van het getal 80 naar de originele 90.\nDit is een pseudocode voorbeeld van bovenstaande afgelijnde transactie:\nBEGIN TRANSACTION;\rUPDATE account SET waarde = waarde - :over_te_maken_bedrag\rWHERE eigenaar = \u0026#39;Jens\u0026#39;\rUPDATE account SET waarde = waarde + :over_te_maken_bedrag\rWHERE eigenaar = \u0026#39;Jolien\u0026#39;\rCOMMIT; Transacties kosten CPU en RAM en zijn configureerbaar maar dus gelimiteerd in aantal. De manager kan worden ingesteld tot bijvoorbeeld ondersteunen van maximum 10 transacties tegelijkertijd.\nDBMS Componenten bij een transactie Een voorbeeld van een transactie workflow (de nummers komen overeen met het schema):\nDBMS componenten aan het werk tijdens een transactie. src: pdbmbook.com\rDe manager waarschuwt de scheduler dat er een nieuwe transactie moet worden ingepland. Deze optimaliseert dit naar throughput (zie BESC); De recovery en stored data manager worden op de hoogte gebracht. Deze optimaliseert disk access: het zou kunnen dat DB reads/writes via een buffer verlopen omdat fysieke file operaties duur zijn; De scheduler is nu klaar om input te ontvangen en uit te voeren in de juiste volgorde; Dit triggert mogelijks interactie met de stored data manager (het effectief wegschrijven van wijzigingen); De uitkomst wordt doorgegevan via een output area: ofwel is het gelukt (5b), ofwel is het mislukt (5a), waardoor de recovery manager zijn werk moet doen om dingen terug te draaien. 3. Wat als er iet misgaat? Hoe werkt dat blokje \u0026ldquo;recovery manager\u0026rdquo; precies? Een DBMS systeem gebruikt achterliggend een logfile als belangrijk element om eventuele recoveries te kunnen doorvoeren. Een logfile bevat in principe redundante data: in het beste geval wordt dit nooit gebruikt. Maar in het geval dat er ook maar iets misloopt is het van groot belang dat de log entries kunnen worden gebruikt om de data terug te zetten.\nVoor elke transactie en operatie wordt relevante informatie geregistreerd in de logfile als een log record. Deze bevat de volgende informatie:\nEen unieke Log ID; Een unieke Transactie identifier om de records te kunnen koppelen aan de transacties; Een markering voor de start van de transactie + tijd + type (read/write/read-write combo) aan te duiden; Database record identifiers en operaties (select/insert/\u0026hellip;.) die bij de transactie horen; before images: een snapshot van de data voordat de transactie werd doorgevoerd. Deze worden gebruikt om een undo uit te voeren; after images: een snapshot van de data nadat de transactie werd doorgevoerd. Deze worden gebruikt om een redo uit te voeren, moest bijvoorbeeld een fysieke file write mislukken en hier een retry op worden toegepast. Er wordt altijd eerst in de logfile geschreven: dit noemen we een write-ahead log strategy. Op die manier is de DBMS manager voorbereid op een mogelijke rollback. Alle updates worden dus eerst naar de logfile geschreven voordat er iets fysiek veranderd op de harde schijf. Merk op dat de \u0026ldquo;logFILE\u0026rdquo; ook (gedeeltelijk) in-memory kan zijn.\nWat kan er zoal misgaan? Failures worden in drie groepen opgedeeld:\nTransaction failures: fouten in de logica van de transactie, zoals verkeerde input, incorrecte variabelen, statements die niet kloppen, etc. Sommige applicaties vangen dit al op voordat het naar de DBMS gaat. System failures: DB of OS crashes op de server, bijvoorbeeld door stroomonderbrekingen of bugs in de database zelf. Het zou kunnen dat de DBMS buffer inhoud hierdoor leeg raakt en delen van data niet teruggezet kunnen worden. Media failures: Storage access fouten door bijvoorbeeld disk crashes, een storing in het netwerk, etc. Het zou kunnen dat de logfile niet toegankelijk is. Het is de moeite waard om even te kijken naar de laatste 2 groepen en hoe daar recovery processen precies werken.\nSystem Recovery Veronderstel dat er 5 transacties door de DBMS worden verwerkt. Tc duidt een checkpoint aan van de data in de buffer. Er treedt een systeemfout op rechts bij Tf:\nUNDO/REDO operaties voor 5 \u0026#39;kapotte\u0026#39; transacties. src: pdbmbook.com\rWe bekijken de 5 transacties afzonderlijk:\nT1\u0026mdash;Aangezien deze succesvol werd gecommit voor de systeemfout én voor de snapshot Tc, hoeft hier niets voor te gebeuren na een crash. T2\u0026mdash;Deze transactie is ook compleet voor Tf, maar er zit nog data in de buffer van de snapshot Tc die niet naar disk geschreven werd. Hier is dus een REDO nodig. T3\u0026mdash;Deze transactie was nog bezig bij de crash van Tf. We hebben niet alle data in de buffer: er is dus transactie data verloren gegaan: een UNDO dus. T4\u0026mdash;Deze transactie is gelukt maar alle data is nog steeds pending to disk (bij T2 was dit een deel): REDO. T5\u0026mdash;De DBMS scheduler had deze net ingepland toen het systeem crashte. Het is niet nodig om hier is van terug te draaien omdat er niks pending was (na de Tc checkpoint). Media Recovery Wat doe jij als er een harde schijf gerashed is van je computer? Bidden voor een werkende backup? Indien fysieke files niet meer toegankelijk zijn is een \u0026ldquo;media recovery\u0026rdquo; afhenkelijk van data redundancy principes. Hopelijk heb je een backup strategie voorzien. Voor database systemen wordt dit streng toegepast en moeten we een recovery doorvoeren via een mirror op een andere HDD in RAID, op een cloud backup, een offline backup, \u0026hellip;\nOm de failover time te minimaliseren wordt dit vaak automatisch opgezet. Een harde schijf kan in een server in RAID-1 modus geplaatst worden: die functioneert als 100% clone van de andere. Indien er één van beide HDDs faalt, neemt onmiddellijk de andere het werk over, zodat gebruikers zo goed als geen last hebben van de media failure. Systemen als backup copies door iets te \u0026ldquo;archiveren\u0026rdquo; (een .tar.gz of .zip op bepaalde tijdstippen aan de kant zetten) vereist meestal meer werk om terug te zetten. Backups nemen betekent ook beslissen of het een full of incremental backup zal zijn, waarbij je (1) alle files apart zet, of (2) enkel de wijzigingen ten opzichte van vorige snapshots.\nEen goede backup strategie\u0026mdash;dit geldt zowel voor databases als voor je eigen data!!\u0026mdash;volgt het 1-2-3 backup principe:\nZorg voor minstens drie backups van je data, waarvan twee lokaal maar op verschillende media (bvb, verschillende servers, op HDD en op USB, \u0026hellip;), en één off-site kopie, zoals cloud-based backup systemen als Dropbox, Google Drive, Backblaze\u0026rsquo;s Cloud Storage. Dan hebben we het nog niet over security gehad\u0026hellip;\nDenkvragen Waarom kan je niet gewoon media recovery strategieën toepassen bij systeemcrashes? Waarom wel, maar is dat misschien geen goed idee? Als er verschillende transacties tegelijkertijd aan één record iets wijzigen, welke problemen zie jij dan zoal? Hoe zou je dat door de transaction manager laten oplossen? Kan je zo twee verschillende oplossingen bedenken? Wat is alweer het verschil tussen UNDO en REDO recovery technieken? Als ier iets misgaat op applicatieniveau, bijvoorbeeld een crash in je Java applicatie, moet de DBMS dan iets doen, of moet de programmeur dan iets doen, om ACID te blijven garanderen? Wat zou er volgens jou moeten gebeuren als twee personen tegelijkertijd op bol.com een item bestellen waarvan maar één hoeveelheid in stock is? Wie trekt hier aan het korte eind? Hoe vangen grote webwinkels dit probleem op? "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/transacties/concurrency-control/",
	"title": "2. Concurrency Control",
	"tags": [],
	"description": "",
	"content": "De transactie management scheduler (zie transacties - basics) is verantwoordelijk om verschillende transacties correct in te plannen zonder dat er data problemen of clashes optreden.\n1. Problemen? Welke problemen? Denk terug aan het bank transfer probleem van de vorige sectie. Veronderstel dat deze keer zowel Jens als Marianne €10 willen overmaken naar Jolien. Als we dat als volgt doen:\nVerminder bedrag van source rekening Verhoog bedrag van destination rekening Dan zou het kunnen dat bij het uitlezen van #2, Jolien\u0026rsquo;s rekening op €100 staat. Maar als de transactie van Marianne dit ook leest als €100, en niet wacht tot de €110 die het zou moeten zijn na de commit van de transactie van Jens, dan gaat in totaal Marianne slechts €10 rijker zijn in plaats van twee keer dat bedrag. Oeps!\ngraph LR;\rJN[Rekening van Jens]\rJL[Rekening van Jolien]\rML[Rekening van Marianne]\rJN --\u003e|10 EUR| JL\rML --\u003e|10 EUR| JL\rHieronder volgen een aantal veel voorkomende concurrency problemen die de transaction scheduler uitdagen.\nA. Lost Updates Dit is exact bovenstaande situatie. Het UPDATE statement van Jens\u0026rsquo; transactie (verhoog Jolien\u0026rsquo;s rekening met 10) is \u0026ldquo;verloren\u0026rdquo;, omdat Marianne hier tussen komt, en haar UPDATE die terug ongedaan maakt:\ntime T1 (Marianne) T2 (Jens) bedrag 1 begin trans 100 2 begin trans read(bedrag): 100 100 3 read(bedrag): 100 bedrag = bedrag + 10 100 4 bedrag = bedrag + 10 write(bedrag) 110 5 write(bedrag) commit 110 (oeps) 6 commit 110 Dit voorbeeld illustreert dat, alhoewel beide transacties 100% correct zijn, er toch nog problemen kunnen optreden als transacties elkaar gaan storen. Het spreekt voor zich dat als T1 data zou lezen en schrijven uit een andere rij of tabel, dit geen probleem zou zijn\u0026mdash;in dit specifieke voorbeeld.\nB. Dirty Reads Een \u0026ldquo;dirty read\u0026rdquo; probleem is het lezen van uncommited \u0026ldquo;dirty\u0026rdquo; data\u0026mdash;data die eigenlijk voor de andere transactie nog niet zichtbaar mat zijn omdat het hier over uncommitted data gaat. Als Marianne\u0026rsquo;s read(bedrag) toch het juiste bedrag zou inlezen (110), voordat Jens\u0026rsquo; transactie compleet is, maar op een of andere manier is die transactie teruggedraaid, dan spreken we over een dirty read, en krijgt Jolien onterecht toch €20, terwijl Jens zijn €10 mag houden. It prints money!\ntime T1 (Marianne) T2 (Jens) bedrag 1 begin trans 100 2 read(bedrag): 100 100 3 bedrag = bedrag + 10 100 4 begin trans write(bedrag) 110 5 read(bedrag): 110 110 6 bedrag = bedrag + 10 ROLLBACK! 120 (oeps) 7 write(bedrag) 120 8 commit 120 C. Inconsistent Analysis Bij inconsistente analyse tussen twee transacties gaat het over een sequentie van verschillende dirty reads die de situatie alleen maar verergeren, zelfs zonder de eventuele rollback. Stel dat het over te schrijven bedrag in stukjes van €2 wordt overgeschreven, waarbij telkens tussenin een read(bedrag) plaats vindt\u0026mdash;die natuurlijk de data van de andere transactie inleest. Het resultaat is, opnieuw, een veel te grote som, en een mogelijks erg blije Jolien.\nWe laten een schematische voorstelling van dit probleem als oefening voor de student.\n\u0026hellip; En meer Er zijn nog verschillende andere mogelijkheden waarbij de scheduler de bal kan misslaan. Bijvoorbeeld door non-repeateable reads: transactie T1 leest dezelfde rij verschillende keren in maar verkrijgt telkens andere waardes (wat niet zou mogen) vanwege andere transacties die ook met die rij bezig zijn.\nOf wat dacht je van phantom reads: transactie T2 is bezig met rijen effectief te verwijderen, terwijl T1 deze toch nog inleest. Het zou kunnen dat hierdoor verschillende rijen ontstaan (T2 rollback, T1 die een nieuwe rij maakt), of dat voorgaande bestaande rijen verdwijnen door T2, waardoor de transactie van T1 mogelijks faalt.\nTeruggrijpende naar ons Jolien voorbeeld, stel dat Jens Jolien €5 wilt betalen per klusje dat ze gedaan heeft. Klusjes worden opgeslagen in een aparte tabel, maar ondertussen kan Jolien een nieuw klusje afvinken, waardoor Jens\u0026rsquo; transactie een phantom read krijgt:\ntime T1 (Jens) T2 (Jolien) klusjes 1 read 1: SELECT * FROM klusjes WHERE naam = 'Jolien' (2) 2 2 2 3 random ander werk INSERT INTO klusjes ... 3 4 3 5 read 2: SELECT * FROM klusjes WHERE naam = 'Jolien' (3, oeps) 3 6 sort 3x5 op rekening (teveel) 3 7 commit Bijgevolg verkgijt T1 inconsistente data: de ene keer 2, de andere keer 3\u0026mdash;vergeet niet dat het goed zou kunnen dat T2 nog teruggedraaid wordt.\nWat is het verschil tussen een non-repeatable read, een phantom read, en een dirty read? Dirty reads lezen foutieve uncommitted data van een andere transactie\u0026mdash;het lezen van \u0026lsquo;in progress\u0026rsquo; data. Non-repeateable reads en phantom reads lezen foutieve committed data van een andere transactie. Bij non-repeatable reads gaat het over UPDATEs, en bij phantom reads over INSERTs en/of DELETEs: rijen die plots verschijnen of zijn verdwenen sinds de transactie begon.\n2. Scheduler oplossingen Wat is de simpelste manier om bovenstaande problemen allemaal integraal te vermijden? Juist ja\u0026mdash;sequentieel transacties verwerken.\nA. Serial scheduling Met serial scheduling is T2 verplicht te wachten op T1 totdat die zijn zaakje op orde heeft. De lost update transactie flow van hierboven ziet er dan als volgt uit:\ntime T1 (Marianne) T2 (Jens) bedrag 1 begin trans 100 2 read(bedrag): 100 100 3 bedrag = bedrag + 10 100 4 write(bedrag) 110 5 commit 110 6 begin trans 110 7 read(bedrag): 110 110 8 bedrag = bedrag + 10 120 9 write(bedrag) 120 10 commit 120 Wat valt je op als je naar de time kolom kijkt? Serial scheduling duurt nu 10 ticks t.o.v. 6 bij de potentiële lost update\u0026mdash;da\u0026rsquo;s een redelijk grote performance hit van 40%! Serial scheduling lost misschien wel alles op, maar daardoor verliezen we alle kracht van het woord parallel: dit is in essentie non-concurrency.\nWat zijn dan betere scheduling alternatieven?\nB. Optimistic scheduling Bij \u0026ldquo;optimistic\u0026rdquo; scheduling gaan we ervan uit dat conflicten tussen simultane transacties nauwelijks voorkomen. Met andere woorden, we benaderen het probleem (misschien te) optimistisch. Transacties mogen gerust tegelijkertijd lopen als ze bijvoorbeeld verschillende tabellen of stukken data in dezelfde tabel bewerken\u0026mdash;zolang er geen conflict is, geniet paralellisatie de voorkeur.\nBij optimistische schedulers worden alle transactie operaties doorgevoerd. Wanneer deze klaar zijn voor een eventuele COMMIT, wordt er gecontroleerd op potentiële conflicten. Indien geen, success. Indien wel, abort en ROLLBACK.\nMerk op dat rollback operaties erg dure operaties zijn: de manager moet graven in de logfile, moet beslissen of er UNDO/REDO operaties moeten worden uitgevoerd, er is mogelijke trage disc access (I/O), \u0026hellip; Als je vaak rollbacks hebt/verwacht is optimistic scheduling nog steeds geen performant alternatief.\nC. Pessimistic scheduling Bij \u0026ldquo;pessimistic\u0026rdquo; scheduling gaan we van het omgekeerde uit: transacties gaan heel zeker conflicteren. De scheduler probeert transactie executies te verlaten om dit zo veel mogelijk te vermijden. Een serial scheduler is een extreem geval van een pessimistic scheduler.\nLocking In de praktijk wordt locking gebruikt op een pre-emptive manier (zie besturingssystemen: scheduling algorithms) om toch transacties waar mogelijk concurrent te laten doorlopen. Bij transacties die schrijven in plaats van die enkel lezen zullen locks eerder nodig zijn. Er bestaan uiteraard erg veel verschillende locking technieken/algoritmes.\nWe maken onderscheid tussen twee groepen:\nexclusive locks: als T1 een exclusieve lock neemt, kan er geen enkele andere transactie op die database worden uitgevoerd. Dit is een erg strict systeem, denk aan serial scheduling. shared locks: zolang T1 een lock neemt op een object (zie onder), krijgt het de garantie dat geen enkele andere transactie dat object kan manipuleren totdat de lock terug wordt vrijgegeven (eventueel ook door middel van een rollback). Locks worden \u0026ldquo;gedeeld\u0026rdquo;: T1 krijgt write access, en T2 moet wachten met schrijven, maar mag wel lezen. De database \u0026ldquo;objecten\u0026rdquo; waar een lock op genomen kan worden zijn onder andere (van kleine locks naar groot):\nrow locks; column locks; page locks (delen van een tabel zoals stored in files); table locks; databas locks (bvb een file lock in SQLite); Een lock op één rij in beslag genomen door T1 betekent dat voor diezelfde tabel T2 nog steeds bedragen kan wijzigen van een andere rekening. Column locks kunnen tot meer wachttijd leiden. Page locks zijn \u0026ldquo;stukken\u0026rdquo; van een tabel (rijen voor x en erna). Een page is een chunk van een tabel die op die manier wordt opgeslaan. Dit verschilt van DB implementatie tot implementatie. Tenslotte kan een hele tabel gelockt worden\u0026mdash;of de hele tablespace\u0026mdash;wat meer pessimistisch dan optimistisch is.\nLocks zijn onderhevig aan dezelfde nadelen als rollbacks: ze zijn duur. Als er erg veel row locks zijn op een bepaalde tabel kan dit veel CPU/RAM in beslag nemen. In dat geval kan de lock manager beslissen om aan lock escalation te doen: de 100 row locks worden één page of table lock. Dit vermindert resource gebruik drastisch\u0026mdash;maar zou transacties ook langer kunnen laten wachten. You win some, you lose some\u0026hellip;\nProblemen bij oplossen van problemen: deadlocks Stel dat Jens cash geld wilt deponeren, en Marianne hem ook geld wenst over te schrijven. Voordat Marianne dat doet koopt ze eerst nog een cinema ticket. Jens wil ook een ticket in dezelfde transactie. Het gevolg is dat T1 en T2 oneindig op elkaar blijven wachten. Dat ziet er zo uit:\ngraph LR;\rC{Cinema tabel}\rR{Rekening tabel}\rJ[Jens]\rM[Marianne]\rJ --\u003e|deposit 10| R\rM --\u003e|transfer 10| R\rM --\u003e|koop ticket| C\rJ --\u003e|koop ticket| C\rDe kruisende pijlen duiden al op een conflict:\ntime T1 (Jens) T2 (Marianne) 1 begin tarns 2 begin tarns 3 update rekening (acquire lock R) 4 update cinema (acquire lock C) 5 poging tot update cinema (WACHT) 6 poging tot update rekening (WACHT) Deze (simpele) deadlock kan gelukkig gedetecteerd worden door het DBMS systeem. Die zal één van beide transacties als \u0026ldquo;slachtoffer\u0026rdquo; kiezen en die transactie terugdraaien\u0026mdash;meestal gebaseerd op welke het makkelijkste is om terug te draaien. Het probleem is dat de meeste applicaties niet onmiddellijk voorzien zijn op zo\u0026rsquo;n onverwachte rollback. Dit resulteert meestal in een negatieve gebruikerservaring.\nDeadlocks en algoritmes om dit te detecteren en op te lossen zijn erg complexe materie. Het volstaat om bovenstaand eenvoudig voorbeeld te kennen, en te weten hoe dat aangepakt zou kunnen worden\u0026mdash;bijvoorbeeld met starvation, timeouts, en priority shift principes zoals ook gezien in het vak Besturingssystemen en C.\nZie ook A beginners guide to DB deadlocks.\nIsolation levels Pessimistic locking kan veel problemen opvangen, maar ten koste van performantie\u0026mdash;wat meestal belangrijker is. Voor veel transacties is het oké om met een minimum aan conflicten de throughput van transacties zo hoog mogelijk te houden. De meeste DBMS systemen zijn hier flexibel in: je kan wat we noemen isolation levels instellen, dat meestal bestaat uit de volgende vier opties (van low naar high isolation):\nRead uncommited\u0026mdash;Dit laat toe om \u0026ldquo;uncommited\u0026rdquo; data te lezen (dat problemen geeft, zie boven), en wordt meestal gebruikt in combinatie met read-only transacties. Read committed\u0026mdash;Gebruikt short-term read locks en long-term write locks, en lost zo het inconsistent analysis/lost update probleem op, maar is niet krachtig genoeg om phantom reads tegen te houden. Repeatable read\u0026mdash;Gebruikt long-term read \u0026amp; write locks. Een transactie kan zo dezelfde rij verschillende keren opnieuw lezen zonder conflicten van insert/updates van andere transacties. Het phantom read probleem is echter nog steeds niet opgelost. Serializable\u0026mdash;het krachtigste isolation level dat in theorie aansluit met serial scheduling. Een short-term lock wordt enkel vastgehouden gedurende het interval dat nodig is om een operatie af te ronden, terwijl long-term locks een protocol volgen en meestal tot de transactie commited/rollbacked is vastgelegd zijn.\nMerk op dat voor elke database implementatie de selectie van een isolation level andere gevolgen kan hebben! Zie de tabellen in https://github.com/changemyminds/Transaction-Isolation-Level-Issue. Het is dus van belang de documentatie van je DB te raadplegen, zoals deze van Oracle, waarin de volgende beschrijving staat voor TRANSACTION_SERIALIZABLE: \u0026ldquo;Dirty reads, non-repeatable reads and phantom reads are prevented.\u0026rdquo;.\nWe komen hier nog later op terug in concurrency in practice wanneer we bijvoorbeeld bij JPA of Hibernate aangeven welk isolation level gewenst is.\nDenkvragen Waarom is het phantom read probleem niet opgelost bij isolation level 3 (repeatable read)? Kan je nog andere situaties verzinnen waarin een deadlock kan voorkomen? Welk isolation level of scheduling algoritme lost dit op? Wat is de verantwoordelijkheid van de DBMS\u0026rsquo;s transactie management systeem in verhouding tot de ACID eigenschappen? Welke impact heeft lock granulariteit op transactie throughput? "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql/rdbms-components/",
	"title": "2. Database Componenten",
	"tags": [],
	"description": "",
	"content": "1. Three Layer Architecture Logical Layer De Logical Layer is waar we bepalen hoe onze data gestructureerd wordt. Hier bepalen we wat voor data we bijhouden, hoe die data eruitziet en hoe die zich gedraagt ten op zichte van onze andere datamodellen.\nEnkele voorbeelden hiervan zijn:\nEen BOEK mag door maximum 0 of 1 PERSONEN ontleend worden. Een PERSOON mag meerdere BOEKEN ontlenen. Een PERSOON is een subtype van een GEBRUIKER. Oefening Hoe zou een database model van een bibliotheek eruit zien? Teken zelf eens uit hoe dit gemodelleerd zou kunnen worden. Hoe houdt ik bij dat een boek uitgeleend werd? Wat als ik ook andere dingen wil uitlenen uit de bibliotheek, zoals DVD\u0026rsquo;s of eBooks? Internal Layer De Internal Layer houdt zich bezig met alle details over hoe de data bewaard wordt. Sommige van de concepten die hier aan bod komen zijn de volgenden:\nIndex management Constraint definities (uniek, referentieel, \u0026hellip;) Gepartitioneerde tabellen \u0026hellip; Deze technologieën hebben allemaal te maken met performantie of data integriteit. We willen onze data op een zo\u0026rsquo;n performante manier opslaan én nog belangrijker op een zo performante manier terug ophalen.\nIndexatie Data wordt ongestructureerd bijgehouden in een tabel. Een tabel is eigenlijk niet meer dan een ongesorteerde lijst van gegevens. Bij elke nieuw element wordt dat aan het eind van de lijst toegevoegd.\nWat als we nu uit een lijst van miljoenen boeken de verzamelde werken van Tolkien willen ophalen? In plaats van door de hele lijst één voor één te gaan zoeken, kunnen we gelukkig gebruik maken van indexen.\nEen index is een inhoudstafel die we bijhouden van een bepaald aantal velden van onze tabel. Stel we hebben een Book tabel met miljoenen rijen, waaronder de volgende:\nid isbn title author price 1345 0765326353 The Way of Kings Brandon Sanderson 24.99 6789 0395177111 The Hobbit J.R.R. Tolkien 24.99 3240 0812511816 The Eye of the World Robert Jordan 24.99 8939 0358439191 The Lord of the Rings J.R.R. Tolkien 24.99 1230 0143111582 Dune Frank Herbert 24.99 Als we een index zouden leggen op de author kolom dan zou die volgende informatie kunnen bevatten:\nauthor id Brandon Sanderson 1345 Frank Herbert 1230 J.R.R. Tolkien 6789 J.R.R. Tolkien 8939 Robert Jordan 3240 Een index houdt een mini-tabel bij van de velden die aan de index worden toegevoegd in combinatie met het identity1 veld. Deze tabel is wel gesorteerd op de velden uit de index, wat zoekopdrachten versnelt.\nConstraints We kunnen onze tabellen behoeden van corrupte data te bevatten door constraints te gebruiken. Het ISBN veld is bijvoorbeeld een uniek veld en mag nooit een waarde bevatten die al gekend is in onze database. Hiervoor kunnen we een unique constraint toevoegen. Bij data insertion gaat de database zelf nakijken of deze value al bestaat en zo ja wordt het toevoegen van de record geblokkeerd. Zo behouden we onze data integriteit.\nAndere voorbeelden van constraints kunnen zijn:\nDe prijs van een boek moet groter dan 0 zijn Een boek kan niet verwijderd worden als het ooit werd uitgeleend Het ISBN-13 nummer moet 13 karakters hebben Het ISBN nummer moet - een aantal keren bevatten Een naam veld mag niet NULL (niet ingevuld) zijn Een email veld moet @ bevatten \u0026hellip; Hoe constraints in de praktijk worden toegevoegd aan data modellen wordt behandeld in het hoofdstuk SQL DDL \u0026amp; DML. Zie ook SQLite table-constraint syntax.\nGepartitioneerde tabellen Sommige tabellen in productie omgevingen bevatten immense hoeveelheden aan data. We spreken over een grootorde van meerdere miljarden rijen. Hoe groter een tabel wordt, hoe trager het wordt om data op te halen. Het maakt niet uit hoeveel indexen we hebben gelegd, of welke SSD schijven we onderliggend op de fysieke storage hebben zitten. Meer data gaat altijd gelijk staan aan tragere data retrieval.\nOm tegen te gaan dat we tabellen krijgen die té groot worden en we daar niet meer zinvol data van kunnen ophalen bestaan hier een paar oplossingen voor. Het partitioneren van tabellen is er eentje van. Archivatie is een andere oplossing.\nNeem als voorbeeld een bank, die elke overschrijving van een rekening moet bewaren. De overschrijving tabel zou kunnen gepartitioneerd worden op jaar. Zodat er nog steeds 1 tabel overschrijving is, maar waarbij we die op de fysieke schijf opsplitsen per jaar, en elke op bijvoorbeeld de recentste 3 jaren index management voor bijhouden. De andere jaren kunnen nog steeds opgevraagd worden maar niet met dezelfde performantie als de meest recente data.\nExternal Layer De External Layer is wat we van onze database laten zien aan de buitenwereld. Dit zijn views van data. Een view is een virtuele representatie van data. We schrijven een query op onze tabellen en bewaren deze query als een view. Op deze manier kunnen we garanderen aan integrerende applicaties dat onze data er steeds hetzelfde gaat uitzien en tevens beschermen van informatie die voor het integrerende systeem niet relevant is.\nIn onze bibliotheek kunnen we een aantal views osptellen op basis van de noden van de verschillende applicaties. In het online platform waar je boeken kan uitlenen is het niet nodig de informatie over een auteur als een aparte entiteit weer te geven. We kunnen de tabel van Authors dus verbergen en enkel een view aanbieden op niveau van Books die er als volgt zou uitzien:\nclassDiagram\rclass LendingAppBooks{\risbn: NVARCHAR\rtitle: NVARCHAR\rauthor: NVARCHAR\rprice: DECIMAL\rgenre: NVARCHAR\r}\rVoor de inventaris applicatie moeten we wel in staat zijn om nieuwe boeken en auteurs toe te voegen. Daar kunnen de views er dan als volgt uitzien:\nclassDiagram\rInventoryBooks \"1..*\" --\u003e \"1\" InventoryAuthors\rclass InventoryAuthors{\rid: INT\rname: NVARCHAR\rfirstName: NVARCHAR\r}\rclass InventoryBooks{\risbn: NVARCHAR\rtitle: NVARCHAR\rauthor: INT\rprice: DECIMAL\r}\r2. Catalog Dit is het hart van de de database. Dit bevat alle metadata die zich in de database bevindt. Onder andere, de tabellen; views; stored procedures; \u0026hellip;\nDe SQL standaard om deze informatie in te bewaren is in INFORMATION_SCHEMA. Niet alle SQL Database providers voldoen hier echter aan. SQLite doet dit niet en daar vind je die informatie in de tabel sqlite_master.\n3. Database Languages SQL is onderverdeeld in twee verschillende talen. Enerzijds heb je DDL (Data Definition Language). Dit gebruik je om de database structuur te wijzigen. Nieuwe tabellen toevoegen, indexen aanmaken, views verwijderen, \u0026hellip;\nAnderzijds heb je DML (Data Manipulation Language). Dit gebruik je voor alle CRUD (Create, Read, Update, Delete) acties op data. Hier gaan we in een volgend hoofdstuk verder op in gaan.\nEigenlijk niet het Identity veld, maar het veld dat in de Clustered Index zit van de tabel. Als er dan in de query meer informatie nodig is om op te halen kan die via die manier de rest van de data ophalen.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql-ddl-dml/dml/",
	"title": "2. DML",
	"tags": [],
	"description": "",
	"content": "Data Modification Language is de taal die we gebruiken om de data van onze database te bekijken of aan te passen. Met DML kunnen we CRUD operaties uitvoeren. Create, Read, Update en Delete.\nSELECT SELECT is het commando dat we gebruiken om data op te vragen uit de database.\nSELECT { DISTINCT } expression\rFROM table\r{ WHERE condition } LIKE operator LIKE wordt gebruikt om wildcard searches uit te voeren. Deze kan enkel gebruikt worden op alfanumerieke velden.\n% is een match anything character voor een onbeperkt aantal karakters (0 tot n). Zo matcht Gen% met volgende waardes: Gen, Genk, Gent, Genève, Genua, \u0026hellip;\n_ is een match anything character voor één karakter. Zo matcht Gen_ met volgende waardes: Genk, Gent, \u0026hellip; Maar niet met volgende waardes: Gen, Genève, Genua, \u0026hellip;\nNULL NULL is het ontbreken van een waarde. Het is een onbekende. We kunnen in DML niet zomaar vergelijken met NULL. We kunnen namelijk niet zeggen dat een onbekende gelijk is aan een andere onbekende.\nHieronder een overzicht van een binary AND table met True, False en NULL waardes.\nAND True False NULL True True False NULL False False False False NULL NULL False NULL Denkvraag: Waarom is False == NULL gelijk aan False?\nHieronder vinden we de binary OR table met True, False en NULL waardes.\nOR True False NULL True True True True False True False NULL NULL True NULL NULL Als we willen vergelijken met NULL in queries, dan gebruiken we volgende code:\n\u0026lt;value\u0026gt; IS NULL\nen\n\u0026lt;value\u0026gt; IS NOT NULL\nSchrijf een query die alle Customers (volledige naam, customer ID en land) laat zien die niet wonen in de USA. Schrijf een query die enkel de Customers laat zien die in Brazilië wonen. Schrijf een query die alle Employees laat zien die werken in de Sales afdeling. Schrijf een query die een unieke lijst van landen laat zien uit de Invoices tabel. Schrijf een query die alle Tracks laat zien waarvoor er geen componist bekend is. Schrijf een query van alle unieke Componisten. Als de componist niet bekend is, dan moet er \u0026lsquo;Onbekend\u0026rsquo; weergegeven worden gesorteerd op naam. Schrijf een query die het maximumbedrag van alle Invoices laat zien. JOIN Wanneer we informatie willen ophalen uit meerdere tabellen dan gebruiken we daar een JOIN statement voor. Die syntax ziet er als volgt uit:\nSELECT { DISTINCT } expression\rFROM table\rINNER JOIN other_table ON join_condition\r{ WHERE condition } Hiermee matchen we alle data van de ene tabel met de andere tabel op de meegegeven conditie. Er bestaan drie verschillende types JOINs:\nINNER JOIN - Geeft alle resultaten die bestaan zowel in de ene als de andere tabel LEFT JOIN - Geeft alle resultaten die bestaan in de base tabel, ook al bestaan die niet in de tabel waarop we joinen RIGHT JOIN - Wordt in de praktijk zelden tot nooit gebruikt. Geeft alle resultaten die bestaan in de gejoinde tabel ook al bestaan ze niet in de base tabel. Schrijf een query die alle Invoices laat zien van alle Customers uit Brazilië. Het resultaat moet de volledige naam van de Customer, Invoice ID, Invoice Datum en Billing Country weergeven. Schrijf een query die alle Invoices laat zien voor elke Sales Agent. Het resultaat moet de volledige naam van de Sales Agent weergeven. Schrijf een query die het Invoice Totaal, de Customer naam en land en de naam van de Sales Agent weergeeft voor alle Invoices en Customers. Schrijf een query die het aantal invoice lijnen weergeeft voor Invoice ID 37. Schrijf een query die de track naam weergeeft langs elke invoice lijn. Schrijf een query die de track naam en de artiest naam weergeeft langs elke invoice lijn. Schrijf een query die alle tracks laat zien, maar geen ID\u0026rsquo;s. Het resultaat moet de album titel, het media type en het genre bevatten. Schrijf een query die alle genres weergeeft waarvoor er geen tracks bestaan. GROUP BY Soms willen we data aggregeren. In Basic Engineering Skills in Python werd aggregratie gebruikt om bijvoorbeeld de som van een lijst te nemen, of met funtools.reduce() een custom functie los te laten op een lijst. (Dit gaan we ook nog zien in het hoofdstuk rond NoSQL \u0026ndash; Advanced map-reduce queries).\nIn RDBMS bestaan hiervoor een aantal verschillende functies. De meest courante zijn hieronder te vinden:\nMAX() MIN() COUNT() AVG() SUM() Elke waarde die je extra selecteert in een query bovenop een aggregate function, moet in een GROUP BY clause komen. Hoe ziet dit er dan bijvoorbeeld uit?\nSELECT BillingCity, SUM(Total) FROM Invoices GROUP BY BillingCity Zonder GROUP BY statement krijg je ofwel een fout ofwel maar één record terug, zoals in SQLite.\nHAVING Als we willen filteren op een grouping function, dan gaat dat niet via een WHERE clause, dan krijg je namelijk een foutmelding:\nSELECT BillingCity, count(*) FROM invoices WHERE count(*) \u0026gt; 2 GROUP BY BillingCity Om te filteren op een grouping function schrijven we dit in een HAVING clause die de query gebruikerlijks afsluit:\nSELECT BillingCity, count(*) FROM invoices GROUP BY BillingCity HAVING count(*) \u0026gt; 2 Schrijf een query die het aantal Invoices laat zien voor 2009 en 2011. Schrijf een query die het aantal invoices per land laat zien. Schrijf een query die per Invoice ID het aantal invoice lijnen laat zien. Schrijf een query die de naam van elke playlist laat zien, alsook het aantal tracks in elke playlist. Schrijf een query die alle data uit de Invoices tabel laat zien, aangevuld met het aantal invoice lijnen. Schrijf een query die de totale verkoopcijfers per Sales Agent laat zien. Schrijf een query die laat zien welke Sales Agent de grootste verkoopcijfers heeft voor 2009. Schrijf een query die laat zien welke Sales Agent de grootste verkoopcijfers heeft voor 2010. Schrijf een query die laat zien welke Sales Agent de grootste verkoopcijfers heeft over alle jaren heen. Schrijf een query die het aantal Customers laat zien per Sales Agent. Schrijf een query die de totale verkoopcijfers per land laat zien. In welk land werd er het meest uitgegeven? Schrijf een query die laat zien welke track er in 2013 het meest werd verkocht. Schrijf een query die laat zien wat de top 5 tracks zijn die ooit werden verkocht. Schrijf een query die laat zien wie de top 3 artiesten zijn die het meest verkocht werden. Schrijf een query die laat zien welk media type het meest verkocht werd. Schrijf een query die de tracks laat zien die meer dan 4 keer verkocht zijn. Subqueries Een query die we uitvoeren geeft een set van resultaten terug. Die set kunnen we opnieuw gebruiken als input voor een nieuwe query. We kunnen die set op verschillende plaatsen gebruiken als input voor een nieuwe query. Hieronder een aantal voorbeelden.\nIn een WHERE clause SELECT * FROM invoice_items WHERE invoice_items.TrackId IN ( SELECT tracks.TrackId FROM tracks WHERE name LIKE \u0026#39;%hell%\u0026#39; ) In een FROM clause SELECT * FROM ( SELECT tracks.TrackId, tracks.Name FROM tracks WHERE name LIKE \u0026#39;%hell%\u0026#39; ) In een JOIN clause SELECT * FROM tracks INNER JOIN ( SELECT tracks.TrackId, tracks.Name FROM tracks WHERE name LIKE \u0026#39;%hell%\u0026#39; ) hell_tracks ON hell_tracks.TrackId = tracks.TrackId Subqueries in een WHERE IN statement worden geëvauleerd voor elke voor elke rij uit de outer query, dus zijn eigenlijk niet zo heel performant. We kunnen dat iets verbeteren door dat te herschrijven naar een WHERE EXISTS statement. Zie hieronder.\nSELECT * FROM invoice_items WHERE EXISTS ( SELECT 1 FROM tracks WHERE name LIKE \u0026#39;%hell%\u0026#39; AND tracks.TrackId = invoice_items.TrackId ) De IN clause gaat een subquery volledig ophalen om alle rijen te hebben om dan in die lijst van rijen te kunnen zoeken. Een EXISTS clause gaat een subquery maar zo lang uitvoeren tot er een resultaat gevonden is. Als de tabel uit de subquery 1000 rijen bevat en er wordt een match gevonden op rij 200, dan gaan de andere 800 niet meer geëvauleerd worden.\nDe meeste van deze queries kunnen ook geschreven worden met een JOIN statement. Dit is echter niet waar we hier op willen oefenen. Los dus volgende oefeningen op met minstens één subquery. Als je hier moeite mee hebt kan her handig zijn om eerst een werkende query te bekomen met JOIN en die dan om te vormen naar een subquery.\nSchrijf een query die alle invoices laat zien die een track bevatten van Iron Maiden. Schrijf een query die alle invoices laat zien die verkocht werden door Margaret Park. Schrijf een query die alle genres laat zien waarvoor er geen track bestaat. Schrijf een query die alle invoices laat zien waarvan de prijs groter is dan het gemiddelde van alle invoices. Schrijf een query die alle invoices laat zien waarin een Metallica track verkocht is, waarvan de prijs groter is dan het gemiddelde van alle invoices waarin een Metallica track verkocht is. Data manipulatie INSERT Met een INSERT Statement gaan we data toevoegen in de database. We gebruiken een column listing om aan te geven welke kolommen, in welke volgorde, we van een waarde kan voorzien. Kolommen die NULL values ondersteunen mogen uit de column listing gelaten worden.\nINSERT INTO Genres(Name) VALUES(\u0026#39;Rock\u0026#39;) Voeg je favoriete album (inclusief artiest en tracks) toe aan de database.\nUPDATE Met een UPDATE statement kunnen we één of meerdere waardes in een set van data aanpassen.\nUPDATE Tracks SET MediaTypeId = 1 WHERE AlbumId = 2 Wijzig de UnitPrice en de Composer voor de 3e track van je toegevoegde album. Wijzig de titel van je favoriete album (zie oefening hierboven).\nDELETE Hiermee kunnen we een set van data verwijderen.\nLET OP! Een DELETE statement zonder WHERE clause verwijdert alles uit de tabel!\nDELETE FROM Genre WHERE Name = \u0026#39;Rock\u0026#39; Verwijder het album (inclusief artiest en tracks) dat je hierboven hebt toegevoegd.\nWat is volgens jou het verschil tussen DELETE FROM zonder WHERE en DROP TABLE?\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/sql-ddl-dml/",
	"title": "2. SQL DDL &amp; DML",
	"tags": [],
	"description": "",
	"content": "SQL DDL \u0026amp; DML Zie menu links.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/transacties/failures-rollbacks/",
	"title": "3. Failures-Rollbacks",
	"tags": [],
	"description": "",
	"content": "Voorbereidende CREATE statements (Dit is SQLite syntax!) Zie SQLite manual:\nDROP TABLE IF EXISTS student; CREATE TABLE student( studnr INT NOT NULL PRIMARY KEY, naam VARCHAR(200) NOT NULL, voornaam VARCHAR(200), goedbezig BOOL ); DROP TABLE IF EXISTS log; CREATE TABLE log( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, date DATETIME DEFAULT CURRENT_TIMESTAMP, foreign_id INT NOT NULL, msg TEXT ); INSERT INTO student(studnr, naam, voornaam, goedbezig) VALUES (123, \u0026#39;Trekhaak\u0026#39;, \u0026#39;Jaak\u0026#39;, 0); INSERT INTO student(studnr, naam, voornaam, goedbezig) VALUES (456, \u0026#39;Peeters\u0026#39;, \u0026#39;Jos\u0026#39;, 0); INSERT INTO student(studnr, naam, voornaam, goedbezig) VALUES (890, \u0026#39;Dongmans\u0026#39;, \u0026#39;Ding\u0026#39;, 1); 1. System failure simulatie 1.1 In SQLite met DB Browser Gegeven een aantal SQL statements, waarvan niet alle statements kloppen, maar die wel allemaal bij elkaar horen als één atomaire transactie. Dat betekent dat als er één van die statements misloopt, de rest teruggedraait zou moeten worden. Het spreekt voor zich dat zonder speciale handelingen, zoals het beheren van transacties, dit niet gebeurt. Een eenvoudig voorbeeld demonstreert dit.\nUPDATE student SET voornaam = \u0026#39;Jaqueline\u0026#39; WHERE studnr = 123; INSERT INTO oeitiskapot; INSERT INTO log(foreign_id, msg) VALUES (123, \u0026#39;Voornaam vergissing\u0026#39;); INSERT INTO student(studnr, naam, voornaam, goedbezig) VALUES (445, \u0026#39;Klakmans\u0026#39;, \u0026#39;Jef\u0026#39;, 1); INSERT INTO log(foreign_id, msg) VALUES (445, \u0026#39;Nieuwe student registratie\u0026#39;); Plak dit in de \u0026ldquo;Execute SQL\u0026rdquo; tab van de SQLite DB Browser. Het resultaat is een foutboodschap:\nnear \u0026#34;;\u0026#34;: syntax error: INSERT INTO oeitiskapot; Maar: het eerste UPDATE statement, voor de foute regel, is wel uitgevoerd:\nOefeningen Probeer bovenstaande voorbeeld zelf uit in de SQLite DB Browser. Als je jezelf ervan verzekerd hebt dat inderdaad het eerste UPDATE statement wordt uitgevoerd, terwijl wij dat in één ACID blok willen, ga dan over naar de volgende oefening. In SQLite is het starten van een transactie erg eenvoudig: zie SQLite transaction tutorials van tutorialspoint.com. BEGIN; en COMMIT; zijn voldoende. Probeer dit uit in bovenstaande voorbeeld om er voor te zorgen dat de voornaam van Jaak niet wordt gewijzigd. Om met een \u0026ldquo;clean slate\u0026rdquo; te herbeginnen kan je gewoon de voorbereidende SQL code copy/pasten en opnieuw uitvoeren. Merk op dat dit nog steeds het ongewenst effect heeft dat de student zijn/haar naam wordt gewijzigd. We moeten expliciet zelf ROLLBACK; aanroepen. Probeer een nieuwe student toe te voegen: eentje met studentennummer, en eentje zonder. Dat tweede kan in principe niet door de NOT NULL constraint. Wrap beide statements in een transactie. Let Op: Het zou kunnen dat SQLite de volgende fout geeft: cannot start a transaction within a transaction: BEGIN;. Queries die geplakt worden in het \u0026ldquo;execute SQL\u0026rdquo; scherm worden meestal (onzichtbaar, achter de schermen) gewrapped in transacties. Stop de huidige transactie door COMMIT; uit te voeren met de knop \u0026ldquo;execute single SQL line\u0026rdquo;.\nLet Op: Het zou kunnen dat BEGIN TRANSACTION; de transactie niet goed encapsuleert, maar simpelweg BEGIN; wel. Het TRANSACTION keyword is optioneel volgens de SQLite docs en lijkt, afhankelijk van de geïnstalleerde SQLite versie, ander gedrag te vertonen.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/transacties/",
	"title": "3. RDBMS Transacties",
	"tags": [],
	"description": "",
	"content": "Transaction management Zie menu links.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/",
	"title": "Index",
	"tags": [],
	"description": "",
	"content": " Databases Laatste aanpassingen voor academiejaar 2023\u0026mdash;2024.\nPlanning nr datum onderwerp 01 vr 16-02-2024 RDBMS \u0026amp; SQL: Basics, DB Componenten 02 vr 23-02-2024 ER-schema 03 di 27-02-2024 ACID \u0026amp; SQL Deel 1 04 vr 08-03-2024 SQL deel 2 05 vr 15-03-2024 RDBMS transacties: basics, concurrency control 06 vr 22-03-2024 DB APIs: basics, JDBC, JDBI 07 di 26-03-2024 DB APIs: JPA \u0026amp; Hibernate 08 di 16-04-2024 Re Transacties: rollbacks, concurrency in practice 09 vr 26-04-2024 NoSQL 1: intro HC, key/value en document stores 10 vr 03-05-2024 NoSQL 2: advanced concepts, case studies 11 vr 17-05-2024 XML Data Storage, Big Data \u0026amp; Analytics 12 do 23-05-2024 Reserve Cursus noties Er worden telkens blokken van 3 uur ingepland voor dit vak. Er zijn geen traditionele hoorcolleges voorzien. Alle noties zijn via deze website te raadplegen (tenzij anders vermeld):\nInhoudsopgave SQL: Database Basics DB Componenten ER-schema Transacties I: ACID SQL: DDL SQL: DML SQL DB APIs: API Basics \u0026amp; layered tiers JDBC en JDBI JPA en Hibernate Extra oefeningen Transacties: Transacties II: Management Basics Concurrency control Failures/Rollbacks Transacties III: in de praktijk NoSQL: NoSQL Basics Key/Value stores Document stores Advanced map/reduce queries Replication XML \u0026amp; Big Data Storage XML Basics XSD Schemas XPath Queries Big Data Basics Big Data: Warehousing \u0026amp; BI Syllabus Lesgevers: Coördinerend Verantwoordelijke: prof. dr. Kris Aerts (kris.aerts@kuleuven.be) assistent lesgever: ing. Arne Duyver (arne.duyver@kuleuven.be) Kantoor: Technologiecentrum Diepenbeek, Groep ACRO. Cursusbeschrijving Dit opleidingsonderdeel focust enerzijds op drie soorten databases:\nrelationele databases de NoSQL-alternatieven XML databases En anderzijds op twee toepassingen:\nprogrammeren van database-gestuurde applicaties via API\u0026rsquo;s een inleiding in Big Data Vereiste voorkennis Basiskennis van een Object-Geörienteerde programmeertaal als Java of C# Basiskennis van het UNIX systeem, werken met commandline Doelstellingen Zie ook Studiegids UHasselt\nDe context en het overzicht worden aangereikt in de eerste lessen van dit vak.\nAls practicum wordt een grotere probleemstelling als project uitgewerkt. Alle aan te leren aspecten van databases komen in dit project aan bod. Studenten kunnen facultatief buiten het practicum extra thematische oefeningen oplossen.\nKalender Zie Mytimetable UHasselt.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]