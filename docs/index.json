[
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/hoorcolleges/",
	"title": "Hoorcolleges",
	"tags": [],
	"description": "",
	"content": "Slides Hoorcolleges 1. NoSQL Databases: Introductie 2. NoSQL Databases: Map/Reduce, Case Studies (1) 3. NoSQL Databases: Graph-based, Case Studies (2)  4. Transactie Management Video lectures van het Principles of Database Management boek zijn gratis beschikbaar op YouTube, via http://www.dataminingapps.com/dma_videos/introduction-to-database-management-systems/\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/nosql/keyvaluestores/",
	"title": "1. Key/value stores",
	"tags": [],
	"description": "",
	"content": "1.1 Persistente Hashmaps De eenvoudigst mogelijke noSQL database die gebruik maakt van key/values is een simpele HashMap\u0026lt;K,V\u0026gt; die je zelf serialiseert naar een flat file op de HDD. Een netwerk share kan dit bestand delen, maar locking systemen zullen moeten ingebouwd worden om te voorkomen dat dit bestand corrupt wordt.\nDe \u0026ldquo;oude\u0026rdquo; manier om dit te doen op de JVM is gebruik te maken van FileOutputStream:\nfun main(args: Array\u0026lt;String\u0026gt;) { val db = mapOf(\u0026#34;Joske\u0026#34; to Student(\u0026#34;Joske\u0026#34;, 11)) val file = File(\u0026#34;database.db\u0026#34;) // handy function to auto-close streams: https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html  ObjectOutputStream(FileOutputStream(file)).use { it.writeObject(db) } } public static void main(String[] args) throws IOException { var db = new HashMap\u0026lt;String, Object\u0026gt;(); db.put(\u0026#34;joske\u0026#34;, new Student(\u0026#34;Joske\u0026#34;, 11)); var file = new File(\u0026#34;database.db\u0026#34;); var f = new FileOutputStream(file); var s = new ObjectOutputStream(f); s.writeObject(db); s.close(); }  Inlezen werkt op dezelfde manier, met FileInputStream en ObjectInputStream. Hoe je Student klasse wordt geserialiseerd kan je zelf kiezen, maar een vereiste is dat je de interface Serializable implementeert!\nMet bovenstaande interface kan je de student terug uitlezen:\nvar fromFile: Map\u0026lt;String, Student\u0026gt; ObjectInputStream(FileInputStream(\u0026#34;database.db\u0026#34;)).use { fromFile = it.readObject() as Map\u0026lt;String, Student\u0026gt; } val joske = fromFile.getValue(\u0026#34;joske\u0026#34;) println(joske.name) var s = new ObjectInputStream(new FileInputStream(\u0026#34;database.db\u0026#34;)) Map\u0026lt;String, Object\u0026gt; map = (Map\u0026lt;String, Object\u0026gt;) s.readObject(); s.close(); Student joske = (Student) map.get(\u0026#34;joske\u0026#34;); System.out.println(joske.getName());  1.1.1 Oefeningen  Werk bovenstaand voorbeeld uit en persisteer een aantal studenten met de volgende klasse:  data class Student(val name: String, val age: Int) public class Student { private final String name; private final int age; public Student(String name, int age) { this.name = name; this.age = age; } }  1.2 Distributed Hashmaps: Memcached Met de Java voorbeeldcode op pagina 307 kunnen we een verbinding maken met een (of meerdere) Memcached servers. De Memcached client van net.spy.spymemcached (zie mvn repo: https://mvnrepository.com/artifact/net.spy/spymemcached).\nDe client code vereist een werkende memcached server - https://www.memcached.org. Je kan dit zelf compileren onder UNIX of Msys in Windows. We gaan voor de oefeningen hier niet verder op in.\nDenkvragen  Welke beperkingen zijn er verbonden aan het geserialiseerd database bestand doorgeven aan andere medestudenten? Op welke manier kan je zo verschillende \u0026lsquo;clients\u0026rsquo; verbinden aan één database \u0026lsquo;server\u0026rsquo;?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/nosql/",
	"title": "1. NoSQL",
	"tags": [],
	"description": "",
	"content": "NoSQL Databases HF11, p300 Zie menu links.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/nosql/documentstores/",
	"title": "2. Document stores",
	"tags": [],
	"description": "",
	"content": "2.1 Eenvoudige CouchDB Queries Lui in die zetel liggen, en vanaf de bank met gemak query\u0026rsquo;s lanceren? Geen probleem met CouchDB, een open source NoSQL JSON-based document store.\nMango CouchDB heeft een eenvoudige ingebouwde query syntax genaamd Mango. Documentatie op https://github.com/cloudant/mango en http://127.0.0.1:5984/_utils/docs/intro/api.html#documents. Selecteer een database, klik op \u0026ldquo;run a query with Mango\u0026rdquo;:\n{ \u0026#34;selector\u0026#34;: { \u0026#34;year\u0026#34;: 3 } } De selector attribute bepaalt op welke keys er wordt gefilterd. Indexen leggen op zwaar belaste \u0026ldquo;kolommen\u0026rdquo; (keys dus) is in geval van miljarden records zeker geen overbodige luxe.\nMango werkt met een selector syntax (zie documentatie) die impliciet bovenstaande omzet naar {\u0026quot;year\u0026quot;: {\u0026quot;$eq\u0026quot;: 3}}. Er zijn ook andere dollar-based operatoren. Geneste attributes kan je raadplegen met de . separator: {\u0026quot;student.name\u0026quot;: {\u0026quot;eq\u0026quot;: \u0026quot;Joske\u0026quot;}}.\nDe CouchDB API interface: alles via HTTP(S) curl is een snelle cmd-line tool waarbij je via -X kan meegeven of het over een HTTPs GET, POST, PUT, \u0026hellip; gaat. De DB locatie en poort met het juiste endpoint zijn hier de belangrijkste factoren. Een bepaald document raadplegen doe je met:\ncurl -X GET http://127.0.0.1:5984/[database]/[id] Het resultaat is altijd een geldig JSON object (ook al geef je een ongeldige ID mee): curl -X GET \u0026quot;http://127.0.0.1:5984/courses/aalto-university;bachelor-data-science;professional-development;1\u0026quot;\n{\u0026quot;_id\u0026quot;:\u0026quot;aalto-university;bachelor-data-science;professional-development;1\u0026quot;,\u0026quot;_rev\u0026quot;:\u0026quot;1-f7872c4254bfc2e0e5507502e2fafd6f\u0026quot;,\u0026quot;title\u0026quot;:\u0026quot;Professional Development\u0026quot;,\u0026quot;url\u0026quot;:\u0026quot;https://oodi.aalto.fi/a/opintjakstied.jsp?OpinKohd=1125443391\u0026amp;haettuOpas=-1\u0026quot;,\u0026quot;university\u0026quot;:\u0026quot;Aalto University\u0026quot;,\u0026quot;country\u0026quot;:\u0026quot;Finland\u0026quot;,\u0026quot;category\u0026quot;:\u0026quot;professional\u0026quot;,\u0026quot;ECTS\u0026quot;:5,\u0026quot;year\u0026quot;:1,\u0026quot;optional\u0026quot;:true,\u0026quot;skills\u0026quot;:[\u0026quot;motivate self\u0026quot;,\u0026quot;oral communication\u0026quot;,\u0026quot;self-directed learning\u0026quot;,\u0026quot;self-reflection\u0026quot;,\u0026quot;give/receive feedback\u0026quot;,\u0026quot;set/keep timelines\u0026quot;,\u0026quot;show initiative\u0026quot;],\u0026quot;course\u0026quot;:\u0026quot;Bachelor Data Science\u0026quot;,\u0026quot;lo\u0026quot;:\u0026quot;\u0026lt;br/\u0026gt;Learning Outcomes \u0026lt;br/\u0026gt;Being able to effectively communicate one's strenghts and professional capacities\u0026lt;br/\u0026gt;Finding one’s own academic and professional interests and taking initiative in one’s own learning\u0026lt;br/\u0026gt;Planning and prototyping one's own professional development\u0026lt;br/\u0026gt; \u0026lt;br/\u0026gt;Content \u0026lt;br/\u0026gt;The course is integrated to the Aaltonaut program to promote reflection, skill articulation and initiative. The course comprises workshops on different themes related to developing professional skills, independently building a learning portfolio, and taking part in feedback, reflection and goal setting activities.\u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt; \u0026quot;} Indien ongeldig: {\u0026quot;error\u0026quot;:\u0026quot;not_found\u0026quot;,\u0026quot;reason\u0026quot;:\u0026quot;missing\u0026quot;}.\nIndien geen toegang: {\u0026quot;error\u0026quot;:\u0026quot;unauthorized\u0026quot;,\u0026quot;reason\u0026quot;:\u0026quot;You are not authorized to access this db.\u0026quot;}. Zie \u0026ldquo;LET OP\u0026rdquo; hieronder\u0026mdash;gebruik het -u argument.\n2.2 Oefeningen: Voorbereidingswerk  Download CouchDB via https://couchdb.apache.org. Download de testdatabase JSON file Maak een nieuwe databases aan via de Fauxton Web-based admin tool. Open CouchDB, ga naar \u0026ldquo;Open Admin Console\u0026rdquo; of surf zelf naar http://127.0.0.1:5984/_utils/. Maak een database aan genaamd \u0026lsquo;courses\u0026rsquo;. Importeer de test JSON met curl in cmdnline:  curl -d @dump.db -H \u0026quot;Content-Type: application/json\u0026quot; -X POST http://127.0.0.1:5984/courses/_bulk_docs De ongelukkigen op Windows kunnen curl for Windows downloaden, of Msys/MinGW/de besturingssystemen ISO gebruiken.\nLET OP:\n Bij het aanmaken van een database kan je kiezen tussen partitioned en non-partitioned. Kies hiervoor non-partitioned. Het kan zijn dar CURL een security fout geeft. Bij het installeren van CouchDB moet je een admin username/password meegeven. Voeg aan het einde van je curl commando dit toe: -u username:wachtwoord.  Nadien kan je in Fauxton op F5 drukken en zou je dit moeten zien:\nIk heb voor jullie de dump genomen door het omgekeerde (exporteren) te doen:\ncurl -X GET http://127.0.0.1:5984/courses/_all_docs\\?include_docs\\=true \u0026gt; dump.db Daarna volgt wat post-processing (rows wordt docs, elke doc moet in de root array zitten en _rev moet weg) om tot bovenstaande dump.db filte te komen. Dit hebben wij handmatig voor jullie gedaan, zodat de downloadbare file klaar is om te importeren.\n2.3 Oefeningen met Fauxton/Curl  Schrijf een Mango query die cursussen ophaalt waarbij het aantal ECTS punten groter is dan 5. Hoe voer je de query uit oefening 1 uit, zonder de Admin console, maar met curl? Selecteer alle documenten die als skill de waarde self-reflection én show initiative bevatten. Probeer zelf een dump te nemen van je eigen database zoals hierboven beschreven, met het _all_docs endpoint. Wat gebeurt er als je die dump opnieuw wilt importeren via het _bulk_docs endpoint? Maak een nieuwe database genaamd studenten. POST via curl enkele nieuwe documenten, met als template { name: $naam, age: $age, favouriteCourses: [$course1, $course2]} naar deze DB. Controleer in Fauxton of de records correct zijn ingegeven. Verzin zelf wat Mango queries om studenten te filteren. Maak een index aan op age voor je studenten database. Merk op dat indexes, zichtbaar in http://127.0.0.1:5984/_utils/#database/studenten/_index ook worden beschouwd als documenten op zich!  Tip: CouchDB heeft een eenvoudige ingebouwde query syntax genaamd Mango. Documentatie op https://github.com/cloudant/mango en https://docs.couchdb.org/en/stable/api/database/find.html. Lees eerst na hoe dit in elkaar zit!\nEen uitgewerkt voorbeeld van oefening 1 en 2 in begeleidende video:\n 2.4 Java Client API Als je geen toegang hebt tot de admin console, of je wenst vanuit een Java programma records weg te schrijven naar een Couch database (of query\u0026rsquo;s uit te voeren), dan heb je de Java API nodig.\nIn principe kan je met eender welke HTTP client REST calls uitvoeren en de responses zelf verwerken. Om het jezelf gemakkelijker te maken, gebruiken we hier ter illustratie LightCouch.\nLees de LightCouch Getting Started guide. Maak een nieuw gradle 6 project met de volgende dependencies:\ndependencies { implementation group: 'org.lightcouch', name: 'lightcouch', version: '0.2.0' } In je java/main/resources map dien je een couchdb.properties file aan te maken die verwijst naar de DB URL/poort/naam (zie getting started):\ncouchdb.name=testdb couchdb.createdb.if-not-exist=true couchdb.protocol=http couchdb.host=127.0.0.1 couchdb.port=5984 couchdb.username= couchdb.password= Vanaf dan is het heel eenvoudig: Maak een CouchDbClient instantie aan. Nu kan je .save(), .shutdown() en .find() uitvoeren. Wat kan je bewaren? POJO (Plain Old Java Objects) klassen\u0026mdash;of in geval van Kotlin, data objects\u0026mdash;waarbij alle members automatisch worden geserialiseerd.\nLightCouch oefeningen  Maak zoals hierboven beschreven een nieuw gradle project aan (IntelliJ?) en voeg LightCouch toe als dependency. Probeer naar een nieuwe database enkele objecten weg te schrijven. Gebruik hiervoor een Student klasse met als velden name en age (respectievelijk String en int als type). Controleer of dit is aangekomen in de admin console. Dat ziet er dan hopelijk zo uit:  { \u0026#34;_id\u0026#34;: \u0026#34;387a34be062140e4be1390e846242114\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-742f438439fd68bc6c67ca0d615f1469\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Joske\u0026#34;, \u0026#34;age\u0026#34;: 10 } Probeer de views en query\u0026rsquo;s even uit. Zoek bijvoorbeeld alle studenten in List\u0026lt;Student\u0026gt; en druk de namen af door middel van println().  Denkvragen  Wat is het verschil tussen een key/value store en een document store? Kan je een verklaring geven waarom NoSQL databases zonder DB SCHEME werken, als je weet dat bijvoorbeeld CouchDB plain JSON objecten kan bewaren? Wat is het verschil tussen het bewaren van een JSON object via Curl en het bewaren van een POJO via LightCouc (De Client API verschillen zelf niet in rekening gebracht)?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/transacties/",
	"title": "2. Transacties",
	"tags": [],
	"description": "",
	"content": "Transaction management HF14, p430 Zie menu links.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/nosql/mapreduce/",
	"title": "3. Advanced map/red. queries",
	"tags": [],
	"description": "",
	"content": "Deze oefeningen volgen de theorie van 11.3.3 op pagina 320.\nDeze oefeningen gaan verder op de database die je hebt opgezet in 2. document stores. Herinstalleer indien nodig en download de benodigde gegevens via de instructies (2.2 Oefeningen: voorbereidingswerk) in die link. Start voor onderstaande oefeningen de lokale CouchDB Server en de Admin Console (Project Fauxton) opnieuw op.\nZoals ook op de PouchDB docs vermeld staat; zijn mapreduce queries niet altijd nodig:\n Documenten op _id raadplegen gaat door middel van de Curl REST API Documenten sorteren of simpele queries uitvoeren gaat door middel van de Mango API, zoals reeds gezien. Dit zijn simpele queries, maar die volstaan meestal. Indien de DB store \u0026lt; 100.000 records bevat, zoals de onze, kan je ook simpelweg alles in-memory inladen (bijvoorbeeld in de browser), en met javascript zelf verder filteren:  const db = pouchdb.get(); // zoiets // ... const skillsOfBigCourses = db.filter(doc =\u0026gt; { return doc.ECTS \u0026gt; 6 }).map(doc =\u0026gt; { return skills }) // gebruik dit in een template HTML factory Emit Een mapreduce query is in PouchDB uitvoerbaar met db.query() en in CouchDB deel van de _view API. Klik dus op het plusje + bij All Documents en dan op \u0026ldquo;new view\u0026rdquo;:\nDaar kan je een nieuwe \u0026ldquo;map\u0026rdquo; functie aanmaken:\nfunction (doc) { emit(doc._id, 1); } Merk op dat hier de JavaScript syntax geldt. emit() betekent \u0026ldquo;geef als key deze waarde terug voor elk gevonden document\u0026rdquo;. Als je dit verandert naar doc.title wordt er een view aangemaakt die documenten op titel bewaart, om daar zeer snel in te kunnen zoeken. Bovenstaande functie wordt uitgevoerd voor elk document, vandaar de \u0026ldquo;map\u0026rdquo; in de naam. Het zou kunnen dat je filtert, vandaar de \u0026ldquo;reduce\u0026rdquo; in de naam.\nIk kan dus gewoon if() gebruiken, en zo documenten filteren. Alle cursussen gegeven in het tweede jaar of later:\nfunction (doc) { if(doc.year \u0026gt; 1) { emit(doc.title, 1); } } Aggregeren Stel dat ik de totale ECTS punten wil verzamelen van alle Belgische vakken in de database. Dus: eerst filteren op country property, en daarna de som nemen van alle ECTS properties. Hoe doe je zoiets in SQL? Met SUM() en GROUP BY:\nSELECT SUM(ECTS) FROM courses WHERE country = \u0026#34;Belgium\u0026#34; GROUP BY country Hoe doe je zoiets in NoSQL/Mongo/CouchDB? Met Reduce Functions. Je kan in Fauxton bij het bewerken van je view een CUSTOM waarde in de Reduce combobox selecteren:\nWat is die derde rereduce parameter? Volgens de docs:\n Reduce functions take two required arguments of keys and values lists - the result of the related map function - and an optional third value which indicates if rereduce mode is active or not. Rereduce is used for additional reduce values list, so when it is true there is no information about related keys (first argument is null).\n Rereducen wordt typisch uitgevoerd bij een cluster met verschillende CouchDB Nodes die de data verdeelt. CouchDB ontvangt groepen van inputs in plaats van alles in één vanwege performantie optimalisatie. Dit systeem is visueel uitgelegd in deze primer, maar is voor ons niet van toepassing.\nDus, map functie om te filteren op België:\nfunction (doc) { if(doc.country == \u0026#34;Belgium\u0026#34;) { emit(doc._id, doc.ECTS); } } Door ECTS in emit() mee te geven (als VALUE!) kunnen we in de reduce functie de array values manipuleren. En de reduce functie om de ECTS punten op te tellen:\nfunction (keys, values, rereduce) { return sum(values); } sum() is een ingebouwde CouchDB functie. Dit kan ook manueel op de functionele JS reduce() manier:\nfunction (keys, values, rereduce) { return values.reduce((a, b) =\u0026gt; a + b); } Klik op \u0026ldquo;Run Query\u0026rdquo;. De resultaten zijn de resultaten van de MAP - de Reduce value moet je expliciet enablen door vanboven rechts op \u0026ldquo;Options\u0026rdquo; te klikken, en dan \u0026ldquo;Reduce\u0026rdquo; aan te vinken:\nMerk op dat je met \u0026ldquo;Group Level\u0026rdquo; moet spelen (Op None zetten) om de groepering te doen werken, anders gaat de reduce functie de som nemen op elk indiviudeel document, wat uiteraard geen correct som is.\nMerk op dat reduce functies verschillende keren kunnen worden opgeroepen - en dat reduce reeds kan beginnen voordat map klaar is met zijn werk. Deze maatregelen zijn genomen om vlot om te kunnen gaan met miljarden records, verticaal verspreid over verschillende clusters.\nOefeningen  Maak een nieuwe view die documenten teruggeeft die in de titel het woord \u0026ldquo;project\u0026rdquo; bevatten. Werk case-insensistive. Vergeet niet dat het zou kunnen dat sommige documenten géén title property hebben, of deze null is. Wat dan? Schrijf een reduce query die voor alle bovenstaande titels het aantal cursussen weergeeft (enkel het aantal is voldoende) dat explicit op true heeft staan. Schrijf een view die de som neemt van alle ECTS punten van alle cursussen. Doe dit op drie manieren:  Met de ingebouwde _sum functie. Met een custom reduce en sum() zoals hierboven in het voorbeeld Met een custom reduce die values.reduce() gebruikt: zie docs Array.prototype.reduce(). Wat is volgens jou het fundamentele verschil tussen deze 3 opties? Op welk gebied?   Kopieer je LightCouch oefening van 2. Document stores als een nieuw Java project. Programmeer nu in Java om de view die je hebt gemaakt in oefening 2 op te roepen met dbClient.view(). Zie LightCouch docs. Schrijf een view die het aantal optionele cursussen weergeeft waarvan \u0026ldquo;motivate others\u0026rdquo; een skill is.  Denkvragen  Waarom is het niet mogelijk in NoSQL databases om een simpele query uit te voeren die bijvoorbeeld auteurs opvraagt ouder dan een bepaalde leeftijd, en dan alle titels per auteur teruggeeft? (Hint: p. 321) Wat is het verschil tussen emit(doc._id, 1) en emit(doc._id, doc.year)? Wat is het verschil tussen map(), reduce() en filter() in Javascript? Hint: Zie Mozilla MDN Web Docs.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/apis/",
	"title": "3. Database APIs",
	"tags": [],
	"description": "",
	"content": "Database APIs HF15, p458 Zie menu links.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/nosql/replication/",
	"title": "4. Replication",
	"tags": [],
	"description": "",
	"content": "Met replication is het eenvoudig om clusters van clones te maken om de 99.9% uptime te kunnen garanderen, gegeven de juiste loadbalancing instellingen. Als voorbeeld gaan we een open-source JavaScript DB gebruiken genaamd PouchDB. PouchDB draait goed client-side in de browser, en interfacet heel gemakkelijk met zijn inspirator, CouchDB. Met Pouch is het een kwestie van een paar regeltjes code om replication aan te zetten tussen Pouch en de \u0026ldquo;master\u0026rdquo; Couch database, zoals ook zichtbaar op de Pouch website:\nvar db = new PouchDB(\u0026#39;dbname\u0026#39;); db.put({ _id: \u0026#39;dave@gmail.com\u0026#39;, name: \u0026#39;David\u0026#39;, age: 69 }); db.changes().on(\u0026#39;change\u0026#39;, function() { console.log(\u0026#39;Ch-Ch-Changes\u0026#39;); }); db.replicate.to(\u0026#39;http://example.com/mydb\u0026#39;); Wat is het doel? Replication op te zetten tussen de cursussen database van 2. document stores en de PouchDB JS web-based client. Dat kan op verschillende manieren:\n Unidirectional replication. Zie PouchDB Docs Bidirectional replication. Live/Continuous replication.  Je kan bovenstaande demo code onmiddellijk proberen op https://pouchdb.com: Druk op F12 of CTRL+SHIFT+J (Mac: OPT+CMD+J) of ga naar menu Developer -\u0026gt; Developer Tools van je favoriete browser. In de tab \u0026ldquo;Console\u0026rdquo; wordt je begroet door de PouchDB welkomsttekst. Daar kan je je test commando\u0026rsquo;s in uitvoeren: var db = .... Om te controleren of het record het tot in de database heeft gehaald, zie hieronder, bij tips.\nGebruik in de oefeningen de CDN versie om het jezelf gemakkelijk te maken. Maak een leeg .html bestand aan en kopieer de Quick Start code over:\n\u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/pouchdb@7.2.1/dist/pouchdb.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var db = new PouchDB(\u0026#39;my_database\u0026#39;); \u0026lt;/script\u0026gt; Vergeet niet dat je lokale CouchDB waarschijnlijk draait op poort 5984.\nEen uitgewerkt voorbeeld in begeleidende video:\n Oefeningen  Start CouchDB opnieuw met de bestaande courses db. Stel PouchDB in op unidirectionele replication. Alle LOKALE wijzigingen worden nu bewaard in de remote DB. Schrijf in Javascript ter test een nieuw fictief document weg met db.put(). Vul alle JSON properties in: kijk naar een bestaand document in je Couch database. Maak een nieuw .html bestand aan, en stel een remote URL in om vanuit JS onmiddellijk op de remote DB te kunnen queryen.  Gebruik de Mango query API van Pouch om in CouchDB de oefeningen van 2. document stores te implementeren. Opgelet: hier moet je een extra JS file voor includen, pouchdb.find.js, zoals aangegeven in de link, downloadbaar hier en zorg ervoor dat zowel PouchDB als de find versies van dezelfde release komen! Gebruik de Mapreduce query API van Pouch om in CouchDB de oefeningen van 3. advanced map/red. queries te implementeren. Merk op dat voor map en reduce beiden uit te voeren, je een JSON object moet meegeven met beide functies: { map: function(doc) { emit(...); }, reduce: '_count}. Zie docs in link.   Maak een nieuw .html bestand aan, en stel continuous replication in. Voeg dan een nieuw document toe in de CouchDB Admin console. Maak in HTML een knop die gewoon records afdrukt via console.log(). Wordt het nieuwe document getoond? Gebruik deze boilerplate:  \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/pouchdb@7.2.1/dist/pouchdb.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;Print docs\u0026lt;/button\u0026gt; \u0026lt;pre id=\u0026#34;pre\u0026#34;\u0026gt; ... \u0026lt;/pre\u0026gt; \u0026lt;script\u0026gt; function print(doc) { document.querySelector(\u0026#39;#pre\u0026#39;).innerHTML = JSON.stringify(doc); } var db = new PouchDB(\u0026#39;my_database\u0026#39;); // do your setup here  function queryDocs() { // do your thing here  print(\u0026#39;goed bezig\u0026#39;); } document.querySelector(\u0026#34;#btn\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, queryDocs); \u0026lt;/script\u0026gt; Tips: Wanneer je een item hebt toegevoegd aan je lokale JavaScript database met .put(), maar replication nog niet aan staat, kan het handig zijn om met Chrome/Opera/\u0026hellip; Dev Tools te kijken naar de local storage databases. Deze zijn terug te vinden in de tab \u0026ldquo;Application\u0026rdquo;, bij \u0026ldquo;IndexedDB\u0026rdquo;:\nDe volgende elementen zijn te herkennen in bovenstaande screenshot:\n Ik heb een \u0026ldquo;mydb\u0026rdquo; object aangemaakt (DB naam _pouch_mydb) Onder element \u0026ldquo;by-sequence\u0026rdquo; kan je de huidige elementen in de DB raadplegen, zoals bovenstaande demo code waarbij object met naam \u0026ldquo;David\u0026rdquo; werd toegevoegd.  Troubleshooting Cross site origin fouten? - Het kan zijn dat je browser, zoals een strict ingestelde Firefox, klaagt over Cross-Origin domains wanneer replication aan staat, omdat die naar 127.0.0.1 gaat, en je browser de .html file aanlevert vanuit file:/// wat technisch gezien niet dezelfde hostname is. Ga naar je CouchDB admin config (klik op tandwieltje), op CORS, en klik \u0026ldquo;enable\u0026rdquo; (all domains). Oplossing 1: gebruik een andere browser. Oplossing 2: disable CORS in de browser (zie artiel). Optie 3: gebruik een python3 webserver om je bestand te serven. Open een terminal en typ python -m http.server in de directory van je html bestand. Ga dan naar http://127.0.0.1:8000/oefening.html (Poort 8000). Indien niet opgelost, ga naar volgende troubleshooting puntje:\nConnecton errors? - Als Pouch bij replication connection errors geeft in de JS Console kan het zijn dat je Couch server te streng staat ingesteld, en hij de requests blokkeert. In dat geval ga je naar Fauxton, klik je op het \u0026ldquo;tandwieltje\u0026rdquo; linkqs, en enable je CORS (Cross Origin Requests):\nAccess denied? - Als je een admin username/password hebt ingesteld dien je dit ook mee te geven met de parameters: new PouchDb(\u0026quot;http://localhost:5984\u0026quot;, { auth: { username: \u0026quot;jef\u0026quot;, password: \u0026quot;lowie\u0026quot;} }). Zie options for remote databases in de PouchDb API manual.\nMijn find() doet niks? - Merk op dat eender welke actie een Promise object teruggeeft. Dat wil zeggen dat de query \u0026ldquo;onderweg\u0026rdquo; is, en als je iets wilt uitvoeren wanneer dit klaar is (een asynchroon proces), moet dit via de Promise API, zoals .then(). Lees hierover in de Mozilla MDN docs.\nIk krijg rare javascript errors? - Is je pouch.min.js en pouch.find.min.js versie dezelfde? D.w.z. zijn de major/minor/revision nummers hetzelfde? Dit staat aangeduid in de eerste regel van de source file. Indien niet, download de correcte versie via de PouchDB Github Releases pagina.\nIk krijg 404 object not found bij put? - Heb je je remote DB opgezet naar een onbestaande database, zoals /hallokes? Die moet je eerst zelf aanmaken in de CouchDB admin pagina! Anders kan je geen PUT commando\u0026rsquo;s op die URL opsturen.\nUncaught in Promise request PUT not supported? - In serviceWorker.js? Ben je op de pouchdb.com website in de console dingen aan het testen? Sommige scripts, zoals deze, vangen PUT commando\u0026rsquo;s op en crashen dan. Je object zal wel correct zijn bewaard, dit mag je negeren.\nDenkvragen  Heb je een verschil gemerkt tussen bidirectionele en live replication in PouchDB? Probeer beide instellingen uit en kijk in de Chrome/Opera/Mozilla Dev Tools van je browser naar de uitgaande HTTP requests. Op welk moment gebeurt dit? Welke POST/GET metadata wordt verstuurd? Wat is het verschil tussen in Pouch alle documenten op te vragen en daarna als array MapReduces toe te passen, of dit in de Mango query rechtstreeks te doen?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/transacties/failures-rollbacks/",
	"title": "1. Failures/Rollbacks",
	"tags": [],
	"description": "",
	"content": "blabla\nVoorbereidende CREATE statements (Dit is SQLite syntax!) Zie SQLite manual:\nDROP TABLE IF EXISTS student; CREATE TABLE student( studnr INT NOT NULL PRIMARY KEY, naam VARCHAR(200) NOT NULL, voornaam VARCHAR(200), goedbezig BOOL ); DROP TABLE IF EXISTS log; CREATE TABLE log( id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, date DATETIME DEFAULT CURRENT_TIMESTAMP, foreign_id INT NOT NULL, msg TEXT ); INSERT INTO student(studnr, naam, voornaam, goedbezig) VALUES (123, \u0026#39;Trekhaak\u0026#39;, \u0026#39;Jaak\u0026#39;, 0); INSERT INTO student(studnr, naam, voornaam, goedbezig) VALUES (456, \u0026#39;Peeters\u0026#39;, \u0026#39;Jos\u0026#39;, 0); INSERT INTO student(studnr, naam, voornaam, goedbezig) VALUES (890, \u0026#39;Dongmans\u0026#39;, \u0026#39;Ding\u0026#39;, 1); 1. System failure simulatie 1.1 In SQLite met DB Browser Gegeven een aantal SQL statements, waarvan niet alle statements kloppen, maar die wel allemaal bij elkaar horen als één atomaire transactie. Dat betekent dat als er één van die statements misloopt, de rest teruggedraait zou moeten worden. Het spreekt voor zich dat zonder speciale handelingen, zoals het beheren van transacties, dit niet gebeurt. Een eenvoudig voorbeeld demonstreert dit.\nUPDATE student SET voornaam = \u0026#39;Jaqueline\u0026#39; WHERE studnr = 123; INSERT INTO oeitiskapot; INSERT INTO log(foreign_id, msg) VALUES (123, \u0026#39;Voornaam vergissing\u0026#39;); INSERT INTO student(studnr, naam, voornaam, goedbezig) VALUES (445, \u0026#39;Klakmans\u0026#39;, \u0026#39;Jef\u0026#39;, 1); INSERT INTO log(foreign_id, msg) VALUES (445, \u0026#39;Nieuwe student registratie\u0026#39;); Plak dit in de \u0026ldquo;Execute SQL\u0026rdquo; tab van de SQLite DB Browser. Het resultaat is een foutboodschap:\nnear \u0026quot;;\u0026quot;: syntax error: INSERT INTO oeitiskapot; Maar: het eerste UPDATE statement, voor de foute regel, is wel uitgevoerd:\nOefeningen  Probeer bovenstaande voorbeeld zelf uit in de SQLite DB Browser. Als je jezelf ervan verzekerd hebt dat inderdaad het eerste UPDATE statement wordt uitgevoerd, terwijl wij dat in één ACID blok willen, ga dan over naar de volgende oefening. In SQLite is het starten van een transactie erg eenvoudig: zie SQLite transaction tutorials van tutorialspoint.com. BEGIN; en COMMIT; zijn voldoende. Probeer dit uit in bovenstaande voorbeeld om er voor te zorgen dat de voornaam van Jaak niet wordt gewijzigd. Om met een \u0026ldquo;clean slate\u0026rdquo; te herbeginnen kan je gewoon de voorbereidende SQL code copy/pasten en opnieuw uitvoeren. Merk op dat dit nog steeds het ongewenst effect heeft dat de student zijn/haar naam wordt gewijzigd. We moeten expliciet zelf ROLLBACK; aanroepen. Probeer een nieuwe student toe te voegen: eentje met studentennummer, en eentje zonder. Dat tweede kan in principe niet door de NOT NULL constraint. Wrap beide statements in een transactie.  Let Op: Het zou kunnen dat SQLite de volgende fout geeft: cannot start a transaction within a transaction: BEGIN;. Queries die geplakt worden in het \u0026ldquo;execute SQL\u0026rdquo; scherm worden meestal (onzichtbaar, achter de schermen) gewrapped in transacties. Stop de huidige transactie door COMMIT; uit te voeren met de knop \u0026ldquo;execute single SQL line\u0026rdquo;.\n1.2 In SQLite met Java/JDBC Bovenstaande failure fenomeen stellen we ook vast als we niet rechtstreeks in de DB explorer onze queries uitvoeren, maar via Java, met behulp van de sqlite-jdbc drivers. JDBC, of \u0026ldquo;Java DataBase Connection\u0026rdquo;, is een tussenlaag die het mogelijk maakt om SQL uit te voeren op eender welke SQL server. sqlite-jdbc zorgt voor de SQLite-specifieke vertaling. De interface die wij gebruiken om te programmeren zit in de JDK zelf onder de packages java.sql.\nEnkele belangrijke statements:\n Een connectie naar een database vastleggen: var connection = DriverManager.getConnection(\u0026quot;jdbc:sqlite:mydb.db\u0026quot;); Een SELECT query uitvoeren: var s = connection.createStatement(); var result = s.executeQuery(\u0026quot;...\u0026quot;); var cell = result.getString(\u0026quot;column\u0026quot;); Een INSERT/UPDATE/\u0026hellip; query uitvoeren (die de structuur of inhoud van de database wijzigt): var s = connection.createStatement(); s.executeUpdate(\u0026quot;...\u0026quot;);  Het volgende voorbeeld opent een verbinding naar een DB, maakt een tabel aan, voegt een record toe, en telt het aantal records:\nprivate lateinit connection: Connection fun createDb() { connection = DriverManager.getConnection(\u0026#34;jdbc:sqlite:mydb.db\u0026#34;).apply { setAutoCommit(false) } // note that this requires \u0026#34;stdlib-jdk7\u0026#34; as kotlin runtime dependency  connection.createStatement().use { it.executeUpdate(\u0026#34;CREATE TALBE mijntabel(nr INT); INSERT INTO mijntabel(nr) VALUES(1);\u0026#34;) } } fun verifyDbContents() { connection.createStatement().use { val result = it.executeQuery(\u0026#34;SELECT COUNT(*) FROM mijntabel;\u0026#34;) assert result.getInt(0) == 1 } } private Connection connection; public void createDb() throws SQLException { connection = DriverManager.getConnection(\u0026#34;jdbc:sqlite:mydb.db\u0026#34;); connection.setAutoCommit(false); var s = connection.createStatement(); s.executeUpdate(\u0026#34;CREATE TALBE mijntabel(nr INT); INSERT INTO mijntabel(nr) VALUES(1);\u0026#34;) s.close(); } public void verifyDbContents() throws SQLException { var s = connection.createStatement(); var result = s.executeQuery(\u0026#34;SELECT COUNT(*) FROM mijntabel;\u0026#34;); var count = result.getInt(0); s.close(); assert count == 1; }  Gradle dependency: laatste versie van sqlite-jdbc in mvnrepository.com.\nProblemen met je JDK versie en Gradle versies? Raadpleeg de Gradle Compatibiility Matrix. Gradle 6.7 of hoger ondersteunt JDK15. Gradle 7.3 of hoger ondersteunt JDK17. Let op met syntax wijzigingen bij Gradle 7+! Je Gradle versie verhogen kan door de URL in gradle/gradlew.properties te wijzigen.\n Merk op dat SQLException een checked exception is die je constant moet meespelen in de method signature of expliciet moet opvangen. Het probleem van een try { } catch { } finally { } block is dat in de finally je ook geen close() kan uitvoeren zonder opnieuw een try block te openen\u0026hellip; Inception!\nVergelijk de Kotlin implementatie met de standaard Java versie. Als het aan komt op efficiënt gebruik van oudere Java APIs zoals de SQL methodes, is Kotlin véél eenvoudiger, zowel in gebruik als in leesbaarheid. Hier maken we handig gebruik van de use extension om geen close() te moeten oproepen, en with {} om de connectionManager in te stellen zonder telkens connection. te moeten herhalen. Nog een voordeel: er is geen verschil tussen checked en unchecked exceptions. Het loont dus om ook voor dit vak te opteren voor Kotlin\u0026mdash;maar het is niet verplicht.\n Het connection.close() statement moet er voor zorgen dat voor elke request de connection netjes wordt afgesloten. Een database heeft meestal een connection pool van x aantel beschikbare connections, bijvoorbeeld 5. Als een connection per request niet wordt gesloten, heeft de voglende bezoeker van onze website geen enkele kans om zijn zoekquery te lanceren, omdat de database dan zegt dat alle connecties zijn opgebruikt!\nDe setAutoCommit(false) regel is nodig omdat in JDBC standaard elke SQL statement aanschouwd wordt als een onafhankelijke transactie, die automatisch wordt gecommit:\n When a connection is created, it is in auto-commit mode. This means that each individual SQL statement is treated as a transaction and is automatically committed right after it is executed. (To be more precise, the default is for a SQL statement to be committed when it is completed, not when it is executed. A statement is completed when all of its result sets and update counts have been retrieved. In almost all cases, however, a statement is completed, and therefore committed, right after it is executed.)\n Zie JDBC Basics in Oracle docs: https://docs.oracle.com/javase/tutorial/jdbc/basics/transactions.html\nBegeleidende video:\n Oefeningen  Maak een nieuw Gradle project aan en connecteer naar je SQLite database. Merk op dat, bij connectionstring \u0026quot;jdbc:sqlite:sample.db\u0026quot;, automatisch een lege .db file wordt aangemaakt indien de database niet bestaat. Probeer met behulp van executeUpdate() en executeQuery() bovenstaande system failure te veroorzaken. Je kan de \u0026ldquo;foute SQL\u0026rdquo; (met \u0026ldquo;oeitiskapot\u0026rdquo;) gewoon in een string in java copy/pasten. executeUpdate() kan verschillende statements tegelijkertijd verwerken. Verifieer dat de naam foutief toch wordt gewijzigd met een SELECT() nadat je de fout hebt opgevangen in een try { } block. Het probleem is op te lossen met één welgeplaatste regel: connection.rollback(). De vraag is echter: waar plaatsen we die? En ja, rollback() throwt ook de checked SQLException\u0026hellip; Verifieer of je oplossing werkt door de naam na de rollback terug op te halen en te vergelijken met de juiste waarde: \u0026ldquo;Jaak\u0026rdquo;.  De DROP TABLE IF EXISTS statements kan je in je project in een aparte SQL file bewaren en als een String inlezen, om in één keer te laten uitvoeren na het openen van de connectie:\nfun initTables() { val sql = SomeClass::class.java.getResource(\u0026#34;dbcreate.sql\u0026#34;).readText() println(sql) connection.createStatement().use { it.executeUpdate(sql) } } private void initTables() throws Exception { var sql = new String(Files.readAllBytes(Paths.get(getClass().getResource(\u0026#34;dbcreate.sql\u0026#34;).getPath()))); System.out.println(sql); var s = connection.createStatement(); s.executeUpdate(sql); s.close(); }  De verwachte fout (met de ongeldige SQL regel) die SQLite doorgeeft aan Java genereert de volgende stacktrace:\norg.sqlite.SQLiteException: [SQLITE_ERROR] SQL error or missing database (near \u0026quot;;\u0026quot;: syntax error) at org.sqlite.core.DB.newSQLException(DB.java:1010) at org.sqlite.core.DB.newSQLException(DB.java:1022) at org.sqlite.core.DB.throwex(DB.java:987) at org.sqlite.core.NativeDB._exec_utf8(Native Method) at org.sqlite.core.NativeDB._exec(NativeDB.java:94) at org.sqlite.jdbc3.JDBC3Statement.executeUpdate(JDBC3Statement.java:109) at SQLiteTransactionTest.doStuff(SQLiteTransactionTest.java:54) at SQLiteMain.main(SQLiteMain.java:7) Denkvragen  De SQLite website beschrijft in detail hoe ze omgaan met \u0026ldquo;atomic commits\u0026rdquo; om aan de ACID regels te voldoen. Lees dit na op https://sqlite.org/atomiccommit.html Op welke manier gebruiken zij een rollback journal? Hoe is dat gelinkt aan de logfile van 14.2.3 op p.435? JDBC is vrij rudimentair, en het is vrij omslachtig om simpele statements te committen vanwege boilerplate code. Hoe zou je dit probleem verminderen door middel van enkele refactorings? Anders gezegd: welke patronen herken je (zie SES 2de bach.) en hoe kan je gebruik maken van die patronen om herhalende boilerplate code te verminderen?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/apis/jdbc-jdbi/",
	"title": "1. JDBC en JDBI",
	"tags": [],
	"description": "",
	"content": "1.1 Queries/Objecten in JDBC Zie Transacties failures/rollbacks voor de initiële setup van een eenvoudige Java JDBC applicatie.\nStel dat we dezelfde studenten willen inladen in een Student klasse instantie: van de TABLE STUDENT naar de class Student. In geval van JDBC is dat veel handwerk:\n Maak een verbinding met de database. Voer de SELECT statements uit. Loop door de ResultSet en maak een nieuwe Student instantie aan. Vang alle mogelijke fouten zelf op: wat met lege kolommen, null? Wat met INTEGER kolommen die je wilt mappen op een String property?  Om van de huidige resultatenrij naar de volgende te springen in ResultSet gebruikt men de methode next() in een typisch while() formaat:\nval result = statement.executeQuery(\u0026#34;SELECT * FROM iets\u0026#34;) while(result.next()) { val eenString = result.getString(\u0026#34;kolomnaam\u0026#34;) // doe iets! } var result = statement.executeQuery(\u0026#34;SELECT * FROM iets\u0026#34;); while(result.next()) { var eenString = result.getString(\u0026#34;kolomnaam\u0026#34;); // doe iets! }  Zie ook ResultSet Oracle Javadoc.\nAangezien we reeds hebben kennis gemaakt met de (beperkte) API, schakelen we onmiddellijk over naar de oefeningen:\n1.1.1 Oefeningen  Maak (én test!) een klasse StudentRepository die de volgende methode implementeert. Zoals je ziet is het de bedoeling dat de JDBC Connection instance elders wordt aangemaakt, bijvoorbeeld in een aparte ConnectionManager klasse.  class StudentRepository(val connection: Connection) { fun getStudentsByName(name: String): List\u0026lt;Student\u0026gt; } public class StudentRepository { public StudentRepository(Connection connection); public List\u0026lt;Student\u0026gt; getStudentsByName(String name); }  Breid dit uit met saveNewStudent(Student). Breid dit uit met updateStudent(Student). Wat moet je doen als deze student nog niet in de database zit? Welke gegevens update je wel en welke niet?  Tip:\n executeUpdate() van een Statement is erg omslachtig als je een string moet stamenstellen die een INSERT query voorstelt (haakjes, enkele quotes, \u0026hellip;). Wat meer is, als de input van een UI komt, kan dit gehacked worden, door zelf de quote te sluiten in de string. Dit noemt men SQL Injection, en om dat te vermijden gebruik je in JDBC de prepareStatement() methode. Zie JDBC Basics: Prepared Statements. De String die je meegeeft bevat in de plaats van parameters een vraagteken: INSERT INTO STUDENT(bla, bla) VALUES(?, ?). Die parameters vul je daarna aan met preparedStatement.setString() of setInt(). Op die manier is de code zowel netjes als injectie-vrij!  1.2 Queries/Objecten in Jdbi 3 Jdbi (Java DataBase Interface v3) is een lightweight library geschreven bovenop JDBC. Het gebruikt dus de interne Java API om te communiceren tussen de database en de Java applicatie. Echter, het maakt het leven voor ons als ontwikkelaar op heel wat vlakken véél aangenamer: waar JDBC eerder database-driven en dialect-afhankelijk is, is Jdbi eerder user-driven en met behulp van plugins dialect-onafhenkelijk.\nJDBI3 is opgedeeld in modules, waarvan wij de volgende drie gaan gebruiken:\n jdbi3-core (altijd nodig) - voor JDBC zit dit in de JDK. jdbi3-sqlite (voor de SQLite verbinding) - of andere DB driver jdb3-sqlobject - voor de eenvoudige mapping naar Plain Old Java Objects (POJOs)  Er is ook support voor spring, jpa, guava, kotlin, \u0026hellip;\nOm bovenstaande JDBC oefening te implementeren in Jdbi3 hebben we eerst een extractie van een interface nodig voor de repository acties:\ninterface StudentRepository { fun getStudentsByName(student String): List\u0026lt;Student\u0026gt; fun saveNewStudent(student: Student) fun updateStudent(student: Student) } public interface StudentRepository { List\u0026lt;Student\u0026gt; getStudentsByName(String student); void saveNewStudent(Student student); void updateStudent(Student student); }  Nu kan StudentRepositoryJdbcImpl (hernoem bovenstaande) en onze nieuwe StudentRepositoryJdbi3Impl de interface implements-en. Denk aan de Strategy design pattern van SES: afhankelijk van een instelling kunnen we switchen van SQL leverancier, zolang de code overal de interface gebruikt.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; Main[Controlller] Interface{StudentRepository} Jdbc[StudentRepositoryJdbcImpl] Jdbi[StudentRepositoryJdbi3Impl] Main -- Interface Interface -- Jdbc Interface -- Jdbi  1.2.1 JDBC vs Jdbi3 1. Connection openen In plaats van JDBC\u0026rsquo;s DriverManager.getConnection() om de Connection instance te bootstrappen, gebruiken wij gewoon Jdbi.create() met ook één paremter, namelijk dezelfde connectionstring.\n2. Query uitvoeren In plaats van de vervelende checked SQLExceptions en de createStatement() code, heb je nu de keuze om ofwel de Fluent API te gebruiken:\nreturn jdbi.withHandle(handle -\u0026gt; { return handle.createQuery(\u0026#34;SELECT * FROM student WHERE naam = :naam\u0026#34;) .bind(\u0026#34;naam\u0026#34;, student) .mapToBean(Student.class) .list(); }); ofwel de Declarative API, waarbij je met de @SqlQuery kan werken op een interface:\npublic interface StudentDao { @SqlQuery(\u0026#34;SELECT * FROM student\u0026#34;) @RegisterBeanMapper(Student.class) List\u0026lt;Student\u0026gt; getStudenten(); } Dit vereist dat je de plugin SqlObjectPlugin installeert na de Jdbi.create(): jdbi.installPlugin(new SqlObjectPlugin());. Zie jdbi.org documentatie.\nJdbi ondersteunt Kotlin met twee modules: jdbi3-kotlin en jdbi3-kotlin-sqlobject om data classes direct te binden aan een bepaalde tabel. Bovenstaande Java code (met .bind() werken) is analoog. Om verwarring te voorkomen zijn de Jdbi voorbeelden uitgewerkt in Java. Lees meer op http://jdbi.org/#_kotlin\n Herinner je je nog de SESsy Library? Die werkte ook op die manier! Kijk nog eens in https://github.com/kuleuven-diepenbeek/sessylibrary in de map src.main.java.be.kuleuven.sessylibrary.domain in klasse BooksRepository!\nMerk op dat Jdbi3 er voor kan zorgen dat de resultaten van je query automatisch worden vertaald naar een Student instantie door middel van bean mapping: de mapToBean() methode of de @RegisterBeanMapper annotatie. Die gaat via reflectie alle kolomnamen 1-op-1 mappen op properties van je object dat je wenst te mappen. Er zijn ook nog andere mogelijkheden, zoals mappen op een HashMap, ea:\n3. Transacties, insert/update queries, \u0026hellip; Zelfstudie. Zie jdbi.org documentatie.\n1.2.2 Oefeningen Begin vanaf start project jdbc-repo-start.zip! Deze bevat reeds bovenstaande JDBC implementatie en een aantal unit testen, waarvan er nog twee falen.\n Fix eerst de falende unit testen! Herimplementeer alle methodes van de StudentRepository interface hierboven, maar dan in Jdbi3 met de Fluent API (jdbi.withHandle()). Maak een tweede klasse genaamd StudentRepositoryJdbi3. Schrijf ook een bijhorende unit test klasse (kijk voor inspiratie naar de JDBC implementatie). Om te testen of het werkt in \u0026ldquo;productie\u0026rdquo; kan je je testcode van JDBC herbruiken door de code de interface te laten gebruiken in plaats van de implementatie. Bijvoorbeeld:  fun main(args: Array\u0026lt;String\u0026gt;) { val jdbcRepo = StudentRepositoryJdbc(...) val jdbiRepo = StudentRepositoryJdbi3(...) doStuff(jdbcRepo) } fun doStuff(repository: StudentRepository) { // argunent = interface!  // uw repository.getStudentsByName, saveNewStudent, ... tests hier } public class OefeningMain { public static void main(String[] args) { var jdbcRepo = new StudentRepositoryJdbc(...); var jdbiRepo = new StudentRepositoryJdbi3(...); doStuff(jdbcRepo); } public static void doStuff(StudentRepository repository) { // argunent = interface!  // uw repository.getStudentsByName, saveNewStudent, ... tests hier  } }  Extra Oefening: Maak een nieuwe implementatie van de repository interface die via de Jdbi3 Declaratie API de queries doorgeeft naar de SQLite DB. D.w.z., lees in de Jdbi3 developer guide na hoe je de Declarative API gebruikt en verwerk dit. Tip: jdbi.withExtension(StudentDao.class, ...).  Tip:\n Neem de tijd om de JDBI documentatie uitvoerig te bekijken!  1.3 Jdbi Backend + JavaFX Frontend Met Java database access enigszins onder de knie kijken we verder dan alleen maar de \u0026ldquo;repository\u0026rdquo;. Op welke manier kunnen we onze STUDENT tabel visueel weergeven, en er studenten aan toevoegen of uit verwijderen?\nDat kan op verschillende manieren, van HTML (SESsy Library) en JavaScript API calls naar iets eenvoudiger vanuit het eerstejaarsvak INF1: JavaFX. Je kan in JavaFX eenvoudig TableView stukken positioneren op een AnchorPane en die vullen met de juiste kolommen en rijen. De data blijft uiteraard uit de SQLite DB komen via JDBC/Jdbi. De StudentRepository is dus slechts één deel van het verhaal: waar wordt deze gebruikt? In JavaFX controllers.\n1.3.1 Een Gradle JavaFX Project Er zijn een aantal aanpassingen nodig aan je build.gradle file om van een gewone Java applicatie over te schakelen naar een JavaFX-enabled applicatie. We hebben de application en javafxplugin plugins nodig onder plugins {}, verder ook een javafx {} property groep die bepaalt welke modules van JavaFX worden ingeladen:\nplugins { id 'application' id 'org.openjfx.javafxplugin' version '0.0.10' } repositories { mavenCentral() } javafx { version = \u0026quot;15\u0026quot; modules = [ 'javafx.controls', 'javafx.fxml' ] } dependencies { implementation group: 'org.xerial', name: 'sqlite-jdbc', version: '3.36.0.3' implementation group: 'org.jdbi', name: 'jdbi3-core', version: '3.24.1' implementation group: 'org.jdbi', name: 'jdbi3-sqlite', version: '3.24.1' implementation group: 'org.jdbi', name: 'jdbi3-sqlobject', version: '3.24.1' testImplementation group: 'junit', name: 'junit', version: '4.12' } group 'be.kuleuven.javasql' version '1.0-SNAPSHOT' sourceCompatibility = 1.13 mainClassName = 'be.kuleuven.javasql.SqlFxMain' Herinner je het volgende over JavaFX:\n De main klasse leidt af van Application en laadt de hoofd-.fxml file in. Controllers hebben een public void initialize() methode waar action binding in wordt gedefinieerd. .fxml files beheer je met SceneBuilder. Vergeet hier niet de link naar de fully qualified name van je controller klasse te plaatsen als AnchorPane attribuut: fx:controller=\u0026quot;be.kuleuven.javasql.controller.StudentController\u0026quot;.  Problemen met je JDK versie en Gradle versies? Raadpleeg de Gradle Compatibiility Matrix. Gradle 6.7 of hoger ondersteunt JDK15. Gradle 7.3 of hoger ondersteunt JDK17. Let op met syntax wijzigingen bij Gradle 7+! Je Gradle versie verhogen kan door de URL in gradle/gradlew.properties te wijzigen. De laatste versie van JavaFX is 17\u0026mdash;backwards compatible met JDK15 en hoger.\n Voor onze studententabel visualisatie hebben we een TableView nodig. Daarnaast eventueel Buttons om te editeren/toe te voegen/\u0026hellip; Vergeet de fx:id van de tabel niet:\nKolommen (en de inhoud van de rijen) definiëren we in de controller zelf:\n@FXML private lateinit var tblStudent: TableView\u0026lt;Student\u0026gt; fun initialize() { tblStudent.getColumns().clear() val col: TableColumn\u0026lt;Student, String\u0026gt; = TableColumn\u0026lt;\u0026gt;(\u0026#34;Naam\u0026#34;).apply { setCellValueFactory(f -\u0026gt; ReadOnlyObjectWrapper\u0026lt;\u0026gt;(f.getValue().getMaam())) } with(tblStudent) { getColumns().add(col) getItems().add(Student(\u0026#34;Joske\u0026#34;, \u0026#34;Josmans\u0026#34;, 124, true)) } } @FXML private TableView\u0026lt;Student\u0026gt; tblStudent; public void initialize() { tblStudent.getColumns().clear(); TableColumn\u0026lt;Student, String\u0026gt; col = new TableColumn\u0026lt;\u0026gt;(\u0026#34;Naam\u0026#34;); col.setCellValueFactory(f -\u0026gt; new ReadOnlyObjectWrapper\u0026lt;\u0026gt;(f.getValue().getMaam())); tblStudent.getColumns().add(col); tblStudent.getItems().add(new Student(\u0026#34;Joske\u0026#34;, \u0026#34;Josmans\u0026#34;, 124, true)); }  Merk op dat TableView een generisch type heeft, en we zo dus heel eenvoudig onze eigen POJO rechtstreeks kunnen mappen op de Student klasse! Als we dit opstarten krijgen we alvast één kolom te zien met de naam (f in de CellValueFactory is een wrapper waarvan de waarde de huidige student in de rij is. getNaam() zorgt ervoor dat de juiste waarde in de juiste cel komt te staan)\n1.3.2 Oefeningen Begin vanaf start project jdbc-fxml-start.zip! Deze bevat reeds bovenstaande JDBC implementatie en een leeg gekoppeld JavaFx project. Om uit te voeren, klik op \u0026ldquo;Gradle\u0026rdquo; en voer target \u0026ldquo;run\u0026rdquo; uit (dus niet op \u0026ldquo;Play\u0026rdquo; in de main klasse!).\n Werk bovenstaande voorbeeld verder uit voor alle kolommen. Voeg eerst testdata toe (getItems().add(new student...). Probeer nu de controller te linken met de repository. De tabel items moeten overeenkomen met de repository items. Proficiat, je kijkt naar \u0026ldquo;live data\u0026rdquo;! Voeg een knop Voeg Toe toe op het scherm, dat een ander FXML venster opent, waar je gegevens van de nieuwe student kan ingeven, en kan bewaren. De \u0026ldquo;bewaren\u0026rdquo; knop persisteert naar de database, sluit het venster, én refresht het studentenadmin overzichtsscherm.  Tip: Vanuit een JavaFX controller een ander scherm openen is een kwestie van een nieuwe Stage en Scene object aan te maken:\nprivate fun showScherm() { val resourceName = \u0026#34;bla.fxml\u0026#34; val root = FXMLLoader.load(this::class.java..getResource(resourceName)) as AnchorPane; val stage = Stage().apply { setScene(Scene(root)) setTitle(\u0026#34;dinges\u0026#34;) initModality(Modality.WINDOW_MODAL) show() } } private void showScherm() { var resourceName = \u0026#34;bla.fxml\u0026#34;; try { var stage = new Stage(); var root = (AnchorPane) FXMLLoader.load(getClass().getClassLoader().getResource(resourceName)); stage.setScene(new Scene(root)); stage.setTitle(\u0026#34;dinges\u0026#34;); stage.initModality(Modality.WINDOW_MODAL); stage.show(); } catch (Exception e) { throw new RuntimeException(e); } }  Zit je vast? Raadpleeg de TableView JavaDocs: https://openjfx.io/javadoc/13/javafx.controls/javafx/scene/control/TableView.html\nBekijk een voorbeeld Kotlin/JavaFX project in de github appdev-course repository.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/hoorcolleges/slides-1/",
	"title": "1. NoSQL Databases: Introductie",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/transacties/concurrency/",
	"title": "2. Concurrency",
	"tags": [],
	"description": "",
	"content": "Meerdere threads met toegang tot de DB Download het concurrency startproject. Het bevat een JDBC implementatie van de gekende studenten opgave, inclusief een aantal random Runnable thread workers die INSERT, UPDATE en DELETE statements issuen naar de database. De volgorde is een deel van de chaos\u0026hellip;\nOefeningen  Inspecteer de huidige code van het project en vergewis je ervan dat je alle stappen begrijpt. Voer het een aantal keer uit. Wat zie je in de Stdout? Zijn de queries telkens dezelfde, in dezelfde volgorde? Transacties op elke query/statement toepassen is een eenvoudige oplossing maar lang niet de beste: de toegevoegde grote performantie hit kan bij miljoenen requests de applicatie volledig tot stilstand doen brengen. Welke repository calls zouden in een transactie moeten worden uitgevoerd, en bij welke calls is dat niet nodig? Speel met de parameter van setAutoCommit() in de ConnectionManager. Zie je een verschil? Speel met de parameter van setTransactionIsolation() op de connection. Welke vier mogelijke waardes worden ondersteund door SQLite? Wat is volgens de Oracle docs het verschil tussen bijvoorbeeld READ_UNCOMMITTED en READ_COMMITTED? Kan je uit de context opmaken wat een \u0026ldquo;dirty read\u0026rdquo; is? De sqlite-jdbc driver die we gebruiken heeft nog een aantal verborgen opties, waarvan setTransactionMode en setLockingMode het interessantste zijn om mee te prutsen. Kijk goed naar de Sysout output om het verschil te bepalen. Dat doe je door een SQLiteConfig object aan te maken en op de volgende manier mee te geven aan de DriverManager:  val config = SQLiteConfig().apply { setX(val1) setY(val2) } connection = DriverManager.getConnection(\u0026#34;jdbc:sqlite:...\u0026#34;, config.toProperties()) SQLiteConfig config = new SQLiteConfig(); config.setX(val1); config.setY(val2); connection = DriverManager.getConnection(\u0026#34;jdbc:sqlite:...\u0026#34;, config.toProperties());  Extra:\n Implementeer zelf de nodige Jdbi3 details in StudentRepositoryJdbi3Impl. In Jdbi stel je de transaction isolation level in met .inTransaction(TransactionIsolationLevel.SERIALIZABLE, ...) (zie docs).  Tip: SQLite config, transactie en locking modes zijn uitgelegd in de SQLite docs, pragma pagina.\nConnection Pooling Uit de code blijkt dat alle threads momenteel éénzelfde connection instance delen via de StudentRepository implementatie. In de praktijk wordt er voor client/server applicaties altijd connection pooling toegepast: een aantal connections zijn beschikbaar in een pool, waar de clients uit kunnen kiezen. Als er een beschikbaar is, kan deze verder gaan. Als dat niet zo is, moet die bepaalde request wachten, tot een andere klaar is met zijn database acties en de connection terug vrijgeeft, opnieuw in de pool. Op die manier kan je bijvoorbeeld 6 connections verdelen over 10+ client threads, zoals in deze figuur (bron: oracle docs):\nVoor embedded single-file databases als SQLite is dit niet de gewoonte. Hibernate (zie 3. Database APIs) voorziet verschillende properties om connection pooling in te stellen, zoals aantal connections, aantal threads die kunnen requesten, timeout request, enzovoort. We gaan hier verder niet op in.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/apis/jpa/",
	"title": "2. JPA en Hibernate",
	"tags": [],
	"description": "",
	"content": "2.1 Wat is JPA? JPA of de Java Persistence API is een deel van Java EE (Java Enterprise Platform), een set van specificaties die initiëel de JDK SE 8 versie uitbreidden met \u0026ldquo;enterprise\u0026rdquo; features zoals distributed computing en web services. J2EE wordt vooral ingezet als het gaat over grote applicaties die bedrijven ontwikkelen voor andere bedrijven (zogenaamde \u0026ldquo;B2B\u0026rdquo;, Business 2 Business, of Enterprise Software Development).\nOndertussen is J2EE omgevormd tot Jakarta EE. In principe staat JPA nu voor Jakarta Persistence API\u0026hellip; What\u0026rsquo;s in a name.\n2.1.1 Maar wat is de JPA API nu precies? De API, levend in de package javax.persistence, is een manier om relationele data voor te stellen in enterprise Java applicaties, door middel van Objecten. Het is dus een mapping tool die object/relationale (meta)data bewerkt en verwerkt. JPA heeft ook zijn eigen query language, JPQL, die het eenvoudiger moet maken om queries te schrijven in Java code zelf in plaats van in SQL, die vertaald worden naar SQL. Dit vereenvoudigt refactoring en vermindert mogelijke fouten in de SQL string die te laat naar boven komen (nu compiletime ipv runtime, aangezien Java statisch getypeerd is).\nJPA is niet meer dan een specificatie die de interfaces en annotaties voorziet. De implementatie, en de klasses, worden overgelaten aan vendors, waarvan voor JPA 2.2 de volgende vendors beschikbaar zijn:\n DataNucleus EclipseLink Hibernate OpenJPA  JPA 2.2 Gradle dependency: compile group: 'javax.persistence', name: 'javax.persistence-api', version: '2.2'\n2.2 Wat is Hibernate ORM? Volgens de hibernate.org website:\n Your relational data. Objectively.\n Hibernate is dé populairste object-relational mapper in Java die de JPA standaard implementeert. Hibernate heeft zowel een eigen API als een JPA specificatie, en kan dus overal waar JPA nodig is ingeschakeld worden. Het wordt vaak in omgevingen gebruikt waar performantie belangrijk is, en waar enorm veel data en gebruikers data transferreren.\nBelangrijk startpunt: Hibernate getting started guide Ook Hibernate werkt met modules, zoals Jdbi3. We gebruiken hibernate-core; via Gradle: compile group: 'org.hibernate', name: 'hibernate-core', version: '5.4.23.Final'\nHet gebruik van Hibernate geeft meestal een aantal mogelijkheden:\n Gebruik de Native Hibernate API en hbm.xml mapping (Zie \u0026ldquo;2. Tutorial Using Native Hibernate APIs and hbm.xml Mapping\u0026rdquo;) Gebruik de Native Hibernate API en annotaties (Zie \u0026ldquo;3. Tutorial Using Native Hibernate APIs and Annotation Mappings\u0026rdquo;) Gebruik de JPA interface (Zie \u0026ldquo;4. Tutorial Using the Java Persistence API (JPA)\u0026quot;)  Waarvan wij #3 gaan hanteren.\n2.2.1 Hibernate/JPA Bootstrapping JPA bootstrappen kan - net zoals JDBC en Jdbi - vrij eenvoudig met een statische klasse Persistence die een sessionFactory object aanmaakt. Elke session factory stelt een verbinding voor tussen de Java code en de Database zelf. Om te kunnen werken met objecten moet je vanuit de session factory de entity manager creëren. Vanaf dan kan er worden gewerkt met de database via de entity manager instantie.\nvar sessionFactory = Persistence.createEntityManagerFactory(\u0026#34;be.kuleuven.mijnmooiepackage\u0026#34;); var entityManager = sessionFactory.createEntityManager(); // do stuff with it! // entityManager.createQuery(...) javax.persistence.Persistence gaat op zoek naar een persistence.xml bestand in de map src/main/resources/META-INF. Die bevat alle connectiegegevens en instellingen. De persistence XML file is de belangrijkste file van je hele applicatie, waar caching strategie, driver management, table autocreation, \u0026hellip; allemaal in wordt bepaald!\nEen voorbeeld XML file:\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;persistence version=\u0026#34;2.1\u0026#34; xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/persistence\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd\u0026#34;\u0026gt; \u0026lt;persistence-unit name=\u0026#34;be.kuleuven.studenthibernate.domain\u0026#34;\u0026gt; \u0026lt;description\u0026gt;Studenten JPA Test\u0026lt;/description\u0026gt; \u0026lt;provider\u0026gt;org.hibernate.jpa.HibernatePersistenceProvider\u0026lt;/provider\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;property name=\u0026#34;javax.persistence.jdbc.driver\u0026#34; value=\u0026#34;org.sqlite.JDBC\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;javax.persistence.jdbc.url\u0026#34; value=\u0026#34;jdbc:sqlite:studenten.db\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;javax.persistence.jdbc.user\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;javax.persistence.jdbc.password\u0026#34; value=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;javax.persistence.schema-generation.database.action\u0026#34; value=\u0026#34;drop-and-create\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;hibernate.dialect\u0026#34; value=\u0026#34;org.hibernate.dialect.SQLiteDialect\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;hibernate.connection.autocommit\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;hibernate.show_sql\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;hibernate.flushMode\u0026#34; value=\u0026#34;ALWAYS\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;hibernate.cache.use_second_level_cache\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;hibernate.cache.provider_class\u0026#34; value=\u0026#34;org.hibernate.cache.NoCacheProvider\u0026#34; /\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/persistence-unit\u0026gt; \u0026lt;/persistence\u0026gt; Bevat onder andere de volgende belangrijke properties:\n javax.persistence JDBC driver/url. Merk op dat achterliggend dus nog steeds JDBC wordt gebruikt! Dat betekent ook dat we de sqlite dependency sqlite-jdbc van de groep org.xerial nog steeds nodig hebben. schema-generation properties: drop-and-create betekent dat tabellen die niet bestaan automatisch worden aangemaakt. Geen CREATE TABLE statements meer nodig, dus. hibernate.dialect: voor vendor-specifieke queries te genereren moet Hibernate weten welke database wij hanteren. Dit staat los van de jdbc driver! Hiervoor gebruiken we het dialect van dependency compile group: 'com.zsoltfabok', name: 'sqlite-dialect', version: '1.0'. Flush modes, auto-commit instellingen, caching, e.a. Dit gaat ver buiten de scope van deze cursus. show_sql print de gegenereerde queries af in de console, handig om te zien hoe Hibernate intern werkt, en om te debuggen.  Er ontbreekt hierboven nog een belangrijk gegeven: elke entity (domein object dat een tabel voorstelt in de code) moet met fully qualified name in een \u0026lt;class/\u0026gt; tag onder \u0026lt;persistence-unit/\u0026gt; worden toegevoegd. Anders herkent JPA het object niet, en heeft hij geen idee welke kolommen te mappen op welke properties. Die metadata zit namelijk in de entity klasse zelf.\nMeer informatie: zie hibernate.org documentatie en A beginners guide to JPA persistence xml.\n2.2.2 Hibernate/JPA Peristence/querying Nu de verbinding tussen de DB en Hibernate/JPA tot stand werd gebracht, is het tijd om gebruik te maken van de kracht van de library.\nOm kolommen te kunnen mappen op properties voorziet JPA een aantal annotaties als meta-data op het domeinobject zelf. Dat betekent dat DB beschrijving netjes bij het object waar het hoort wordt geplaatst. Bijvoorbeeld:\n@Entity data class Huis( @Column(name = \u0026#34;beschr\u0026#34;) var beschrijving: String, @Column var prijs: Int? = null, @Column @Id @GeneratedValue var id: Int = 0) @Entity public class Huis { @Column @Id @GeneratedValue private int id; @Column(name = \u0026#34;beschr\u0026#34;) private String beschrijving; @Column private int prijs; }  In Kotlin zijn types standaard not-nullable. Denk goed na over de mogelijke waardes van elk type: kan er ooit null in komen? Indien ja werk je met Kotlin\u0026rsquo;s optional alternatief: suffixen met een ?. Not-nullable types die later dan de constructor een waarde krijgen toegewezen worden aangeduid met lateinit. Zie Null safety Kotlin docs. Om Kotlins data class te laten samenwerken met oudere Java APIs zoals JPA/Hibernate, die niet kunnen omgaan met immutability, moeten we nog een extra plugin installeren: de no-arg plugin: id(\u0026quot;org.jetbrains.kotlin.plugin.jpa\u0026quot;) version \u0026quot;1.5.21\u0026quot; in de gradle plugins block. Die plugin genereert de nodige no-arg constructoren die JPA nodig heeft.\n Het datatype kan ook worden ingesteld met @Column (merk op dat de kolomnaam van de tabel in de DB kan en mag wijzigen van de property name in Java), bijvoorbeeld voor temporele waardes waar enkel de tijd of datum wordt bijgehouden op DB niveau. Merk op dat @Id nodig is op een @Entity - zonder primary key kan JPA geen object persisteren. @GeneratedValue is er omdat wij niet telkens de ID willen verhogen, maar dat willen overlaten aan de database vanwege de AUTOINCREMENT. Bij elke persist() gaat Hibernate de juiste volgende ID ophalen, dat zich vertaalt in de volgende queries in sysout:\nHibernate: select next_val as id_val from hibernate_sequence Hibernate: update hibernate_sequence set next_val= ? where next_val=? Hibernate: insert into Student (goedBezig, naam, voornaam, studnr) values (?, ?, ?, ?) De tabelnaam kan je wijzigen met de @Table annotatie op klasse niveau.\nInserts/updates Hoe bewaar ik een entity? entityManager.persist(object). That\u0026rsquo;s it!\nHoe update ik een entity, als properties zijn gewijzigd? .merge(object)\nMerk op dat in de Sysout output geen query wordt gegenereerd. Hibernate houdt alles in zijn interne cache bij, en zal pas flushen naar de database wanneer hij acht dat dat nodig is. Dat kan je zelf triggeren door entityManager.flush() te gebruiken (kan alleen in een transactie) - of het commando te wrappen met een transactie:\nwith(entityManager) { getTransaction().begin() persist(dingdong) getTransaction().commit() } entityManager.getTransaction().begin(); entityManager.persist(dingdong); entityManager.getTransaction().commit();  Zonder dit, en met herbruik van dezelfde entity manager in SQLite, is er een kans dat je SELECT query niets teruggeeft, omdat de INSERT nog niet werd geflushed. De interne werking van combinatie JDBC+SQLite+JPA+Hibernate is zeer complex en zou een cursus van 20 studiepunten vereisen\u0026hellip;\nQueries Hoe query ik in JPA? Dit kan op verschillende manieren. We beperken ons hier tot de JPA Criteria API. Een voorbeeld. Gegeven een huizenlijst, waarvan we huizen willen teruggeven die onder de 200.000 kosten. In SQL zou dit SELECT * FROM huizen WHERE prijs \u0026lt; 200000 zijn. In Criteria API:\nval criteriaBuilder = entityManager.getCriteriaBuilder() val query = criteriaBuilder.createQuery(Huis::class.java) val root = query.from(Huis::class.java) query.where(criteriaBuilder.equal(root.get\u0026lt;Int\u0026gt;(\u0026#34;prijs\u0026#34;), 200000)) return entityManager.createQuery(query).getResultList() var criteriaBuilder = entityManager.getCriteriaBuilder(); var query = criteriaBuilder.createQuery(Huis.class); var root = query.from(Huis.class); query.where(criteriaBuilder.equal(root.get(\u0026#34;prijs\u0026#34;), 200000)); return entityManager.createQuery(query).getResultList();  Voor simpele queries zoals deze is dat inderdaad omslachtig, maar de API is zeer krachtig en kan automatisch complexe queries genereren zonder dat wij ons moe moeten maken. Merk op dat wij geen enkele letter SQL zelf schrijven. Alles is java code, wat het eenvoudig maakt om te refactoren, redesignen, statische code analyse op te doen, unit testen, \u0026hellip; Lees meer over criteria API:\n Voorbeeld 2 Programmatic Criteria Queries Voorbeeld 3 TutorialsPoint Criteria API Voorbeeld 4 Using \u0026ldquo;In\u0026rdquo; in Criteria API  Controleer in de sysout output welke query Hibernate uiteindelijk genereert. Dat ziet er zo uit:\nselect student0_.studnr as studnr1_0_, student0_.goedBezig as goedbezi2_0_, student0_.naam as naam3_0_, student0_.voornaam as voornaam4_0_ from Student student0_ where student0_.naam=? 2.2.3 Oefeningen Quickstart project: hibernate-jpa-start.zip!\n Het is opnieuw tijd voor onze studentendatabase. Open of kopiëer het project van 1. jdbc en jdbi (of start met het quickstart project). We voorzien een derde implementatie van de StudentRepository interface, naast de JDBC en Jdbi3 versies: StudentRepositoryJpaImpl. Probeer een nieuwe student te bewaren én daarna dezelfde student op te halen en af te drukken in sysout. Wat heb je daar weer voor nodig? (Scroll up!)  Een configuratiebestand in resources/META-INF. Entities, zoals onze Student klasse. Bootstrappen van de EntityManager. Een repository implementatie die de EntityManager gebruikt (tip: constructor injectie!)   Modelleer ook de log tabel uit 1. Failures/rollbacks. Bewaar een log record bij elke wijziging van student (aanmaken, wijzigen). Vergeet geen \u0026lt;class/\u0026gt; entry toe te voegen in je persistence.xml! Anders krijg je de volgende fout:  Exception in thread \u0026quot;main\u0026quot; java.lang.IllegalArgumentException: Not an entity: class be.kuleuven.studenthibernate.domain.Student at org.hibernate.metamodel.internal.MetamodelImpl.entity(MetamodelImpl.java:566) at org.hibernate.query.criteria.internal.QueryStructure.from(QueryStructure.java:127) at org.hibernate.query.criteria.internal.CriteriaQueryImpl.from(CriteriaQueryImpl.java:158) 2.2.4 JDBC VS Jdbi3 VS JPA  JDBC: Low-level relationele mapping tussen Java en DB. Wordt door alle high-level API\u0026rsquo;s gebruikt. Omslachtig (checked Exceptions, beperkte interface), erg kort bij SQL. Functionaliteit: minimaal. Jdbi3: High-level relationele mapping no-nonsense API bovenop JDBC die in feite alle negatieve kenmerken van JDBC wegwerkt. Nog steeds kort bij SQL, maar meer object-friendly door Fluent/Declarative API. Functionaliteit: nog steeds basic, maar wel met gebruiksgemak. JPA en vendors: High-level object-relational mapper bovenop JDBC waarbij entities centraal staan en compatibiliteit met Java EE is ingebouwd. Genereert SQL (zelf raw queries schrijven kan nog steeds, maar wordt afgeraden). Functionaliteit: enorm uitgebreid.  Kies altijd bewust voor één bepaald framework in plaats van \u0026ldquo;random\u0026rdquo; of \u0026ldquo;uit ervaring\u0026rdquo;: JPA/Hibernate is vaak overkill voor simpele applicaties, JDBC is vaak té low-level en bevat veel boilerplating, terwijl Jdbi3 daartussen ligt.\nZijn er nog alternatieven? Uiteraard, en meer dan één\u0026hellip; Maar dat reikt buiten de scope van deze cursus.\n2.3 Many-to-one relaties in Hibernate/JPA De grootste kracht van JPA hebben we nog steeds niet gezien: in plaats van één of meerdere entiteiten onafhankelijk te mappen, kunnen we ook relaties mappen en Hibernate alles op SQL-niveau laten afhandelen. Nooit meer JOIN statements schrijven, hoera!\u0026hellip; Niet altijd. Soms wil je de queries anders aanpakken dan Hibernate ze genereert omwille van performantie redenen. In dat geval zal je nog steeds moeten teruggrijpen naar native SQL - of veel tijd investeren in de correcte configuratie van de Hibernate/JPA/JDBC installatie.\nEen concreet voorbeeld. Een Docent entiteit geeft les aan verschillende studenten:\n@Entity data class Docent( @Id @GeneratedValue var docentennummer: Int, @Column var naam: String, @OneToMany(mappedBy = \u0026#34;docent\u0026#34;) var studenten: List\u0026lt;Student\u0026gt; ) @Entity public class Docent { @Id @GeneratedValue private int docentennummer; @Column private String naam; @OneToMany(mappedBy = \u0026#34;docent\u0026#34;) private List\u0026lt;Student\u0026gt; studenten; }  De @OneToMany annotatie zorgt voor de link tussen de studenten- en docententabel: het is wel nog nodig om een omgekeerde mapping property genaamd docent toe te voegen op de Student klasse:\n@Entity data class Student( // ...  @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;docent_nr\u0026#34;) var docent: Docent? ) @Entity public class Student { // ...  @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \u0026#34;docent_nr\u0026#34;) private Docent docent; }  Op die manier kan je van docenten onmiddellijk zien aan wie ze lesgeven (one to many), en van een student van wie hij of zij les krijgt (many to one). De data wordt in de studententabel bewaard, in kolom docent_nr. Andere configuraties zoals tussentabellen zijn uiteraard ook mogelijk.\nPersisteren we nu een nieuwe docent waar een reeds bewaarde student in de lijst werd toegevoegd:\nprivate fun docentenTest(entityManager: EntityManager, student: Student) { val wouter: Docent(\u0026#34;Wouter\u0026#34;).apply { geefLesAan(student) } with(entityManager) { begin() persist(wouter) commit() } } private static void docentenTest(EntityManager entityManager, Student student) { var wouter = new Docent(\u0026#34;Wouter\u0026#34;); wouter.geefLesAan(student); entityManager.getTransaction().begin(); entityManager.persist(wouter); entityManager.getTransaction().commit(); }  Geeft in Hibernate:\nHibernate: select next_val as id_val from hibernate_sequence Hibernate: update hibernate_sequence set next_val= ? where next_val=? Hibernate: insert into Docent (naam, docentnummer) values (?, ?) SQLite browser:\nWaar is onze docent_nr data? De methode geefLesAan voegt enkel toe aan de studentenlijst, maar de relatie moet voor beide entities kloppen:\nfun geefLesAan(student: Student) { studenten.add(student) student.docent = this } public void geefLesAan(Student student) { studenten.add(student); student.setDocent(this); }  Zonder de tweede regel wordt de kolom niet ingevuld. Geeft nu:\nHibernate: select next_val as id_val from hibernate_sequence Hibernate: update hibernate_sequence set next_val= ? where next_val=? Hibernate: insert into Docent (naam, docentnummer) values (?, ?) Hibernate: update Student set docent_nr=?, goedBezig=?, naam=?, voornaam=? where studnr=? Bingo, een UPDATE statement in de studententabel. SQLite Browser:\n2.3.1 Oefeningen  Implementeer de Docent klasse zoals hierboven.  Wat gebeurt er als je studenten opvraagt? Wat gebeurt er als je een docent van een student opvraagt? De FetchType.LAZY schiet in gang. Verander dit naar EAGER. Kijk in de Hibernate output wat er verandert op SQL niveau en verifiëer dat er nu een LEFT OUTER JOIN in de SELECT van de student staat.    Pas op het moment dat de data van de docent effectief nodig is, zoals bij het afdrukken, wordt een SELECT query gelanceerd bij lazy-loading. Bijvoorbeeld:\nval student = entityManager.find(Student::class.java, jos.studentennummer) println(\u0026#34;student ${student.naam}\u0026#34;); println(\u0026#34; -- heeft als docent ${student.docent.naam}\u0026#34;) var student = entityManager.find(Student.class, jos.getStudentenNummer()); System.out.println(\u0026#34;student \u0026#34; + student.getNaam()); System.out.println(\u0026#34; -- heeft als docent \u0026#34; + student.getDocent().getNaam());  Geeft als sysout output:\nHibernate: select student0_.studnr as studnr1_1_0_, student0_.docent_nr as docent_n5_1_0_, student0_.goedBezig as goedbezi2_1_0_, student0_.naam as naam3_1_0_, student0_.voornaam as voornaam4_1_0_ from Student student0_ where student0_.studnr=? student Lowiemans Hibernate: select docent0_.docentnummer as docentnu1_0_0_, docent0_.naam as naam2_0_0_ from Docent docent0_ where docent0_.docentnummer=? -- heeft als docent Wouter Merk op dat de eerste System.out.println vóór de docenten SELECT query komt. Een eager-loaded docent geeft andere output:\nHibernate: select student0_.studnr as studnr1_1_0_, student0_.docent_nr as docent_n5_1_0_, student0_.goedBezig as goedbezi2_1_0_, student0_.naam as naam3_1_0_, student0_.voornaam as voornaam4_1_0_, docent1_.docentnummer as docentnu1_0_1_, docent1_.naam as naam2_0_1_ from Student student0_ left outer join Docent docent1_ on student0_.docent_nr=docent1_.docentnummer where student0_.studnr=? student Lowiemans -- heeft als docent Wouter Tip: entityManager.clear() of close() een nieuwe aanmaken kan helpen om de persistence context te flushen ter test.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/hoorcolleges/slides-2/",
	"title": "2. NoSQL Databases: Advanced concepts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/apis/ex/",
	"title": "3. Extra Oefeningen",
	"tags": [],
	"description": "",
	"content": "SESsy Library - Revisited Voorbereiding: Maak uzelf opnieuw vertrouwd met de SESsy Library applicatie, de geïntegreerde oefening uit het tweedejaarsvak Software Engineering Skills.\nHet is interessant om de libraries die de app gebruikt eens in detail te inspecteren. Dat kan met gradlew dependencies. In context van het vak Databasess zien we dat de webapp gebouwd is met de volgende relevante tools en libraries:\n Als database endpoint wordt com.h2database.h2 gebruikt. De Dropwizard jdbi3 dependency verwijst op zijn beurt naar een variant van jdbc De sqlobject plugin van Jdbi3 wordt gebruikt.  Zoals een snippet van de dependency tree aangeeft:\n... +--- io.dropwizard:dropwizard-jdbi3:2.0.0-rc12 | +--- io.dropwizard:dropwizard-db:2.0.0-rc12 | | +--- io.dropwizard:dropwizard-core:2.0.0-rc12 (*) | | \\--- org.apache.tomcat:tomcat-jdbc:9.0.27 | | \\--- org.apache.tomcat:tomcat-juli:9.0.27 ... Oefeningen  Inspecteer de H2 Database Engine documentatie. Wat is het verschil tussen H2 en MySQL? En wat zijn de gelijkenissen tussen H2 en SQLite dat elders in deze cursus wordt gebruikt? Zoek in de SEssy code waar de Jdbi3 sqlobject annotaties worden gebruikt. Dit is dus de Jdbi Declarative API (zie docs). Wat zou je moeten doen om dit te refactoren naar de Fluent API? Voer de veranderingen door voor de methode findBooksByTitle(). Worden ergens transacties gebruikt? Wordt er ergens in de code bewaakt tegen concurrency? Indien niet, bouw dit in voor het uitlenen van boeken in de methode borrow(). Moet transactie beheer op niveau van Resource klasses staan, of behoort het volgens jou toe aan de Repository klasses? Welke code heb je specifiek nodig om in Jdbi3 transacties te hanteren? Stel dat ik in een nieuwe repository klasse een low-level SQL statement zelf wil schrijven en uitvoeren, rechtstreeks naar de database, in plaats van via Jdbi3. Hoe kan ik dat doen? Probeer dit zelf in de code door iets met de books tabel te doen (bijvoorbeeld een COUNT). Is er een manier om de queries die Jdbi3 uitvoert in H2 ook af te drukken, zoals Hibernate\u0026rsquo;s show_sql config flag? We zijn niet meer tevreden over de performantie en het gebruiksgemak van H2. We wensen in de plaats daarvan JPA + Hibernate te gebruiken. Voer de nodige veranderingen door. Test de applicatie ook uitvoerig door de webserver op te starten! De integratie testen die falen mag je negeren, dat valt buiten deze cursus om die ook te converteren. Denk eerst goed na over welke wijzigingen allemaal moeten gebeuren:  Welke config file wordt nu gebruikt om de database file/connectionstring op te geven? Hoe kan je dat vervangen door persistence.xml? Kan je interfaces, strategies, of facades gebruiken om eerst de H2 implementatie te verbergen, en dan te refactoren, of is dat niet meer nodig? Is er een manier in Dropwizard om eenvoudiger Hibernate session factories aan te maken? (ja dus!) \u0026hellip;    "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/hoorcolleges/slides-3/",
	"title": "3. NoSQL Graphs, Case Studies",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/hoorcolleges/slides-4/",
	"title": "4. Transactie Management",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/",
	"title": "Index",
	"tags": [],
	"description": "",
	"content": " Databases  Laatste aanpassingen voor academiejaar 2021 - 2022.\n Planning    nr datum onderwerp     1 do 28-10-2021 NoSQL 1: intro HC, key/value en document stores   2 do 18-11-2021 NoSQL 2: advanced concepts, case studies (1)   3 do 25-11-2021 NoSQL 3: map/reduce, replication, graph stores, case studies (2)   4 do 02-12-2021 Transactie management HC/oefeningen   5 do 09-12-2021 Database APIs 1: ORM mapping, Hibernate   6 do 16-12-2021 Database APIs 2: H2, Sessy Library   7 do 23-12-2021 Database APIs 3: Transacties, Sessy Library naar CouchDB    Cursus notities Hoorcolleges Index pagina van alle hoorcolleges.\nOnderstaande hoorcolleges zijn complementair aan degene die via Toledo worden aangeboden.\n NoSQL Databases: Introductie - HF11 p.300 NoSQL Databases: Advanced concepts - HF11 p.334 Transactie Management - HF14 p.430 Database APIs - HF15 p.458  Labo noties  NoSQL:  Key/Value stores Document stores Advanced map/reduce queries Replication   Transacties:  Failures/Rollbacks Concurrency   Database APIs:  JDBC en JDBI JPA en Hibernate Extra oefeningen    Syllabus  Lesgevers: Coördinerend Verantwoordelijke: prof. dr. Kris Aerts - kris.aerts@kuleuven.be Onderwijsassistent: Wouter Groeneveld - wouter.groeneveld@kuleuven.be Kantoor: Technologiecentrum Diepenbeek, Groep ACRO, D.0.35. Verplicht handboek: Principles of Database Management, Wilfried Lemahieu  Cursusbeschrijving Dit opleidingsonderdeel focust enerzijds op drie soorten databases:\n relationele databases de NoSQL-alternatieven XML databases  En anderzijds op twee toepassingen:\n programmeren van database-gestuurde applicaties via API\u0026rsquo;s een inleiding in Big Data  Dit reflecteert zich in de volgende selectie van hoofdstukken uit het handboek:\n Part I. Databases and Database Design    Fundamental concepts of database management    Conceptual data modeling using the (E)ER model and UML class diagram     Part II. Types of Database Systems:   Relational databases: the relational model    Relational databases: structured query language (SQL)    XML databases    NoSQL databases (+ 16.7)     Part III. Physical Data Storage, Transaction Management, and Database Access   Basics of transaction management    Accessing databases and database APIs     Part IV. Data Warehousing, Data Governance and (Big) Data Analytics   Big data      Merk op dat we dus niet het volledige boek behandelen. Dit zou ver voorbij het bereik van 4 studiepunten gaan.Toch blijft de aankoop verantwoord aangezien andere boeken die dezelfde thema\u0026rsquo;s behandelen nog een pak duurder zijn en ook altijd overbodige hoofdstukken voor dit opleidingsonderdeel bevatten. Bovendien zijn de niet-behandelde thema\u0026rsquo;s interessant voor extra-curriculaire zelfstudie.\nVereiste voorkennis  Basiskennis van een Object-Geörienteerde programmeertaal als Java of C# Basiskennis van het UNIX systeem, werken met commandline  Doelstellingen Zie ook Studiegids UHasselt\nDe context en het overzicht worden aangereikt in het hoorcollege.\nAls practicum wordt een grotere probleemstelling als project uitgewerkt. Alle aan te leren aspecten van databases komen in dit project aan bod. Studenten kunnen facultatief buiten het practicum extra thematische oefeningen oplossen.\nKalender Zie collegeroosters UHasselt.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/db-course/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]