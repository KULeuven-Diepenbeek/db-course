[
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/hoorcolleges/",
	"title": "Hoorcolleges",
	"tags": [],
	"description": "",
	"content": " Slides Er zijn in totaal 4 hoorcolleges voorzien. Indien er meer online colleges zijn ingepland, later dan de laatste datum van het hoorcollege, vallen deze colleges weg.\nHoorcolleges 1. Introductie in C/C++: context, ecosysteem Datum: 22/09/2020\n GBA Projecten vorige jaren:\n  2. Pointers in C, dynamisch geheugen in C++ Datum: 29/09/2020\n 3. Introductie in Object-Georiënteerd denken in C++ Datum: 06/10/2020\n 4. Een introductie in GUI ontwerp met Qt, Samenvatting, examen info Datum: 13/10/2020\n "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/c/",
	"title": "1. Introductie in C",
	"tags": [],
	"description": "",
	"content": " Introductie in C "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/c/prep/",
	"title": "Voorbereiding Thuis",
	"tags": [],
	"description": "",
	"content": " Installaties Volg de installatieinstructies en zorg ervoor dat de basisvereisten geïnstalleerd zijn:\n Een C compiler geïnstalleerd is (build essentials) Je vlot toegang hebt tot cmdline (Op Windows: met cmder, zie bovenstaande instructies) git geïnstalleerd is  Controle  Controleer of git werkt door git version uit te voeren in cmdline. Controleer of je compiler correct is geïnstalleerd door gcc -v uit te voeren, en make -v. Kopiëer het eerste voorbeeld in de tekst van labo 1 (\u0026ldquo;vergelijkingen met Java\u0026rdquo;) en probeer dit zelf te compileren in C met gcc [bestand.c]. Uitvoeren doe je door de binary in cmdline uit te voeren, standaard genoemd \u0026ldquo;a.out\u0026rdquo;: ./a.out.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/cpp/prep/",
	"title": "Voorbereiding Thuis",
	"tags": [],
	"description": "",
	"content": " Installaties Volg de installatieinstructies en zorg ervoor dat:\n CMake geïnstalleerd is een C++ compiler geïnstalleerd is De google test instructies doorgelopen zijn en geïnstalleerd is  Controle  Controleer of g++ werkt in cmdline. Download gcctest.cpp en compileer het met de g++ compiler (++ gcctest.cpp \u0026amp;\u0026amp; ./a.out). Is de output \u0026ldquo;het werkt!\u0026rdquo;, dan is alles ok.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-c/prep/",
	"title": "Voorbereiding Thuis",
	"tags": [],
	"description": "",
	"content": " Installaties Volg de installatieinstructies en zorg ervoor dat de devkitPro tools geïnstalleerd zijn:\n DevkitPro installatie om te cross-compilen en toe te voegen aan je PATH variabele. Download een GBA emulator, bij voorkeur mGBA, via mgba.io.  Controle  Controleer in cmdnline of arm-eabi-none-gcc in eender welke locatie werkt. Ga naar de labo 3 opgave en probeer eerste opgave te downloaden en compileren met de Makefile. Oplossen hoeft nog niet. Controleer of de .gba file werkt door het in de emulator in te laden.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-cpp/prep/",
	"title": "Voorbereiding Thuis",
	"tags": [],
	"description": "",
	"content": " Installaties Volg de installatieinstructies en zorg ervoor dat:\n CLion geïnstalleerd is indien gewenst (of een Een andere geïntegreerde IDE geïnstalleerd is)  Controle  Compileer gba-sprite-engine Lees de README Controleer of de demo\u0026rsquo;s werken door een .gba bestand te openen in de mGBA emulator  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-c/",
	"title": "2. GBA programming in C",
	"tags": [],
	"description": "",
	"content": " GBA Programming in C "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-cpp/labo-8/",
	"title": "Labo 8: GBA Programming in C++: een abstractielaag",
	"tags": [],
	"description": "",
	"content": " Het zal je ondertussen wel al duidelijk zijn dat technische details zoals IO pointers en OAM vanuit labo 4 de code er niet bepaald duidelijker op maken. Jammer genoeg voorziet de GBA geen andere mogelijkheden. Een oplossing zal van de ontwikkelaar zelf moeten komen, in de vorm van de principes uit labo 7.\nAbstracties creëren Als ontwikkelaar wil ik niet altijd bezig zijn met de juiste hexadecimale waarde voor IO pointer aan te spreken om een sprite te renderen. Dit zou éénmalig voorzien moeten worden, en dan herbruikbaar moeten zijn. Herbruikbaarheid betekent:\n In C: gebruik maken van function, struct In C++: gebruik maken van class bovenop bovenstaande.  De oplossing van labo 4 voorziet methodes als create_sprite die zowel voor de bal, de paddle als de blokken aangeroepen kunnen worden. Omdat de OAM structuur té low-level is, voorzien we een abstractielaag: de functie geeft een sprite* struct terug die we zelf ontworpen hebben:\ntypedef struct sprite { int x; // position  int y; int dx; // velocity  int dy; uint8 w; // dimensions (bvb simple hitbox detection)  uint8 h; volatile oam_object *obj; } sprite; De sprite struct heeft een reference naar oam_object* vast. Dit noemt men \u0026ldquo;wrapping\u0026ldquo;: de code kan niet rechstreeks aan het object maar moet met de sprite werken. In C zijn er geen mogelijkheden om dit te encapsuleren met een access modifier zoals C++\u0026rsquo; private.\nVergeet niet dat deze eigenschappen redundant zijn en geheugen innemen voor niets\u0026hellip; In de OAM struct zitten eigenlijk in bepaalde bits diezelfde eigenschappen (x, y, w, h). De afweging tussen gebruiksgemak en geheugengebruik is in dit geval echter eenvoudig gemaakt. sprite.x is een pak eenvoudiger in gebruik dan sprite.obj-\u0026gt;attr1 | OAM_X_MASK!\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[highlevel Sprite struct] B[lowlevel OAM struct] A -- |obj*|B  De waardes in de sprite manipuleren levert echter een synchronisatie probleem op: de GBA reageert enkel op het OAM geheugen dus we moeten beide waardes in sync houden:\nvoid position(sprite *s) { volatile object *obj = s-\u0026gt;obj; int x = s-\u0026gt;x; int y = s-\u0026gt;y; obj-\u0026gt;attr0 = (obj-\u0026gt;attr0 \u0026amp; ~OAM_Y_MASK) | (y \u0026amp; OAM_Y_MASK); obj-\u0026gt;attr1 = (obj-\u0026gt;attr1 \u0026amp; ~OAM_X_MASK) | (x \u0026amp; OAM_X_MASK); } De Gameboy Advance en C++ De devKit toolchain voorziet ook een C++ cross-compiler: arm-none-eabi-gcc wordt simpelweg arm-none-eabi-g++. That\u0026rsquo;s it! Je kan C++11 gebruiken en naar hartelust STL bibliotheken in de code verwerken in plaats van met char* \u0026ldquo;collecties\u0026rdquo; te moeten werken.\nEchter\u0026hellip; Er is geen enkel productiespel ooit uitgebracht op een cartridge dat in C++ geschreven is. Dit om de eenvoudige reden dat C++ een hoop overhead met zich meebrengt:\n De footprint van een .gba ROM is véél groter in C++ door extra libraries De memory footprint van een class t.o.v. een struct zou +/- 4 bytes extra zijn  Gezien de erg beperkte hardwaremogelijkheden van de GBA is het voor veel grote spellen praktisch gezien niet haalbaar om alles in C++ te schrijven. Trouwens ook niet in C: veel kritieke instructies in engines zijn nog in Assembly geschreven.\nls -la output:\n -rwxr-xr-x 1 wgroenev staff 8320 Jul 25 13:54 main_c.gba -rwxr-xr-x 1 wgroenev staff 23328 Jul 22 20:36 main_cpp.gba -rwxr-xr-x 1 wgroenev staff 24032 Jul 25 13:55 main_cpp_stl.gba  De C++ ROM is 280% groter dan de C ROM, als je \u0026lt;vector\u0026gt; e.d. mee include zelfs 288% - van 8K naar 23K!\nVoor Software ontwerp in C/C++ ligt de focus op software ontwerp, niet op performante algoritmes of hardware. Wij gaan dit \u0026ldquo;probleem\u0026rdquo; dus straal negeren en vanaf nu alles in C++ schrijven. Emulators hebben hier geen probleem mee, evenals de EZ-FLASH Omega ROM die ik gebruik om op echte hardware te draaien.\nEen minimale 2D sprite engine Welke concepten hebben we nodig om een minimaal spel te ontwerpen dat met 2D sprites werkt (MODE1)? Neem de Arkanoid clone opnieuw als voorbeeld. Ook technische vereisten zoals deze kunnen in een analyse gegoten worden om de ontwerpfase van het ontwikkelen te vergemakkelijken:\n GBA001. Een minimale 2D sprite engine Beschrijving: Als programmeur wil ik niet bezig zijn met technische details van de GBA interface bij het ontwikkelen van een spel. Ik wil eenvoudig sprites op het beeld kunnen toveren en deze kunnen manipuleren. Context: Het moet mogelijk zijn om het gebruik van OAM en VRAM te vergemakkelijken. Acceptatiecriteria: - Ik wil als ontwikkelaar bij het boostrappen van het spel \"sprite mode\" kunnen kiezen. - Ik wil makkelijk sprites kunnen toevoegen aan de hand van een externe image in jpg/png formaat zonder iets van het palet af te weten. - Ik wil sprites kunnen verplaatsen op het scherm - Ik wil eenvoudig kunnen zien of sprite 1 \"botst\" met sprite 2.  Dit vraagt niet om een volledige herwerking van de opgave uit labo 4, maar om een abstractielaag in de vorm van klassen. Welke concepten kunnen we afleiden uit de analyse, of welke ontbreken er nog?\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; Z{GBA} A{SpriteManager} B{Sprite} C[OAM] D[Palet] E[ImageData] Z -- |setRenderer|A A -- |add1 op veel|B B -- |\"collidesWith(other)\"|B B -- |\"move(x,y)\"|B B -.- C B -.- D B -.- E  Bovenstaand model kan afwijken van wat jij in gedachten had: hier is geen enkelvoudig antwoord op te geven, de enige vereiste is een laag tussen het gebruik van OAM, VRAM en de programmeur die als designer optreedt.\nDenk bij het ontwerpen van een klasse na over eventuele logische operatoren die van pas kunnen komen. Het is niet de bedoeling om een hoop overrides te implementeren om te laten zien hoe goed je daar in bent: code wordt \u0026ldquo;just-in-time\u0026rdquo; geschreven: YAGNI. Templates en abstracte klassen zijn ook niet altijd nodig.\nGa uit van het eenvoudigst mogelijke. Welke minimale elementen heb je absoluut nodig om de vereiste analyse tot een goed einde te brengen? Laat alle toeters en bellen achterwege en concentreer je op herbruikbaarheid en Clean Code.\nImage data importeren Het OAM is gekoppeld aan een referentie naar het palet samen met een referentie naar het VRAM waar je je image data in de vorm van een \u0026ldquo;tileset\u0026rdquo; hebt opgeslagen. Voor de paddle voorzagen wij met een simpele for lus onze eigen tile data:\nfor(int i = 0; i \u0026lt; 4 * sizeof(tile_4bpp) / 2; i++) { paddle_tile[i] = 0x2222; } In de praktijk wordt art aangeleverd door 2D artiesten die gespecialiseerd zijn in pixel art. Deze files moeten we vertalen naar hexadecimale waarden gegroepeerd in tileset en palet data.\nGegeven de volgende \u0026ldquo;pixel art\u0026rdquo;:\nHerinner je dat OAM data vaste groottes hebben: we kiezen hier voor 64x32. Hoe verwerken we deze png in de ROM? Emulator screenshot:\nDaar hebben we png2gba voor nodig, die de image omzet naar hexadecimale data. De broncode van bovenstaande screenshot verduidelijkt dit. Op de github pagina staan instructies om het tooltje te compileren.\n Exporteer een header file: png2gba -p -t img.png #include \u0026lt;kul.h\u0026gt; Kopiëer data rechtstreeks naar VRAM met memcpy Map palet en VRAM index op een OAM object zoals gezien in labo 4\nvoid copy_image_data() { memcpy(pal_fg_mem, kul_palette, sizeof(kul_palette)); memcpy(\u0026amp;tile_mem[0][0], kul_data, sizeof(kul_data)); }  OAM attributes maken het eenvoudig om de image horizontaal of verticaal te flippen, bijvoorbeeld bij sprite animaties die naar links of naar rechts lopen. Transformatiematriches zijn nodig om te roteren.\nExport tool Grit (Voor Windows gebruikers: Wingrit) geeft meer mogelijkheden, om bijvoorbeeld stukken van een palet te exporteren met ./grit piskel.png -p -gt -gB4 -ftc -pe 16 - zie handleiding. Maak op piskelapp.com je eigen pixel art.\nEen kijkje achter de schermen Emulators zoals mGBA zijn krachtige tools voor de beginnende GBA ontwikkelaar om te graven in hun favoriete ROM. Ze bieden de mogelijkheid om tiles, palettes, sprites, geheugenwaardes, \u0026hellip; allemaal in te kijken. Een van mijn favoriete games is Castlevania: Aria of Sorrow. Ik kan met mGBA zien hoe de sprites zijn opgedeeld in het scherm.\nProbeer aan de hand van deze animatie maar eens te bepalen welke sprites gebrukt worden, en welke achtergronden:\nHerinner je uit labo 4 dat er 4 VRAM pointers naar achtergrond geheugen is: 4 char blocks. Bovenstaand spel creëert zo de illusie van diepte: verschillende achtergronden schuiven over elkaar met verschillende snelheden (kijk goed naar de maan).\n Alles aan   Sprites (OAM) uit    bg3 uit   bg2 uit   Uiteindelijk stelt zo\u0026rsquo;n 2D platformspel niet zo veel voor op gebied van sprite engine. Er kunnen immers maar maximum 128 objecten tegelijkertijd in het geheugen opgeslagen worden. In Aria of Sorrow wordt dat opgelost met \u0026ldquo;tussenschermen\u0026rdquo;: van area 1 naar 2 moet je door een soort van sluis. In de achtergrond wordt een hoop nieuwe data in alle IO adressen gepompt.\nHet meeste werk ligt bij de artist. De screenshot linksboven toont de aanwezigheid van 2 personage sprites (Alucard en Soma) en 3 nummer sprites (Healthbar: 3, 2, 0). Toch klopt dit niet helemaal als je graaft in de mGBA sprite explorer:\nSoma bestaat uit 2x 64x32 OAM objecten!  Er zal dus ook een soort van OAM manager nodig zijn die beide sprites aan elkaar rijgt, zodat in de code en in het spel dit één sprite lijkt te zijn. Dit zijn nog artefacten van de originele Gameboy.\nLabo oefeningen  Implementeer bovenstaande technische analyse in C++. Verterk vanuit een modeloplossing van labo 4. Bedenk welke verplichte parameters nodig zijn om een sprite \u0026ldquo;in te laden\u0026rdquo;. Test om te beginnen de C implementatie met de gcc compiler met behulp van de Makefile uit labo 3. Voorzie ook een KeyManager die inlezen van toetsen abstraheert. Werken met functie pointers als callback methodes is niet nodig.  Voor oefening 1 is er een alternatief met CLion en CMake: Verterk vanuit deze template: labo8-gbagplusplus.zip.\nDenkvragen  Welke functies uit de opgave zou je niet abstraheren in klassen maar voldoen aan een duidelijke naamgeving? Waarom zouden dezen wel in de global namespace mogen leven? Wat als ik een sprite nodig heb die groter is dan 64x64? Wat zou de SpriteManager klasse moeten teruggeven bij het aanmaken van een \u0026ldquo;sprite\u0026rdquo; (niet een GBA sprite, maar de term die wij handhaven)?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-cpp/labo-9/",
	"title": "Labo 9: GBA Programming in C++: scrolling backgrounds",
	"tags": [],
	"description": "",
	"content": " Uit labo 4 weten we hoe het VRAM van de GBA in elkaar steekt: het bestaat uit char en screen blocks. Character blocks 0 tot en met 3 vanaf 0x6010000 zijn gereserveerd voor achtergrond lagen: dat is in totaal meer geheugen dan voor sprites. De Gameboy Advance voorziet aparte registers om de 4 achtergrond lagen te configureren.\nVoor sprites speelde een tilemap geen rol, voor grote achtergronden wel: het kost immers minder ruimte om de tile data apart op te slaan en in een map per tile te refereren naar die data. Achtergrond art is typisch iets herhalend: veel wolkjes, dezelfde soorten muren, plafond en vloeren. Uit labo 4:\n Om tegen de GBA te zeggen welke tile op welke plaats in het scherm moet komen hebben we een tilemap nodig. Een tilemap kan wél heel groot worden en stelt letterlijk het \u0026ldquo;level\u0026rdquo; of de \u0026ldquo;map\u0026rdquo; voor, met op elke plaats in de 2-dimensionele lijst een referentie naar een tile. Zie Metroid Level voorbeeld.\n Een uitbreiding op de abstractielaag We introduceren de volgende nieuwe concepten in ons domein model:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A{Palet} B{Achtergrond} C[AchtergrondLaag0] D[AchtergrondLaag1] E[AchtergrondLaag2] F[AchtergrondLaag3] G[Voorgrondpalet] H[Achtergrondpalet] A -- G A -- H B -- C B -- D B -- E B -- F  Waarbij de diamant blokken abstracte klassen voorstellen.\nHet achtergrondpalet Juist zoals het voorgrondpalet (adres 0x5000200) is er maar één palet voor de achtergrond aanwezig bestaande uit 256 kleuren. Om hier mee om te gaan heb je een paar mogelijkheden:\n Per verwisseling van achtergrond persisteer je een nieuw palet in het geheugen. Elke achtergrondlaag deelt hetzelfde palet.  Het adres voor het achtergrondpalet is 0x5000000.\nHet achtergrond register De GBA heeft net zoals het OAM een aantal flags in de vorm van bits nodig per achtergrond om te configureren in welk VRAM de imageset steekt en hoe groot het is. Zie ook weer gbatek specificaties. De belangrijkste flags leven vanaf bit 8 (screen block naar tilemap) en 2 (char block naar imageset).\nDe adressen voor elk register zijn:\n 0x4000008 voor BG0 0x400000a voor BG1 0x400000c voor BG2 0x400000e voor BG3  De gewenste achtergronden moeten net als de video mode in het algemeen controle register aangezet worden:\n#define MODE0 0x00 #define MODE1 0x01  #define BG0_ENABLE 0x100 #define BG1_ENABLE 0x200 #define BG2_ENABLE 0x400 #define BG3_ENABLE 0x800  display_control = MODE0 | BG0_ENABLE; Mode 0 hebben we later nodig om de achtergrond te laten scrollen. Mode 0, 1 en 2 zijn drie mogelijke \u0026ldquo;tile\u0026rdquo; (sprite) modes.\nHet tilemap adres Tilemaps leven net zoals de rest wat tiles aanbelangt in het VRAM. Kies een geheugen plaatsje dat niet in beslag genomen wordt door je eigenlijke tile data.\nEen tilemap ontwerpen in notepad is snel vervelend en geeft geen visuele feedback. Er zijn tools op ROMHacking.net die (al dan niet specifiek per spel) het ontwerpen vergemakkelijken. De eenvoudigste is GBA Tile-editor:\n(Voor Windows gebruikers: Wingrit)  De Onderste image is de tileset. Selecteer één tile en klik dan op een plaats om die tile op de map te doen verschijnen. De editor exporteert de map als een unsigned short[]:\nconst unsigned short map [] = { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0012, 0x0014, 0x0014, 0x0015, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0008, 0x0009, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x001d, }; De waardes zijn referenties naar de tiles in de tileset met 0x0000 als éérste tile linksboven (de blauwe lucht). Dit kopiëren we op dezelfde manier (memcpy) als de tileset op een ongebruikte plaats in het VRAM.\nDe map laten scrollen Een tilemap kan best groot worden, en bijna alle 2D platformers of top-down adventure spellen op de GBA hebben een achtergrond die \u0026ldquo;scrollt\u0026rdquo;. Herinner je het Castlevania voorbeeld uit labo 8:\nJe kan duidelijk zien dat de achtergrond niet alleen bestaat uit verschillende lagen, maar ze ook scrollt afhankelijk van de positie van Soma, het hoofdpersonage. Scrollen in X of Y richting is heel eenvoudig en vereist - verrassing! - manipuleren van een register: van 0x4000010 tot 0x400001e (+2, beginnen met bg0 x, bg0 y, bg1 x, \u0026hellip;).\nDit is een write-only register: de X en Y scroll waardes zal je zelf in een variabele moeten bijhouden. Vergeet dit niet te doen na een VBLANK om tearing te vermijden.\nDe toepassing in C++ De verschillende lagen zijn een ideaal slachtoffer om in C++ concepten als templates of abstract klassen toe te passen. De enige verschillen zijn immers de adressen in in het RAM.\nOm geen random waardes te gebruiken als charblock of screenblock om de tileset en tilemaps van elke achtergrond in weg te schrijven hebben we nood aan een \u0026ldquo;geheugen beheerder\u0026rdquo; concept:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[MemoryManager] Base{BaseBGLayer} B0[BGLayer0] B1[BGLayer1] B2[BGLayer...] B0 -- Base B1 -- Base B2 -- Base C[BackgroundPalette] D[Tileset] E[Tilemap] F[\"Scroll value(x,y)\"] Base -- D Base -- E Base -- F Base -.- C  De memory manager en het achtergrondpalet zijn gedeeld tussen de backgroundlayer instanties. Uit het schema van labo 8 weten we dat een GBA klasse nodig is die de memory manager, achtergrondlagen en paletten aanmaakt en gebruikt.  In totaal hebben we de volgende gegevens nodig:\nDe klasse Palette met members:\n unsigned short data[X] (komt uit tile generator)  De abstracte klasse BaseBGLayer met members:\n void scroll(int x, int y) int scrollX, scrollY unsigned short tileset[X] (komt uit tile generator) unsigned short tilemap[X] (komt uit tile generator) Palette palette unsigned short address  De concrete implementatie van de base klasse BGLayer0 met als juiste adres waarde, doorgegeven via de constructor parameter.\nDe klasse MemoryManager, met members:\n void save(BaseBGLayer bglayer) (bewaar data in GBA geheugen)  De klasse GBA, met members:\n MemoryManager manager void initialize() (maak nodige instanties aan en roep bewaar op) void run() (main game loop) void vblank()  De file main.cpp met een main() functie die de GBA klasse activeert.\nVergeet niet te denken aan:\n Accesss modifiers en getters/setters indien nodig. Pointers! Wel/niet/smart pointers/niet?  Labo oefeningen  Ontwerp een minimale standaard C++11 applicatie (zonder GBA) die bovenstaande modellen bevat en 1 achtergrondlaag \u0026lsquo;toont\u0026rsquo; (door in de main functie de juiste andere functies aan te spreken, die nog niets doen behalve een simpele cout). De focus ligt op het juiste OO ontwerp.De oefening is geslaagd als bovenstaande methodes zijn geïmplementeerd. Converteer bovenstaande standaard C++11 toepassing naar een GBA applicatie door cross-compile CMake flags te gebruiken. Baseer je op de CMakeLists.txt van het project. Gebruik voor de achtergrond deze tileset. Nu gaan we de namaak functies effectief implementeren. Haal de tileset door de png2gba tool die we kennen uit labo 8. Verzin je eigen tilemap. Laat de tilemap scrollen met het GBA keyboard (left, right: -x, +x, up, down: -y, +y). Scrollen wordt door de hardware ondersteund dus gaat héél snel: vertraging inbouwen kan door de CPU wat bezig te houden: for(int i = 0; i \u0026lt; 4567; i++){}.  Denkvragen  Scrollen gebeurt niet altijd. Kijk nog eens goed naar Soma als hij naar links beweegt richting de deur. Hoe kunnen we dit implementeren - gegeven een karakter in het midden van het scherm, wanneer starten we en wanneer stoppen we met scrollen? Op welke manier kan je de nadelen van het gedeelde achtergrondpalet minimaliseren?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/cpp/",
	"title": "3. Introductie in C++",
	"tags": [],
	"description": "",
	"content": " Introductie in C++ "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-cpp/labo-10/",
	"title": "Labo 10: Een introductie in GUI ontwerp met C++ in Qt",
	"tags": [],
	"description": "",
	"content": " UI Frameworks De C++ taal is een krachtige tool om native code te compileren voor specifieke CPU en OS systemen. Daardoor is het ook vaak een logische keuze om complexe interfaces in te ontwerpen en ontwikkelen, van Photoshop tot Google Chrome. Interfaces brengen echter weer andere problemen met zich mee: elk besturingssysteem heeft ondertussen zijn eigen interpretatie.\nDe Windows standaard was MFC die de WinAPI wrapt, voor OSX was dit de Carbon API. Ondertussen zijn beide frameworks vervangen door WPF (Ook in C#) en Cocoa (enkel in Objective-C). Voor Linux waren er 2 grote Window Managers: KDE en Gnome, die beiden hun eigen UI framework implementeerden: Qt en GTK.\nWe betreden nu het domein van \u0026ldquo;frameworks\u0026rdquo;: libraries die we samen met een programmeertaal gebruiken om sneller tot het gewenst resultaat te komen. Het zou nogal dom zijn om elke keer opnieuw een Button in de UI te moeten \u0026ldquo;uitvinden\u0026rdquo; - die zijn gewoon meegeleverd als predefined klasse in elk framework.\nWat is een Framework?\n a basic structure underlying a system, concept, or text.\n In ons geval een set van libraries waar we mee linken (met g++) zodat we #include \u0026lt;ui_component.h\u0026gt; in onze code kunnen gebruiken zonder die zelf te moeten maken. Dat brengt buiten een hoop componenten en includes, een aantal erg belangrijke nadelen met zich mee:\n Frameworks leggen vaak een stricte structuur op. Code moet op een bepaalde manier geschreven zijn, zoals voor Qt de Q_OBJECT macro in je klasse. Frameworks leven: ze ontstaan, groeien en gaan dood. Dat betekent dat wij als ontwikkelaar een doordachte keuze moeten maken, en na x jaar ons moeten aanpassen.  Qt en GTK zijn cross-platform UI frameworks: die kan je zowel op UNIX als op Windows compilen. Schrijf je je programma met behulp van Qt, dan zal (met minimale aanpassingen) het zowel voor UNIX als voor Windows kunnen compileren, en dan zal je doelpubliek vergroten. Qt werkt zelfs op iOS en Android - dus waarom ooit Android-specifieke Widgets leren?\nHet Qt ecosysteem Download Qt hier. Je zal merken dat 2gb aan HDD ruimte opgeslokt wordt: dat is erg veel voor een framework! Er zit echter een gigantische hoeveelheid aan bruikbare spullen in:\n Standaard UI componenten 2D en 3D rendering in OpenGL Een SQL object-mapper interface naar verschillende databases XML, JSON, \u0026hellip; support Mobile OS support Web specifieke componenten Netwerk integratie Een eigen concurrency model \u0026hellip;  Met als belangrijkste extra\u0026rsquo;s Qt Designer en Qt Creator, de grafische UI designer (zoals je SceneGraph kent van JavaFX) en een hele eigen IDE.\nEen minimale interface ontwerpen Er zijn zéér veel goede Qt tutorials te vinden, waaronder:\n De ingebouwde tutorials bij het opstarten van Qt Creator Qt.io: Qt for beginners Qt.io: Signal Slot syntax YouTube: Qt for beginners video series BogoToBogo Qt5 tutorials  De beste manier om te leren hoe Qt werkt is met experimentjes in de Creator.\nDe layout van een Qt applicatie In de main.cpp file zal je altijd dit vinden:\n#include \u0026#34;mainwindow.h\u0026#34;#include \u0026lt;QApplication\u0026gt; int main(int argc, char *argv[]) { QApplication a(argc, argv); MainWindow w; w.show(); return a.exec(); } Dit noemen we het bootstrappen van de Qt applicatie waarbij je een specifiek scherm aanmaakt en toont. a.exec() blokkeert de main thread totdat de UI stopt (bij het afsluiten van alle schermen bijvoorbeeld).\nMainWindow is een subklasse van QMainWindow:\nnamespace Ui { class MainWindow; } class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = nullptr); ~MainWindow(); private slots: void on_slider_sliderMoved(int position); private: Ui::MainWindow *ui; }; Merk hier framework-specifieke zaken op:\n De Q_OBJECT macro moet in elk Qt object aanwezig zijn dat signals en slots gebruikt. Een private reference naar\u0026hellip; jezelf? De Qt Designer genereert code! De forward reference is een reference naar een gegenereerde header file die je zelf nooit mag wijzigen. De private slots accessor bestaat natuurlijk niet in C++. Qt voorziet een aparte plek om slots te definiëren.  Qt genereert deze code voor jou - de destructor verwijdert de onderliggende ui pointer met delete.\nIn de source file include je beide headers:\n#include \u0026#34;mainwindow.h\u0026#34;#include \u0026#34;ui_mainwindow.h\u0026#34; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui-\u0026gt;setupUi(this); } De setupUi methode voegt de componenten toe aan het scherm die jij met de Qt Designer op het scherm gesleept hebt. Dankzij deze (ietwat vreemde) manier kan je overal in MainWindow met de ui-\u0026gt; pointer reference aan componten geraken. Merk op dat je dus géén definities van componenten in je eigen header terugziet, die leven allemaal in ui_mainwindow.h.\nSlots en Signals Een actie aan een knop hangen kan op twee manieren: in de Designer of manueel. In beide gevallen gebruik je Qt\u0026rsquo;s slots en signals. Een \u0026ldquo;Signal\u0026rdquo; is een bericht dat uitgestuurd wordt, waarop eender wie kan luisteren. Een \u0026ldquo;slot\u0026rdquo; definiëert de ruimte die gebruikt wordt om dat signaal op te vangen. Het concept is hetzelfde als het observer pattern.\nDe volgende code verbindt een progress bar valueChanged slot met een C++11 lambda callback als signal:\nconnect(ui-\u0026gt;progress, \u0026amp;QProgressBar::valueChanged, [](const int \u0026amp;newVal) { std::cout \u0026lt;\u0026lt; newVal \u0026lt;\u0026lt; std::endl; }); Dit kan je zelf in de constructor van je window toevoegen. connect geeft een QMetaObject::Connection object terug, zodat je dit kan disconnecten wanneer je zelf wilt.\nEen eenvoudigere manier om zaken met elkaar te verbinden is via de UI designer rechtermsuiknop op een element -\u0026gt; \u0026ldquo;Go to slot\u0026hellip;\u0026rdquo; en een voorstel selecteren. Op dat moment wordt de juiste slot code gegenereerd.\nVergeet Q_OBJECT niet als je gebruik maakt van slots en signals.\nQt\u0026rsquo;s objectenboom Elk UI object leidt af van QObject, net zoals in JavaFX. De Qt Inheritance Hierarchy is in de documentatie beschikbaar, waarvan voor ons de belangrijkste klassen bijvoorbeeld QTextEdit en QLabel zijn:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[QObject] B[QThread] C[QWidget] D[QFrame] E[QProgressBar] F[QLabel] G[QAbstractScrollArea] H[QTextEdit] I[QGraphicsView] J[QAbstractButton] K[QPushButton] L[QRadioButton] B -- A C -- A D -- C E -- C F -- D G -- D I -- G H -- G J -- C K -- J L -- J  Voor een eigen widget implementatie lijkt ons overerven van QWidget dus een goede keuze.\nEen kijkje achter de C++ extensions Waar dient die vreemde macro nu eigenlijk voor? Hoe werkt private slots:? Qt gebruikt een Meta-Object Compiler (MOC). Dit programma scant header files en genereert C++ source files met metadata die nodig is om onder andere:\n Slots en signals te laten werken (signal:) Dynamische properties te kunnen gebruiken (Q_PROPERTY) Run-time type informatie te kunnen lezen (Q_CLASSINFO)  Die gegenereerde source file moet ook meegecompileerd worden. Qt projecten worden meestal met QMake gecompileerd die de MOC automatisch afhandelt. Lees ook Why Does Qt Use Moc for Signals and Slots?\nQt komt met een eigen Makefile generator in de vorm van QMake in plaats van CMake dat centraal staat in CLion. Het is mogelijk om CLion Qt projecten te laten builden gegeven enkele wijzigingen in de CMakeLists.txt file om Qt libraries te linken. Het probleem is echter de gegenereerde source files door MOC. Dit zou ons echter te ver leiden.\nLabo oefeningen  Maak een programma dat de gebruiker 2 breuken laat ingeven in de vorm van 4 aparte textfields. Een knop \u0026ldquo;som\u0026rdquo; drukt het resultaat af in een output textfield. Valideer de input en geef een foutboodschap in de vorm van een QMessageBox indien een ongeldige waarde ingegeven. Als uitbreiding moet een tweede window openen die bereken knoppen bevat als een rekenmachine. Scherm 1: input fields, output. Scherm 2: knop \u0026ldquo;plus\u0026rdquo;, knop \u0026ldquo;maal\u0026rdquo;. Het tweede scherm kan men openen via een menu \u0026ldquo;Bestand -\u0026gt; Acites\u0026rdquo; in scherm 1.\n  Denkvragen  Beargumenteer waarom ik als software ontwikkelaar voor een UI framework als Qt zou kiezen in plaats van het native alternatief voor mijn ontwikkelplatform. Zijn hier ook nadelen aan verbonden? Hoe komt het dat ik connect() in de constructor van een QMainWindow klasse kan uitvoeren? Waar is deze methode gedefiniëerd?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-cpp/",
	"title": "4. GBA Programming in C++",
	"tags": [],
	"description": "",
	"content": " GBA Programming in C++ "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-cpp/labo-11/",
	"title": "Labo 11: een GBA spel porten naar Qt",
	"tags": [],
	"description": "",
	"content": " Eigen widgets implementeren De objectenboom uit labo 10 leert ons dat heel wat Qt objecten afleiden van QWidget. Dat is de ideale startplaats om zelf een widget te implementeren. Veel Qt objecten voorzien een override om het tekenen zelf af te kunnen handelen, vergelijkbaar met de while loop in een typisch gameboy spel.\nvoid paintEvent(QPaintEvent *event) override; In het Textrix Qt Voorbeeld wordt er gebruikt gemaakt van custom QFrame en QWidget implementaties die eigen objecten bijhouden die de tetris blokken voorstellen. Het tekenen van die blokken wordt aan de eigen code overgelaten. De QPainter klasse handelt het low-level tekenen af.\nDit voorbeeld, uit het voorbeeld genomen, tekent een tetris \u0026ldquo;shape\u0026rdquo; op het spelbord voor een gegeven painter instantie:\nvoid TetrixBoard::drawSquare(QPainter \u0026amp;painter, int x, int y, TetrixShape shape) { static const QRgb colorTable[8] = { 0x000000, 0xCC6666, 0x66CC66, 0x6666CC, 0xCCCC66, 0xCC66CC, 0x66CCCC, 0xDAAA00 }; QColor color = colorTable[int(shape)]; painter.fillRect(x + 1, y + 1, squareWidth() - 2, squareHeight() - 2, color); painter.setPen(color.light()); painter.drawLine(x, y + squareHeight() - 1, x, y); painter.drawLine(x, y, x + squareWidth() - 1, y); painter.setPen(color.dark()); painter.drawLine(x + 1, y + squareHeight() - 1, x + squareWidth() - 1, y + squareHeight() - 1); painter.drawLine(x + squareWidth() - 1, y + squareHeight() - 1, x + squareWidth() - 1, y + 1); } Dit is redelijk low-level: drawLine , setPen en fillRect verwachten coördinaten als input. In Qt is het ook mogelijk om met OpenGL te werken maar dat valt buiten deze cursus.\nGebruik maken van een abstractielaag Herinner je uit labo 7 en labo 8 het gebruik van een abstractielaag om de Gameboy Advance specifieke implementatie te verbergen in een tweede schil. Dit heeft als doel om makkelijk te kunnen switchen van front-end: als wij beslissen om onze GUI logica in Qt te schrijven, kunnen we de meeste logica, onze domein objecten, zonder meer overnemen! Dit bespaart ons véél moeite en duplicatie.\nEen schematische voorstelling van de context met als voorbeeld het Arkanoid spel uit labo 4:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; subgraph Arkanoid model A[Paddleposx, posy] B[Ballposx, posy] C[BreakableBlocksposx, posy] end subgraph Qt Frontend F[QtArkanoidGame] A -- F B -- F C -- F end subgraph GBA Frontend D[GBAArkanoidGame] A -- D B -- D C -- D end  Als alles perfect gescheiden is kan je de klassen aan de linkerkant van het schema volledig herbruiken. Dit betekent dat we géén specifieke GBA of Qt #include gebruiken en alle logica puur op de objecten zelf doen! Een potentiële collidesWith() zal dus op posx en posy checken en niet in OAM gaan kijken want dat bestaat niet in Qt. Omgekeerd zal het ook niet de QWidget of QFrame positie gebruiken want dat bestaat niet op de GBA.\nDit concept van stricte scheiding noemen we \u0026ldquo;separation of concerns\u0026rdquo; en is een veel gebruikt Design Pattern. In de industrie wordt logica vaak gesplitst om een HTML frontend of een Android of iOS frontend makkelijk te kunnen opbouwen. Op die manier heb je 3 applicaties waarvan de belangrijkste basis, het domein, hetzelfde blijft.\nMerk op dat dit eenvoudiger klinkt dan het in werkelijkheid er aan toe gaat: de gba-sprite-engine die jullie gaan gebruiken voor het project voorziet wel degelijk een scheiding van low-level en high-level GBA implementatie, maar géén stricte scheiding: in scenes gebruik je sprites (zie demo voorbeeld code, en die sprites hebben een OAM buffer. Die zijn dus ongeschikt om in Qt te kunnen werken. Waarom is dit hier niet gedaan? Omdat het natuurlijk nooit voorkomt dat iemand die een GBA spel ontwerpt dit wil porten naar Qt. Wanneer is dit wel van belang? Als iemand een Nintendo Switch spel maakt en het ook op Steam of in de Playstation Store wil publiceren.\nWerken met timers voor updates In ons GBA spel hebben we één centrale while(1) {} loop waar constant alles opnieuw getekend wordt. In Qt wordt de paint methode automatisch aangeroepen, maar daarvoor moeten natuurlijk wel nog variabelen van waarde veranderen. In het Tetrix voorbeeld wordt hiervoor een QBasicTimer instance gebruikt:\nQBasicTimer timer; timer.start(timeoutTime(), this); Om this te kunnen meegeven moet je een void timerEvent(QTimerEvent *event) implementatie voorzien waarin je je logica schrijft om bijvoorbeeld zwaartekracht te imiteren. Elk QObject heeft zo\u0026rsquo;n implementatie: het is dus zaak om je niet te vergissen en enkel je eigen timer specifieke dingen af te handelen:\nvoid TetrixBoard::timerEvent(QTimerEvent *event) { if (event-\u0026gt;timerId() == timer.timerId()) { // do stuff, evt timer restarten  } else { // parent timing  QFrame::timerEvent(event); } } Labo oefeningen  Teken in een eigen QWidget implementatie een eenvoudig mannetje met hulp van wat simpele rechthoeken. Laat dat mannetje naar links en rechts bewegen door keyboard events op te vangen. Herinner je vanuit labo 10 dat dit met slots en signals kan. Implementeer hiervoor void keyPressEvent(QKeyEvent *event); en luister naar event-\u0026gt;key(). Download gba-arkanoid, een C++ implementatie van de oefening uit labo 4. Dit CMake/CLion project is opgesplitst in 2 submappen: domain en gba. Het domein bevat methodes als collidesWith en updatePosition. De OAM GBA impelemntatie leeft in de gba submap. Port dit werkend minimalistisch spel naar Qt door de domein submap volledig intact te laten! De makkelijkste start is een nieuw project via Qt Creator waarbij je de domein code kopiëert.  Denkvragen  Beargumenteer waarom het principe van \u0026ldquo;separation of concerns\u0026rdquo; belangrijk kan zijn. Geef twee concrete voorbeelden waarom dit het geval is. Wanneer beslis je om code te kopiëren, en wanneer beslis je om code te herbruiken? Beschrijf twee situaties waarin je het ene of het andere zou handhaven.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/extra/",
	"title": "5. Extras",
	"tags": [],
	"description": "",
	"content": " Extras Zie Menu links!  FAQs, installatieinstructies, cheat sheets Voorbereidingen voor examen Informatie betreffende het project \u0026hellip;  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/extra/project/",
	"title": "Project opdracht",
	"tags": [],
	"description": "",
	"content": " Project opdracht academiejaar 2020 - 2021 Om jullie recent opgedane object-geörienteerde technieken te toetsen gaan jullie een GBA spel ontwerpen en ontwikkelen in C++11. De focus van de opdracht ligt niet op correcte low-level IO mapping maar op kritisch denken en testen zoals gezien in labo 7. Uiteraard komen zowel pointers en GBA programming technieken van de vroegere labo\u0026rsquo;s, als C++ class inheritance en abstractie lagen uit de latere labo\u0026rsquo;s aan bod.\nVertrek vanuit de gba-sprite-engine library op  Github door een  Fork te nemen met de knop rechtsboven. Op die manier bespaar je veel werk met een nieuw GBA project op te zetten en alle IO adressen opnieuw te mappen. Er is een README voorzien voor meer info. De engine gebruikt Tonc achterliggend.\nWat voor soort spel het moet zijn laat ik volledig aan jullie over. Het spreekt voor zich dat complexiteit (en originaliteit!) mee in rekening gebracht wordt: zie evaluatiecriteria. Inspiratie nodig?\n GBA Projecten vorige jaren videos Top 10 Gameboy Advance games in 10 minutes 25 Best Gameboy Advance games Ever  Werk in groepen van 2 of indien oneven 3.\nMinimumvereisten Lees dit goed na: projecten die niet voldoen aan de volgende vereisten zullen niet geëvalueerd worden.\n De code leeft in een repository op Github onder jullie username met de MIT license. Je vertrekt vanuit gba-sprite-engine - zie hierboven. Daarbij blijf je binnen GBA MODE0 en werk je met sprites. C++11 is hiermee ook een vereiste. Indien je je baseert op andere bestaande code doe je aan bronvermelding! Plagiaat wordt zeer ernstig bestraft. Je project moet uiteraard minstens compileren. Je repository README.md bevat een kleine functionele beschrijving van jullie spel. Naast de functionele beschrijving upload je ook een schets van je domein model, gepaard met verklarende tekst.  Het is niet de bedoeling om je te baseren op één van de engine demo\u0026rsquo;s en die simpelweg verder uit te werken. Dat biedt onvoldoende uitdaging en originaliteit.\nOmdat als vereiste elk project op Github leeft kunnen jullie elkaar\u0026rsquo;s repository, of die van vorig jaar, ook raadplegen. Of jullie daar gebruik van willen maken laat ik aan jullie over: onthoud sharing is caring en vergeet de bronvermelding niet. Het is geen race voor het beste waarbij je je code zorgvuldig moet afschermen: iedereen vertrekt vanuit dezelfde basis en iedereen kiest een ander soort spel. Als het onderwijsteam vermoedt dat er zonder nadenken een kopie genomen wordt van een bestaand spel zal dit resulteren in een onvoldoende.\nEvaluatiecriteria Punten worden op twee keer op /20 gegeven. Eenmalig een globaal cijfer, eenmalig een genormaliseerd cijfer, rekening houdend met de volgende subcriteria en gewichten:\n O.4 Design Hoe is je Object-Oriented design en domein model? Hoge score: duidelijk herkenbare objecten, terug te vinden in domein model, met gescheiden verantwoordelijkheden.Lage score: Alles in enkele objecten gestopt, onduidelijk wie wat doet, nauwelijks of geen model.  O.5 Clean Code Hoe leesbaar is je code? Hoge score: eenvoudig begrijpbare variabelen, methodes, klassen. Lage score: Te veel herlezen is nodig om te begrijpen wat er gebeurt. 0.4 Complexiteit  Hoe moeilijk heb je het gemaakt? Hoge score: gekozen voor een uitdaging in de plaats van een eenvoudige implementatie. Lage score: Het pad met de kleinste weerstand bewandeld, de lat te laag gelegd. 0.3 Originaliteit  Hoe origineel en creatief is je idee? Hoge score: een origineel idee uitgewerkt in plaats van een kloon van een standaard 2D platformer.Lage score: gekozen voor een weinig inspirerend ontwerp, alles gebaseerd op iets bestaand inclusief sprites.  0.2 GBA UI  Hoe uitgebreid is de multimedia presentatie? Hoge score: alle UI/geluid technieken uitgebreid toegepast: tiles, sprites, scrolling backgrounds, \u0026hellip;Lage score: Weinig tot geen animatie/backgrounds, eentonig ontwerp.   Waarbij beide cijfers herleid worden tot één. De tekst in het lichtgrijs dient ter ondersteuning bij het geven van een quotering op dat bepaald criterium, waar concrete voorbeelden met een lage en hoge score zijn uitgewerkt.\nInleverformaat Datum te bepalen, evenals verdedigingsdata.\n Je mailt je github repository URL door, samen met een gecompileerde .gba ROM die je zelf getest hebt. De gecompileerde ROM upload je ook naar Toledo. Er hangt ook een kleine verdediging aan vast zodat ik kan valideren of je voldoende kennis hebt over de code van je eigen spel. We spelen samen het spel en overlopen de code, waarbij er geantwoord wordt op enkele vragen die invloed uitoefenen op het globaal cijfer.  Praktische tips  Begin bij het begin: werk een concept uit op papier en teken dan een ruw model uit. Dit model is onderhevig aan verandering naargelang de ontwikkeling. Vergeet het finale model niet toe te voegen aan de README. Hou het simpel en werk gradueel iets complexer uit. Wees niet te overmoedig: een zeer goede implementatie scoort hoger dan een slappe complexe. Denk voor stukjes met logica eerst aan unit testen. Een test die slaagt helpt je al een heel eind verder. Test je spel tijdig op de mGBA emulator, of in de GBA zelf met een flashcard (uit te lenen bij de lesgever). Gebruik het voordeel van git: check in op regelmatige tijdstippen, zelfs meerdere keren per dag, wanneer iets werkt. Op die manier bespaar je jezelf een hoop werk als er iets teruggedraaid moet worden. Denk aan concepten die je geleerd hebt in andere programmeervakken, zoals Model-View-Controller (MVC) in \u0026ldquo;Software ontwerp in Java\u0026rdquo;. Separation of Concerns is ook in C++ van toepassing.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/hoorcolleges/slides-1/",
	"title": "1. Introductie in C/C++: context, ecosysteem",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/hoorcolleges/slides-2/",
	"title": "2. Pointers in C, dynamisch geheugen in C++",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/hoorcolleges/slides-3/",
	"title": "3. Introductie in Object-Georiënteerd denken in C++",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/hoorcolleges/slides-4/",
	"title": "4. Een introductie in GUI ontwerp met Qt, Samenvatting, examen info",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/extra/cheatsheet/",
	"title": "C Cheat Sheet",
	"tags": [],
	"description": "",
	"content": "Download hier: C Cheat Sheet\nAlternatief (non-hosted)\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/extra/buildsystems/",
	"title": "Een introductie in C(++) Build Systemen",
	"tags": [],
	"description": "",
	"content": " Zie ook labo 1: (herhaaldelijk) compileren\nEen greep uit de mogelijkheden, schematisch samengevat:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; compiler[compiler rechtstreeks uitvoeren] make[Makefiles roepen compiler aan] scons[SCons files roepen compiler aan] cmake[CMake files genereren Makefiles] qmake[QMake files genereren Makefiles] shell[Eigen script roept compiler aan] qmake -- make cmake -- make scons -- compiler make -- compiler shell -- compiler  Hoe compileer ik één file? We gebruiken de UNIX GNU gcc compiler om C soure files om te zetten in binaries. Het simpelste om iets te compileren is:\n g++ [bestand.cpp] -o [output.bin]\n Het programma uitvoeren doe je dan met ./output.bin. Normaal gezien kent het OS de execute flag automatisch toe, anders moet je nog chmod +x output.bin uitvoeren.\nDit kan je makkelijk automatiseren met een shell script door de compilatie en de executie in twee regels onder elkaar te plaatsen. De C(++) wereld voorziet echter flexibelere tools die dit voor je kunnen vergemakkelijken.\nHoe vergemakkelijk ik het compileren van één project? Gebruik daarvoor Makefile bestanden. Een Makefile is platte tekst die informatie bevat over je bronbestanden, libraries, binaries, \u0026hellip; zodat je met één enkel commando:\n make\n Een aantal instructies kan ontketenen. Een Makefile is opgesplitst in verschillende blokken. Elke blok bevat één keyword gevolgd door :, met op de volgende regels (voorafgaand met tab!) de uit te voeren instructies. Bijvoorbeeld:\n.DEFAULT_GOAL := all CC=gcc clean: rm -rf *.o rm -rf *.out compile: $(CC) -c main.c -o main.o link: $(CC) -o main.out main.o all: clean compile link Bovenstaande Makefile bevat de volgende blokken:\n clean compile link all  Merk op dat als géén blok als argument op make voorzien is, dat dan de \u0026ldquo;all\u0026rdquo; block uitgevoerd wordt (.DEFAULT_GOAL, eerste regel). Op die manier kan je met het commando make compile de compilatiestap uitvoeren, maar met make of make all een hele reeks aan stappen.\nMakefiles verzorgen dus het uitvoeren van de compilatie, zodat wij nooit meer rechtstreeks g++ of gcc moeten uitvoeren.\nDeze configuratiebestanden komen niet zonder nadelen:\n De syntax is erg cryptisch. Makefiles kunnen énorm groot, en dus verwarrend, worden.  Meer info over Makefiles.\nHoe vergemakkelijk ik het maken van een Makefile? Om tekortkomingen van de archaïsche Makefile bestanden goed te maken zijn er nieuwe tools ontwikkeld die Makefiles genereren. Er zijn twee grote varianten voorzien: CMake en QMake.\nA. Gebruik CMake CMake genereert Makefile bestanden door middel van CMakeLists.txt configuratie bestanden. Hierin beschrijf je je project, met een eenvoudigere syntax, waarna CMake het genereren van de Makefile uit handen neemt. Dit wil zeggen dat je nog steeds 2 stappen dient uit te voeren: het genereren, én het uiteindelijk uitvoeren van de Makefile zelf. Make blijft dus je comipler aanroepen!.\nEen typisch CMakeLists.txt bestand ziet er als volgt uit:\ncmake_minimum_required(VERSION 3.10) project(mijn_project) SET(CMAKE_CXX_STANDARD 11) add_executable(mijn_binary main.cpp bla.h bla.cpp) De volgende eigenschappen zijn beschreven:\n Welke compiler toolchain gebruik je? (C++ STD. 11 of hoger) Hoe heet je project? (mijn_project) Welke source en header files moeten gecompileerd worden? (main.cpp bla.h bla.cpp) Hoe heet je binary? (mijn_bindary)  Extra bestanden compileren is een kwestie van bestanden toe te voegen aan het lijstje.\nCMake is de standaard build tool in CLion. Je kan met CMake ook eenvoudig subprojecten maken, bijvoorbeeld een productie stukje in /src en een test stukje in /test. Download een CMake voorbeeld project met unittesten hier.\nMeer info over CMake files.\nB. Gebruik QMake Qt heeft zijn eigen Makefile generatie systeem dat QMake heet. Dit voornamelijk om de tussencompilatie stap te voorzien omdat Qt eigen keywords bij \u0026ldquo;verzonnen\u0026rdquo; heeft in de C++ standaard, zoals signals: en slots:. Omdat QMake deel is van een product is het nooit een goed idee om hier voor te kiezen als je geen Qt project gaat aanmaken. Uiteraard is QMake de standaard build tool in Qt Designer/Creator.\nQMake gebruikt projectfiles om de configuratie in op te slaan. Een voorbeeld projectfile (gegenereerd):\n#------------------------------------------------- # # Project created by QtCreator 2018-08-22T11:10:02 # #------------------------------------------------- QT += core gui widgets TARGET = qt-labo-11-player TEMPLATE = app # The following define makes your compiler emit warnings if you use # any feature of Qt which has been marked as deprecated (the exact warnings # depend on your compiler). Please consult the documentation of the # deprecated API in order to know how to port your code away from it. DEFINES += QT_DEPRECATED_WARNINGS # You can also make your code fail to compile if you use deprecated APIs. # In order to do so, uncomment the following line. # You can also select to disable deprecated APIs only up to a certain version of Qt. #DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0 CONFIG += c++11 SOURCES += \\ main.cpp \\ mainwindow.cpp \\ playercanvas.cpp HEADERS += \\ mainwindow.h \\ playercanvas.h FORMS += \\ mainwindow.ui # Default rules for deployment. qnx: target.path = /tmp/$${TARGET}/bin else: unix:!android: target.path = /opt/$${TARGET}/bin !isEmpty(target.path): INSTALLS += target Deze bestanden worden beheerd door de IDE, niet door jezelf. Dat betekent dat toevoegingen niet manueel dienen te gebeuren.\nMeer info over qmake project files.\nHoe vergemakkelijk ik het compileren zonder Makefiles? QMake en CMake bouwen nog steeds verder op het Makefile model. Er zijn echter buildsystemen die hier volledig los van staan, waarvan de populairste SCons is.\nA. Gebruik SCons In SCons beschrijf je je project met python! Er is gekozen voor een bestaande programmeertaal, in plaats van weeral een configuratie taaltje te verzinnen. Dit maakt SCons bijzonder flexibel: loopen over files in het systeem om ze te pipen naar een compiler, of een zipfile maken als distributiestap, zijn simpele zaken die met bovenstaande tools moeilijker te realiseren zijn.\nSCons verwacht één SConstruct bestand. Een voorbeeld SConstruct file:\nenv = Environment(CXX = \u0026#39;g++\u0026#39;) gtest = env.SConscript(\u0026#39;lib/gtest/SConscript\u0026#39;, \u0026#39;env\u0026#39;) src = env.SConscript(\u0026#39;src/SConscript\u0026#39;, \u0026#39;env\u0026#39;) out = env.SConscript(\u0026#39;test/SConscript\u0026#39;, \u0026#39;env gtest src\u0026#39;) # output is an array with path to built binaries. We only built one file - run it (includes gtest_main). test = Command( target = \u0026#34;testoutput\u0026#34;, source = str(out[0]), action = str(out[0]) ) AlwaysBuild(test) SCons vereist een python interpreter (en wat python kennis), en valt daarom buiten de scope van deze cursus. Voor de geïnteresseerden: lees ook SCons building in practice.\nMeer info over SCons.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/extra/faq/",
	"title": "FAQ",
	"tags": [],
	"description": "",
	"content": " Neem ook eens een kijkje bij de Installatieinstructies!\nMinGW installatie problemen Error RES Fout op Win omgevingen Zie ook https://sourceforge.net/p/mingw-w64/bugs/413/ - \u0026lsquo;oplossing\u0026rsquo; is een aantal keer hetzelfde bestand opnieuw te proberen downloaden \u0026amp; installeren. Antivirus die moeilijk doet kan ook een probleem zijn.\nProblemen met build omgevingen SH.exe was found in your path Fout:\n sh.exe was found in your PATH, here: C:/Program Files/Git/user/bin/sh.exe For MinGW make to work correctly sh.exe must NOT be in your path.  Oorzaak: je Cygwin /bin folder zit in de PATH omgevingsvariabele, terwijl je MinGW gebruikt als compilatieomgeving. Verwijder de Cygwin bin folder. Zie Installatieinstructies.\nCygheap base mismatch detected Fout:\n 2 [main] git 2004 C:/cygwin/lib/git-core/git.exe *** fatal error - cygheap base mismatch detected - 0x61242860/0x6123790. This problem is probably due to using incompatible versions of the cygwin DLL. Search fro cygwin1.dll using the WIndows Start-Find/Search facility and delete all bu the most recent version. The most recent version *should* reside in x:\\cygwin\\bin, where 'x' is the drive on which you have installed the cygwin distrubtion. Rebooting is also suggested if you are unable to find another cygwin DLL.  Oorzaak: je werkt met verschillende Cygwin-like omgevingen die niet compatibel zijn met elkaar. Bijvoorbeeld Cmder.exe en Cygwin, of CLion en Cmder en Cygwin, of zelfs WAMP Server. Elke omgeving komt met een eigen cygwin1.dll bestand.\nOplossingen:\n Een van de omgevingen deïnstalleren. Switch naar MinGW in plaats van Cygwin (zie Installatieinstructies). Zoek in de Verkenner naar de DLL en verwijder degene die niet gebruikt worden.  Het project builden Google Test Compile faalt op Mac Fout:\n Wouters-Air:build wgroeneveld$ make [ 25%] Building CXX object CMakeFiles/gtest.dir/src/gtest-all.cc.o In file included from /Users/jefklak/development/KUL/cpp/labo7/googletest/googletest/src/gtest-all.cc:38: In file included from /Users/jefklak/development/KUL/cpp/labo7/googletest/googletest/include/gtest/gtest.h:62: In file included from /Users/jefklak/development/KUL/cpp/labo7/googletest/googletest/include/gtest/internal/gtest-internal.h:40: /Users/jefklak/development/KUL/cpp/labo7/googletest/googletest/include/gtest/internal/gtest-port.h:825:12: error: no member named 'make_tuple' in namespace 'std' using std::make_tuple; ~~~~~^ /Users/jefklak/development/KUL/cpp/labo7/googletest/googletest/include/gtest/internal/gtest-port.h:826:12: error: no member named 'tuple' in namespace 'std' using std::tuple; ~~~~~^ ...  Oorzaak: Master branch van Google Test is recent overgeschakeld naar C++11. In hun CMakeLists.txt moet je dit toevoegen: set(CMAKE_CXX_STANDARD 17). Dan build dir verwijderen en opnieuw cmake voor make uitvoeren.\nZeer veel Google Test fouten bij het linken Fout:\n [100%] Linking CXX executable flyingstuff.elf cd /d C:\\Development\\github\\gba-sprite-engine\\cmake-build-debug\\demos\\demo1-basicfeatures \u0026\u0026 \"C:\\Program Files\\JetBrains\\CLion 2018.2.1\\bin\\cmake\\win\\bin\\cmake.exe\" -E cmake_link_script CMakeFiles\\flyingstuff.elf.dir\\link.txt --verbose=1 CMakeFiles/unittest.dir/gbatest.cpp.obj: In function `GBASuite_AssertionWorks_Test::TestBody()': C:/Development/github/gba-sprite-engine/test/gbatest.cpp:15: undefined reference to `testing::internal::GetBoolAssertionFailureMessage[abi:cxx11](testing::AssertionResult const\u0026, char const*, char const*, char const*)' CMakeFiles/unittest.dir/spritetest.cpp.obj: In function `SpriteSuite_CollidesWith_B_Right_Of_A_Does_Not_Collide_Test::TestBody()': C:/Development/github/gba-sprite-engine/test/spritetest.cpp:227: undefined reference to `testing::internal::GetBoolAssertionFailureMessage[abi:cxx11](testing::AssertionResult const\u0026, char const*, char const*, char const*)' CMakeFiles/unittest.dir/spritetest.cpp.obj: In function `SpriteSuite_CollidesWith_B_Half_In_A_On_X_Axis_Collides_Test::TestBody()': C:/Development/github/gba-sprite-engine/test/spritetest.cpp:234: undefined reference to `testing::internal::GetBoolAssertionFailureMessage[abi:cxx11](testing::AssertionResult const\u0026, char const*, char const*, char const*)' CMakeFiles/unittest.dir/spritetest.cpp.obj: In function `testing::AssertionResult testing::internal::CmpHelperEQFailure(char const*, char const*, int const\u0026, unsigned int const\u0026)': C:/Development/github/googletest/googletest/include/gtest/gtest.h:1435: undefined reference to `testing::internal::EqFailure(char const*, char const*, std::__cxx11::basic_string, std::allocator  const\u0026, std::__cxx11::basic_string, std::allocator  const\u0026, bool)' CMakeFiles/unittest.dir/scenetest.cpp.obj: In function `testing::AssertionResult testing::internal::CmpHelperEQFailure(char const*, char const*, int const\u0026, unsigned long long const\u0026)': C:/Development/github/googletest/googletest/include/gtest/gtest.h:1435: undefined reference to `testing::internal::EqFailure(char const*, char const*, std::__cxx11::basic_string, std::allocator  const\u0026, std::__cxx11::basic_string, std::allocator  const\u0026, bool)' CMakeFiles/unittest.dir/allocatortest.cpp.obj: In function `AllocatorSuite_Allocate_Sprite_Pointers_Reservers_Some_Tile_Space_Test::TestBody()': C:/Development/github/gba-sprite-engine/test/allocatortest.cpp:79: undefined reference to `testing::internal::GetBoolAssertionFailureMessage[abi:cxx11](testing::AssertionResult const\u0026, char const*, char const*, char const*)'  Oorzaak: je Google Test libraries zijn gecompileerd met een andere Toolchain dan waar je het project mee probeert te compileren! Cygwin VS MinGW problemen.\nOplossing: compileer Google Test opnieuw in dezelfde Toolchain - bijvoorbeeld in MinGW. Ga naar gooletest\\googletest\\build, verwijder alle bestaande bestanden met rm -rf * en volg opnieuw de Installatieinstructies.\nCMake was unable to find a build program corresponding to \u0026ldquo;Unix Makefiles\u0026rdquo; Bij uitvoeren CMake commando met het -G argument in Windows omgevingen.\nFout:\n C:\\Users\\x\\Documents\\3ABA\\C en C++\\les7\\googletest\\googletest\\buildcmake -G \"Unix Makefiles\" -DCMAKE_SH=\"CMAKE_SH-NOTFOUND\" ./../ CMake Warning at CMakeLists.txt:54 (project): VERSION keyword not followed by a value or was followed by a value that expanded to nothing. CMake Error: CMake was unable to find a build program corresponding to \"Unix Makefiles\". CMAKE_MAKE_PROGRAM is not set. You probably need to select a different build tool. CMake Error: CMAKE_CXX_COMPILER not set, after EnableLanguage CMake Error: CMAKE_C_COMPILER not set, after EnableLanguage -- Configuring incomplete, errors occurred! See also \"C:/Users/x/Documents/3ABA/C en C++/les7/googletest/googletest/build/CMakeFiles/CMakeOutput.log\".  Oorzaken:\n gcc compiler staat niet in %PATH%, of je voert dit niet uit vanuit de MinGW command prompt. make commando niet gevonden. In dat geval dien je make-mingw32.exe uit de MinGW install bin directory (bvb. C:\\Program Files\\mingw-64\\mingw64\\bin) te kopiëren (naar dezelfde dir) en te hernoemen naar make.exe.  Verwijder de build directory waar CMake files in genereerde, met eventuele CMakeCache.txt files, en voer cmake -G terug uit met de juiste argumenten.\nNo rule to make target ligbtest.a needed by test/unittest. Stop. Fout:\n mingw32-make.exe[2]: *** No rule to make target 'C:\\Development\\github\\googletest\\googletest/build/libgtest.a', needed by 'test/unittest'. Stop. mingw32-make.exe[1]: *** [CMakeFiles\\Makefile2:148: test/CMakeFiles/unittest.dir/all] Error 2 mingw32-make.exe[1]: *** Waiting for unfinished jobs.... mingw32-make.exe[2]: Entering directory 'C:/Development/github/gba-sprite-engine/cmake-build-debug' mingw32-make.exe[2]: Leaving directory 'C:/Development/github/gba-sprite-engine/cmake-build-debug' mingw32-make.exe: *** [Makefile:132: all] Error 2  Oorzaken:\n Je hebt Google Test nog niet gecompileerd Je GTEST_DIR omgevingsvariabele staat niet naar de juiste Google Test submap libgtest.a en libgtest_main.a zitten niet in de build subfolder van de Google Test map  Bij linken met Google Test: undefined reference to `pthread_setspecific\u0026rsquo; Fout:\n (.text._ZNK7testing8internal11ThreadLocalIPNS_31TestPartResultReporterInterfaceEE16GetOrCreateValueEv[_ZNK7testing8internal11ThreadLocalIPNS_31TestPartResultReporterInterfaceEE16GetOrCreateValueEv]+0x29): undefined reference to `pthread_getspecific' /usr/bin/ld: gtest-all.cc:(.text._ZNK7testing8internal11ThreadLocalIPNS_31TestPartResultReporterInterfaceEE16GetOrCreateValueEv[_ZNK7testing8internal11ThreadLocalIPNS_31TestPartResultReporterInterfaceEE16GetOrCreateValueEv]+0x8c): undefined reference to `pthread_setspecific' collect2: error: ld returned 1 exit status make[2]: *** [test/CMakeFiles/unittest.dir/build.make:314: test/unittest] Error 1 make[1]: *** [CMakeFiles/Makefile2:146: test/CMakeFiles/unittest.dir/all] Error 2  Komt enkel voor op Linux distributies zoals Ubuntu.\nSome Linux distributions seem to miss the default link to pthread that should be added manually in that case. When you see errors like \u0026ldquo;undefined reference to \u0026lsquo;pthread_setspecific\u0026rsquo;\u0026rdquo; while linking Google Test, change target_link_libraries in the CMakeLists.txt file of the subdir test to: target_link_libraries(unittest ${GTEST_LIBRARY}/build/libgtest.a ${GTEST_LIBRARY}/build/libgtest_main.a pthread).\nCMake: Check for working C++ compiler: broken Fout:\n C:\\Users\\11401165\\.CLion2018.2\\system\\cygwin_cmake\\bin\\cmake.exe -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_COMPILER=C:/devkitPro/devkitARM/bin/arm-none-eabi-gcc.exe -DCMAKE_CXX_COMPILER=C:/devkitPro/devkitARM/bin/arm-none-eabi-g++.exe -G \"CodeBlocks - Unix Makefiles\" /cygdrive/c/Users/11401165/Desktop/gba-sprite-engine-master/gba-sprite-engine-master -- The CXX compiler identification is GNU 8.1.0 -- Check for working CXX compiler: /cygdrive/c/devkitPro/devkitARM/bin/arm-none-eabi-g++.exe -- Check for working CXX compiler: /cygdrive/c/devkitPro/devkitARM/bin/arm-none-eabi-g++.exe -- broken CMake Error at /cygdrive/c/Users/11401165/.CLion2018.2/system/cygwin_cmake/share/cmake-3.12.2/Modules/CMakeTestCXXCompiler.cmake:45 (message): The C++ compiler \"/cygdrive/c/devkitPro/devkitARM/bin/arm-none-eabi-g++.exe\" is not able to compile a simple test program. It fails with the following output: Change Dir: /cygdrive/c/Users/11401165/Desktop/gba-sprite-engine-master/gba-sprite-engine-master/cmake-build-debug/CMakeFiles/CMakeTmp Run Build Command:\"/usr/bin/make.exe\" \"cmTC_a9bf5/fast\" /usr/bin/make -f CMakeFiles/cmTC_a9bf5.dir/build.make CMakeFiles/cmTC_a9bf5.dir/build make[1]: Entering directory '/cygdrive/c/Users/11401165/Desktop/gba-sprite-engine-master/gba-sprite-engine-master/cmake-build-debug/CMakeFiles/CMakeTmp' Building CXX object CMakeFiles/cmTC_a9bf5.dir/testCXXCompiler.cxx.obj /cygdrive/c/devkitPro/devkitARM/bin/arm-none-eabi-g++.exe -Wno-narrowing -std=gnu++11 -o CMakeFiles/cmTC_a9bf5.dir/testCXXCompiler.cxx.obj -c /cygdrive/c/Users/11401165/Desktop/gba-sprite-engine-master/gba-sprite-engine-master/cmake-build-debug/CMakeFiles/CMakeTmp/testCXXCompiler.cxx arm-none-eabi-g++.exe: error: /cygdrive/c/Users/11401165/Desktop/gba-sprite-engine-master/gba-sprite-engine-master/cmake-build-debug/CMakeFiles/CMakeTmp/testCXXCompiler.cxx: No such file or directory arm-none-eabi-g++.exe: fatal error: no input files compilation terminated. make[1]: *** [CMakeFiles/cmTC_a9bf5.dir/build.make:66: CMakeFiles/cmTC_a9bf5.dir/testCXXCompiler.cxx.obj] Error 1 make[1]: Leaving directory '/cygdrive/c/Users/11401165/Desktop/gba-sprite-engine-master/gba-sprite-engine-master/cmake-build-debug/CMakeFiles/CMakeTmp' make: *** [Makefile:121: cmTC_a9bf5/fast] Error 2  Het probleem is dat je Cygwin gebruikt op een Windows omgeving met een cross-compiler als arm-none-eabi-g++. De cross-compiler kan geen UNIX pad interpreteren, zoals /cygdrive/c/Users/11401165, maar wel C:\\Users\\11401165. Bijgevolg worden bestanden om te compileren niet gevonden.\nDe oplossing is switchen van De Cygwin naar de MinGW omgeving. Lees hier meer over in de installatieinstructies.\nCMake: The C++ compiler is not able to compile a simple test program Fout:\n -- The CXX compiler identification is GNU 8.1.0 -- Check for working CXX compiler: C:/Development/devkitpro/devkitARM/bin/arm-none-eabi-gcc.exe CMake Error: Generator: execution of make failed. Make command was: \"nmake\" \"/nologo\" \"cmTC_e5080\\fast\" The C++ Compiler \"C:/Development/devkitpro/devkitARM/bin/arm-none-eabi-gcc.exe\" is not able to compile a simple test program.  Herkenbaar aan: nmake keyword. Probleem? CMake wilt nmake gebruiken, de Visual Studio variant, niet make. Oplossing: start het commando met cmake ./../ -G \u0026quot;Unix Makefiles\u0026quot; of voeg SET(CMAKE_GENERATOR \u0026quot;Unix Makefiles\u0026quot;) toe aan je CMakeLists.txt.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/extra/installaties/",
	"title": "Installatieinstructies",
	"tags": [],
	"description": "",
	"content": " Onderstaande instructies gaan uit van Ubuntu als besturingssysteem. Windows of OSX is ook mogelijk, alle tools zijn platformonafhankelijk. Voor Windows installeer je MinGW 64 als compiler toolchain.\nBasisvereisten De volgende tools worden verwacht geïnstalleerd te worden via de package tool apt-get bij Ubuntu:\n build-essential als gcc/g++ build tools (preinstalled?) git  Optionele editors (VSCode, Subl) zijn ook via de package tool te installeren. sublime-text (vereist toevoegen van een repository).\nDe volgende tools worden verwacht gedownload te worden via git:\n Google Test (zie labo 7) gba-sprite-engine (zie opdracht)  De volgende tools worden verwacht manueel te downloaden:\n CLionVanaf CLion 2018.1 bevat deze reeds CMake 3.12.x.  CLion is gratis voor studenten: registreet je via de JetBrains Student pagina met je studenten e-mail adres om een licentiesleutel toegestuurd te krijgen.\ngcc Compiler installeren Voor Windows Download en installeer MinGW 64. Cygwin geeft problemen met UNIX paden en de cross compiler! In Cygwin stelt de windows dir C:\\Development\\github bijvoorbeeld /cygdrive/c/Development/github voor. Die forward slashes gecombineerd met de cygdrive prefix kan de GBA cross-compiler niet interpreteren.\n Dubbelklik op mingw-w64-install.exe Kies bij de installatie settings bij Architecture voor x86_64 Verander je destination folder naar believen  Start MinGW met de shortcut die geplaatst werd in je destination folder. Daarna kan je je installatie valideren met het commando gcc -v in de geopende terminal.\nOpgelet voor mensen die switchen van Cygwin naar MinGW: de bin folder van je Cygwin installatie mag niet toegevoegd zijn aan %PATH%. Je krijgt dan de volgende foutboodschap:\n sh.exe was found in your PATH, here: C:/Program Files/Git/user/bin/sh.exe For MinGW make to work correctly sh.exe must NOT be in your path.  Verwijder je oude Cygwin %PATH% variabele via start - \u0026ldquo;Omgevingsvariabelen voor uw account bewerken\u0026rdquo; - zoek \u0026ldquo;Path\u0026rdquo; in de lijst, klik op Bewerken - verwijder de referentie naar je Cygwin pad.\nMinGW integratie in CLion Ga naar bestand - settings - klik op \u0026ldquo;Build, Execution, Deployment\u0026rdquo; - klik op Toolchains:\nKies in de \u0026ldquo;Environment\u0026rdquo; dropdown voor \u0026ldquo;MinGW\u0026rdquo; en zet het pad juist naar je installatie folder van MinGW64. Merk op dat onder \u0026ldquo;C++ Compiler\u0026rdquo; Een foutboodschap kan verschijnen \u0026ldquo;For MinGW make to work correctly\u0026hellip;\u0026rdquo; - dit mag je negeren. De C en C++ compilers zelf mag je leeg laten en komen van de CMake instellingen.\nVanaf dan zal CLion bij het builden de MinGW omgeving gebruiken om CMake en Make uit te voeren.\nVoor Linux Geen speciale actie vereist, compiler built-in.\nVoor OSX Installeer de XCode toolchain via de Mac Appstore. Daarna kan je je installatie valideren met gcc -v.\nCMake installeren Opgelet Wij hebben CMake 3.12 of recenter nodig. Deze versie komt reeds bij CLion 2018.1 of later. Dat betekent dat als je een recente versie van CLion installeert, je CMake niet meer manueel hoeft te installeren! Sla onderstaande stappen dus over indien je CLion installatie recent genoeg is.\nCMake voor OSX Voor OSX via Homebrew: brew install cmake.\nCMake voor Ubuntu Ubuntu\u0026rsquo;s apt-get package manager heeft niet altijd de laatste versie van CMake in zijn repository - wij moeten 3.12 of hoger hebben. Als alternatief kan je op https://cmake.org/download/ de binaries downloaden (shellscript) en dit \u0026ldquo;ergens\u0026rdquo; installeren. Aangeraden is een $CMAKE_HOME omgevingsvariabele te maken en die toe te voegen aan je $PATH. In CLion kan je via CLion settings (File - Settings - Build, Execution, Deployment, Toolchains) een andere CMake executable kiezen.\nCMake voor Windows Voor Windows is er een installer voorzien. De 64-BIT installer is hier te downloaden: https://cmake.org/download/ - wij moeten 3.12 of hoger hebben. Aangeraden is een %CMAKE_HOME% omgevingsvariabele te maken.\n Kies tijdens de installatie wel voor \u0026ldquo;Add CMake to the system PATH for all users\u0026rdquo;. Verander je destination folder naar believen  Het kan zijn dat cmake niet voldoende is of je compilers niet kan vinden maar de VC++ versie probeert (nmake, cl). In dat geval cmake -G \u0026quot;Unix Makefiles\u0026quot; -DCMAKE_SH=\u0026quot;CMAKE_SH-NOTFOUND\u0026quot; als commando hanteren. Als er tijdens het compileren iets misloopt, controleer dan even in het gegenereerde CMakeCache.txt bestand of CMake de juiste compilers gevonden heeft.\nGoogle Test compileren Deze stappen zijn onafhankelijk van je gekozen besturingssysteem, zodra je de basis gcc toolchain én CMake gecompileerd hebt.\nVolg de volgende stappen nadat je de release 1.10.x downloadde via https://github.com/google/googletest\n Download en compileer googletest:  cd googletest/googletest (opgelet dus NIET de root, we moeten googlemock niet hebben) Maak een build directory: mkdir build in de map googletest Build cmake: cd build \u0026amp;\u0026amp; cmake ./../. Vergeet niet op Windows de -G optie mee te geven (zie boven) Build google test: make. Dit geeft libgtest.a en libgtest_main.a\n  Integreer googletest in je CLion project met CMake:  Include de gtest headers met include_directories() Link de libraries met target_link_libraries() Voorzie een omgevingsvariabele GTEST_DIR.   DevkitPro installeren De \u0026ldquo;DevkitPro\u0026rdquo; toolchain installeren levert je een aantal cross-compilers en linkers op die een C source file omzetten ine en GBA binary. Zie installatie instructies per OS. Via de meegeleverde package manager pacman kan je op OSX de package gba-dev installeren.\nWindows specifiek Voor Windows is er een installer voorzien. Vink enkel als \u0026ldquo;components to install\u0026rdquo; GBA development aan. Er is 300MB voor nodig omdat er weer een virtuele omgeving voor bij komt (msys).\nVergeet geen omgevingsvariabele %DEVKITPATH% aan te maken en deze toe te voegen aan je %PATH%; zie verder.\nUbuntu specifieke installatie Voor Ubuntu moet je eerst de devkitpro-pacman .deb file installeren die je hier op Github kan vinden. Het pacman commando is dan het dkp-pacman commando om verwarring met apt te vermijden. Installeer alle gba dev tools met sudo dkp-pacman -S gba-dev. De compilers zijn dan geïnstalleerd in /opt/devkitpro/devkitARM/bin dus voeg die folder toe aan je $PATH.\nWijzigingen in het Bash profiel In je .bashrc bestand in de home folder ~ voeg je het volgende toe:\n export DEVKITPATH=\"/opt/devkitpro/devkitARM/bin\" export CMAKE_HOME=\"/opt/cmake-3.12.1-Linux-x86_64\" export GTEST_DIR=\"/home/wouter/Development/googletest/googletest\" PATH=\"$DEVKITPATH:$CMAKE_HOME/bin:$PATH\"  Bovenstaande variabelen worden onder andere verwacht aanwezig te zijn op systeem niveau in de gba sprite engine. Voor windows pas je dit aan in het \u0026ldquo;System Configuration\u0026rdquo; scherm en klik je op \u0026ldquo;Environment Variables\u0026rdquo; om wijzigingen door te voeren (admin rechten vereist).\nBegeleidende filmpjes Onderstaande filmpjes verduidelijken de installatieinstructies voor Windows 10 gebruikers.\nDe gba-sprite-engine compileren op Win10:\n  Bovenstaande instructies raken ook kort MinGW en CMake aan.\nDe google-test library compileren op Win10:\n  Vergeet niet dat in Windows $PATH gelijk gesteld is aan %PATH%!\nLukt het nog steeds niet? Controleer dan de FAQs.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/c/labo-1/",
	"title": "Labo 1: Introductie in C",
	"tags": [],
	"description": "",
	"content": " De C programmeertaal De C taal is een programmeertaal in de jaren \u0026lsquo;70 ontwikkeld om makkelijk hardware te kunnen aanspreken. C was/is in essentie niet veel meer dan een kleine abstractielaag bovenop assembly.\nC is een imperatieve programmeertaal. Dat zal je bij het oefenen wel merken: we schrijven instructies als statements. Deze regels of statements zijn gestructureerd in functies en struct types. Het jammere hier aan is dat er weinig declarativiteit aan de pas komt. Omdat C zo weinig om het lijf heeft (low-level), drukken statements bijna altijd uit hoe iets moet werken, in plaats van wat het moet doen.\nToch is clean code voor mij van levensbelang en gaan we ook in C ons focussen op leesbaarheid. In plaats van getallen in de code gebruiken we #define, in plaats van lange statements splitsen we logische blokken op in duidelijke function blokken.\nC wordt voornamelijk gebruikt in embedded system development, net omdat het zo kort bij de hardware staat. De UNIX, Windows en OSX kernels zijn volledig geschreven in C bijvoorbeeld. Het besturingssysteem van je GSM, smartwatch of (handheld) gaming systeem bouwt verder op C. Enorm veel talen zoals Java (JVM), Python, Ruby en PHP zijn geschreven in C.\nWat is C++ dan? Zoals we zullen zien, bevat C weinig mogelijkheden om declaratief te zijn. C++ is de objectenlaag bovenop C die de taal uitbreidt met \u0026lsquo;moderne\u0026rsquo; mogelijkheden tot structureren: inheritance, templating, eenvoudigere libraries (STL), \u0026hellip; De C++ compiler gebruikt gewoon C met laagjes C++ \u0026ldquo;sugar\u0026rdquo;, zoals de ANSI C++ Standard aangeeft.\nDe C taal is compact, de C++ taal is dat helaas niet. Kijk zelf maar:\nIk neem aan dat ze met \u0026lsquo;++\u0026rsquo; het aantal pagina\u0026rsquo;s in handboeken bedoelden. Vergeet niet dat bovenstaande handleiding nog maar een \u0026ldquo;primer\u0026rdquo; is.\nVergelijkingen met Java import java.io.IOException; import java.nio.*; class FileReader { @Override public String read(String file) throws IOException { return new String(Files.readAllBytes(Paths.get(file))); } } class Main { public static void main(String[] args) { System.out.println(\u0026#34;reading file: \u0026#34;); System.out.println(new FileReader().read(\u0026#34;sup.txt\u0026#34;)); } } Hoe zouden we zoiets in C doen? Dat wordt moeilijk. C heeft geen class systeem! De low-level C implementatie is als volgt:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; char* read(char* file) { FILE *filePointer = fopen(file, \u0026#34;r\u0026#34;); char *buffer = malloc(255); fgets(buffer, 255, (FILE*) filePointer); fclose(filePointer); return buffer; } int main() { printf(\u0026#34;reading file: \\n\u0026#34;); printf(\u0026#34;%s\\n\u0026#34;, read(\u0026#34;sup.txt\u0026#34;)); return 0; } Compileren met gcc -o fileio fileio.c.\nHier zijn nog veel dingen mee mis: de buffer lengte is hardcoded en het geheugen wordt niet vrijgegeven. Een FileReader klasse kan gewoon niet aangemaakt kan worden. Zoals je kan zien is dit véél meer low-level werk dan een simpele Java one-liner als Files.readAllBytes!\nMet de STL library in C++ gaat het iets beter:\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;fstream\u0026gt;#include \u0026lt;string\u0026gt; using namespace std; class FileReader { public: string readFile(const char* file); }; string FileReader::readFile(const char* file) { ifstream inFile(\u0026#34;sup.txt\u0026#34;, ios::in | ios::binary); return (string((istreambuf_iterator\u0026lt;char\u0026gt;(inFile)), istreambuf_iterator\u0026lt;char\u0026gt;())); } int main() { auto reader = new FileReader(); cout \u0026lt;\u0026lt; \u0026#34;reading file:\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; reader-\u0026gt;readFile(\u0026#34;sup.txt\u0026#34;); }  Compileren met g++ -std=c++11 -o fileio fileio.cpp.\nC++ streams verbergen de low-level details van C File IO maar achterliggend gebeurt natuurlijk hetzelfde. Zoals je kan zien voorziet C++ ook class, publicen new keywords die Java programmeurs wel kennen. Zelfs autoin C++ 11 is de varin C# die Java mist.\nDe essentiële verschillen tussen C en een hogere taal zoals Java of C#:\n C heeft weinig om het lijf: geen private/protected/class/interface/inheritance/bool/string\u0026hellip; Er zijn geen \u0026ldquo;standard\u0026rdquo; libraries. C heeft geen exceptions! Het werkt met interrupts en error codes (return 0). C heeft geen garbage collection: geheugen beheer jij zelf. C draait niet op een virtuele machine (JVM, CLR) maar wordt gecompileerd naar native machine code. C maakt intensief gebruik van pointer variabelen om geheugen direct te manipuleren. C staat toe om combinatie-integer-types te maken (unsigned short int) C/C++ werkt met headers (.h) en source (.c/cpp) files. Een uitvoerbaar bestand vereist twee stappen: compileren én linken. Met linken kan je eenvoudig assembly en C mixen.  Basis C Hello World #include \u0026lt;stdio.h\u0026gt; int main() { int getalleke = 42; printf(\u0026#34;sup wereld? %d\u0026#34;, getalleke); return 0; } De hoofd functie, main(), geeft een getal terug dat aangeeft aan het systeem of je programma met succes uitgevoerd is (0), of een andere error code wenst terug te geven. printf is een functie in de standaard IO header die we moeten includen, zoals een import in Java.\nDe \u0026ldquo;f\u0026rdquo; van printf staat voor \u0026ldquo;formatting\u0026rdquo; zoals je hierboven kan zien. Zie Formatted output.\nStructuur aanbrengen Doe je met function. Blocks zoals if, for, while, do zijn bekend en werken op dezelfde manier als in Java:\n#include \u0026lt;stdio.h\u0026gt; void zeg_iets_als_dit_positief_is(int getalleke) { if(getalleke \u0026gt; 5) { printf(\u0026#34;wow, positief ofwa? \\n\u0026#34;); for(int i = 1; i \u0026lt;= getalleke; i++) { printf(\u0026#34;%d \u0026#34;, i); } printf(\u0026#34;\\n\u0026#34;); } } int main() { zeg_iets_als_dit_positief_is(5); return 0; } Functies kan je niet overloaden in C - in C++ en Java wel. Er kunnen geen twee functies met naam \u0026ldquo;main\u0026rdquo; of \u0026ldquo;zeg_iets_als_dit_positief_is\u0026rdquo; maar met andere parameters bestaan.\nStrings? Hoezo? Vergeet het maar: char[] of een char* pointer is de enige mogelijkheid. std::string zien we later als deel van C++ STL. Een array in Java is een object waar je de lengte van kan opvragen. Handig toch. Ook niet mogelijk in C\u0026hellip;\n#include \u0026lt;stdio.h\u0026gt;#define GROOTTE 10  int main() { int arr[GROOTTE]; for(int i = 0; i \u0026lt; GROOTTE; i++) { arr[i] = i * 10; } for(int j = 0; j \u0026lt; GROOTTE; j++) { printf(\u0026#34;array index %d heeft waarde %d \\n\u0026#34;, j, arr[j]); } char string[] = \u0026#34;heykes cava\u0026#34;; printf(\u0026#34;%s\u0026#34;, string); return 0; } C voorziet de juiste hoeveelheid geheugen bij \u0026ldquo;string literals\u0026rdquo; die we kennen vanuit Java. De string[] char array bevat 12 tekens en geen 11! Omdat we het einde van de array niet kennen wordt er altijd de NULL terminator toegevoegd, \\0. Zo kan je loopen en per char afdrukken - of printf het laten doen met %s.\nIn \u0026lt;string.h\u0026gt; zitten een aantal handige functies om strings te kopiëren, de lengte op te vragen of te concateneren. Dat kan je in GNU C: String utils terugvinden.\nStructs De enige manier om in C data te structureren is met het struct keyword:\nstruct Persoon { int leeftijd; int geslacht; // geen bool, remember?  char naam[]; }; We kunnen deze structuur gebruiken door aan de members waarden toe te kennen:\nstruct Persoon jaak; // vergeet \u0026#34;struct\u0026#34; niet jaak.naam = \u0026#34;Jaak Trekhaak\u0026#34;; jaak.leeftijd = 80; jaak.geslacht = 1; Uiteraard kan je structs ook doorgeven in functies en dan members aanspreken met de puntnotatie.\nDe vraag is dan, kunnen we ook functies definiëren in een struct? Ja en neen. Een functie pointer (zie labo 2) maakt dit wel mogelijk, maar het is niet zoals een C++ member variabele van een klasse. C functie pointers worden gebruikt als callback methods:\n#include \u0026lt;stdio.h\u0026gt; struct Persoon { int leeftijd; int (*is_oud)(); }; int is_oud(struct Persoon this) { printf(\u0026#34;checking leeftijd van persoon: %d\\n\u0026#34;, this.leeftijd); return this.leeftijd \u0026gt; 60; } int main() { struct Persoon jaak; jaak.leeftijd = 40; jaak.is_oud = is_oud; printf(\u0026#34;is jaak oud? %d\\n\u0026#34;, jaak.is_oud(jaak)); } Het toekennen van is_oud aan is_oud is heel gek natuurlijk. Dit is dan ook het emuleren van iets dat ontbreekt in een taal. Met pointers in labo 2 komen we hier nog op terug.\nExtra definities Die struct voor de Persoon jaak is een beetje vreemd en kan je wegwerken met een eigen typedef. Op die manier kan je ook het keyword string in andere talen emuleren, door er een char array of pointer van te maken:\ntypedef struct Persoon Persoon; typedef char* string; Magische getallen worden best ook als constante gedefiniëerd bovenaan (liefst in header files) met #define. Met wat gefoefel en combinaties kunnen we zo een bool emuleren in C:\n#define TRUE 1 #define FALSE 0  typedef unsigned short int bool; bool mannelijk = TRUE; Typische C code die je kan tegenkomen wegens gebrek aan een bool: if(result) { ... } waarbij result een int is. Dit is in geen geval hetzelfde als JavaScripts Truthy/Falsey constructie! Het getal 0 is false. EOF, NULL of \\0 evalueren allemaal naar een getal om dit te kunnen gebruiken.\nGebruik van header Files De #include statements zorgen voor de juiste inclusies van functies in je programma. Grote programma\u0026rsquo;s bestaan uit meerdere C (source) en H (header) files die met compileren en linken aan elkaar geplakt worden. In een header file zitten functie definities, de declaraties zitten in de source files:\n// persoon.h struct Persoon { int leeftijd; }; int is_oud(struct Persoon p); Met als bron:\n// persoon.c #include \u0026lt;stdio.h\u0026gt; #include \u0026#34;persoon.h\u0026#34; int is_oud(struct Persoon p) { return p.leeftijd \u0026gt; 60; } int main() { struct Persoon jaak; jaak.leeftijd = 10; return 0; } De main functie werkt als bootstrapper en wordt nooit in een header file geplaatst. Merk het verschil tussen brackets en haakjes op bij include: dat is het verschil tussen systeem includes en eigen includes (relatief pad gebruiken!).\nDe reden om dit zo op te splitsen is andere source files ook toegang te verschaffen tot is_oud() en Persoon en zo dingen te herbruiken.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A{persoon.h} --|source| B[persoon.c] B -- E[definitie is_oud] A{persoon.h} --|source| C[facebook.c] C -- F[gebruik struct] A{persoon.h} --|source| D[twitter.c] D -- G[gebruik struct]  Scheiding van goederen: functies in aparte C files Om de opsplitsing duidelijker te maken stellen we de volgende C code op, gesplitst in verschillende bestanden:\n// hallo.c char* hallo() { return \u0026#34;heykes\u0026#34;; } // main.c #include \u0026lt;printf.h\u0026gt;int main() { printf(\u0026#34;%s\u0026#34;, hallo()); return 0; } De main functie heeft eigenlijk geen weet van hallo() omdat die in een andere source file leeft. Dit komt goed als we de machine code samen linken, na het compileren. main.c apart compileren geeft dit:\n Wouters-MacBook-Air:cmake-build-debug wgroenev$ gcc -c main.c main.c:5:18: warning: implicit declaration of function 'hallo' is invalid in C99 [-Wimplicit-function-declaration] printf(\"%s\", hallo()); ^ 1 warning generated.  Merk de -c flag op (compile only). Makkelijk opgelost met een forward functie declaratie voor int main: char* hallo();. Dit is het cruciaal verschil tussen declaratie en definitie. De problemen zijn echter nog niet opgelost als we dit willen linken zonder hallo.c:\n Wouters-MacBook-Air:cmake-build-debug wgroenev$ gcc main.o Undefined symbols for architecture x86_64: \"_hallo\", referenced from: _main in main.o ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation)  We hebben de binaries van hallo.o ook nodig om tot een succesvol werkend programma te komen. Daarvoor moeten we dus eerst nog gcc -c hallo.c en dan gcc main.o hallo.o -o hey uitvoeren.\nMet het UNIX tooltje nm kunnen we de adressen bekijken die de linker nodig heeft om tot de hey executable te komen. Probeer eens hallo.o te openen met een tekstverwerker. Je ziet dan dit:\n cffa edfe 0700 0001 0300 0000 0100 0000 0300 0000 f001 0000 0020 0000 0000 0000 1900 0000 8801 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 7800 0000 0000 0000 1002 0000 0000 0000 7800 0000 0000 0000 0700 0000 0700 0000 0400 0000 0000 0000 5f5f 7465 7874 0000 0000 0000 0000 0000 5f5f 5445 5854 0000 0000 0000 0000 0000 0000 0000 0000 0000 0d00 0000 0000 0000 1002 0000 0400 0000 8802 0000 0100 0000 0004 0080 0000 0000 0000 0000 0000 0000 5f5f 6373 7472 696e 6700 0000 0000 0000 5f5f 5445 5854 0000 0000 0000 0000 0000 0d00 0000 0000 0000 0700 0000 0000 0000 1d02 0000 0000 0000 0000 0000 0000 0000 0200 0000 0000 0000 0000 0000 0000 0000 5f5f 636f 6d70 6163 745f 756e 7769 6e64 5f5f 4c44 0000 0000 0000 0000 0000 0000 1800 0000 0000 0000 2000 0000 0000 0000 2802 0000 0300 0000 9002 0000 0100 0000 0000 0002 0000 0000 0000 0000 0000 0000 5f5f 6568 5f66 7261 6d65 0000 0000 0000 5f5f 5445 5854 0000 0000 0000 0000 0000 3800 0000 0000 0000 4000 0000 0000 0000 4802 0000 0300 0000 0000 0000 0000 0000 0b00 0068 0000 0000 0000 0000 0000 0000 0200 0000 1800 0000 9802 0000 0400 0000 d802 0000 2400 0000 0b00 0000 5000 0000 0000 0000 0200 0000 0200 0000 0200 0000 0400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 5548 89e5 488d 0500 0000 005d c368 6579 6b65 7300 0000 0000 0000 0000 0000 0000 0d00 0000 0000 0001 0000 0000 0000 0000 0000 0000 0000 0000 1400 0000 0000 0000 017a 5200 0178 1001 100c 0708 9001 0000 2400 0000 1c00 0000 a8ff ffff ffff ffff 0d00 0000 0000 0000 0041 0e10 8602 430d 0600 0000 0000 0000 0700 0000 0000 001d 0000 0000 0100 0006 1200 0000 0e02 0000 0d00 0000 0000 0000 1900 0000 0e04 0000 3800 0000 0000 0000 0100 0000 0f01 0000 0000 0000 0000 0000 0800 0000 0f04 0000 5000 0000 0000 0000 005f 6861 6c6c 6f00 5f68 616c 6c6f 2e65 6800 4c5f 2e73 7472 0045 485f 6672 616d 6530 0000  Prachtig, maar niet erg duidelijk. nm helpt:\n heykesWouters-MacBook-Air:cmake-build-debug wgroenev$ nm hallo.o 0000000000000038 s EH_frame0 000000000000000d s L_.str 0000000000000000 T _hallo 0000000000000050 S _hallo.eh Wouters-MacBook-Air:cmake-build-debug wgroenev$ nm main.o 0000000000000060 s EH_frame0 0000000000000037 s L_.str U _hallo 0000000000000000 T _main 0000000000000078 S _main.eh U _printf  Je ziet zo dat in main.o de functie _hallo een onbekend adres krijgt toegewezen (vandaar de U). Dit betekent dat de linker er maar van uit moet gaan dat die nog moet komen - en gelukkig genoeg staat die wel correct gedefiniëerd in hallo.o op adres 0000000000000000 (er is maar 1 functie).\nDe bestanden worden zo aan elkaar gekoppeld:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD A[hallo.c] B[main.c] Challo.o] Dmain.o] E{hey executable} E -- C E --|\"zoek main() via linker\"|D C -- A D -- B D -.-|\"zoek hallo() via linker\"|C  Functies die in andere source files gedeclareerd zijn moet je dus herdefiniëren (eventueel met het extern keyword) in je eigen source file waar je de functie wenst te gebruiken. Zo weet de compiler dat een functie met die signatuur bestaat, maar \u0026ldquo;zal hij deze nog wel tegenkomen\u0026rdquo;. Hier gaan we nog op verder in labo 6.\nDe boel compileren We gebruiken de UNIX GNU gcc compiler om C soure files om te zetten in binaries. Het simpelste om iets te compileren is:\n gcc *.c\n Door het gebrek aan een doelbestandsnaam maakt de compiler een bestand \u0026ldquo;a.out\u0026rdquo; dat je kan uitvoeren. Met de \u0026ldquo;-o\u0026rdquo; flag kan je dit specifiëren. Heb je iets meer te linken, zet dan alles in een rijtje achter elkaar.\nEr zijn echter nog veel compiler opties die hier staan, waar je eens mee kan spelen.\nWat is het verschil tussen GNU GCC en Clang en VS Cl? De C programmeertaal is door verschillende bedrijven en personen geïmplementeerd: er bestaan dus verschillende compilers op verschillende besturingssystemen, die allemaal een .c file omzetten in native binaries voor dat systeem. In een poging om compilers te standardiseren, werd er de ANSI C standaard uitgerold, die beschrijft wat een C compiler moet kunnen en wat niet.\nDe bekendste C compilers zijn de GNU GCC compiler (GNU Compiler Collection) en Clang die de LLVM infrastructuur gebruikt. gcc --version geeft op mijn MacBook Air het volgende terug:\n Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/usr/include/c++/4.2.1 Apple LLVM version 6.0 (clang-600.0.56) (based on LLVM 3.5svn) Target: x86_64-apple-darwin15.6.0 Thread model: posix  Dit verraadt dat mijn gcc commando niet de GCC, maar de Clang implementatie gebruikt. Dat heeft wel degelijk een grote impact op het compileren én uitvoeren van code. Probeer het volgende eens te compileren in GNU gcc:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt;char* test(char hey[]) { char heykes[strlen(hey)]; strcpy(heykes, hey); return heykes; } int main() { printf(\u0026#34;%s\u0026#34;, test(\u0026#34;hoi hoe ist?\u0026#34;)); } De fout zit in test(), je kan geen lokale variabele als pointer teruggeven, tenzij je die op de heap zet met malloc(). De output zal (null) (niets) zijn. In Clang is de output �@Ht� (ongeldige karakters uit het geheugen). Dat lijkt een klein verschil, maar kan grote gevolgen hebben.\nWij beperken ons tijdens de lessen tot de GNU gcc compiler, zowel op Windows via MinGW, als op Linux. Nieuwsgierigen kunnen op https://godbolt.org/ de disassembly inspecteren van verschillende compilers om zo de nuanceverschillen te ontdekken.\nHerhaaldelijk compileren Met een scriptje Het is vervelend om de hele tijd hetzelfde commando te moeten typen, dus een simpel alternatief is je gcc commando in een shell script steken:\n#!/bin/sh clear \u0026amp;\u0026amp; gcc -o mijnding source.c \u0026amp;\u0026amp; ./mijnding Met Makefiles In de C/C++ wereld bestaat er zoiets als een Makefile dat definiëert welke source files gecompileerd moeten worden, en in welke volgorde. Dit is handig voor grote applicaties waarbij een overzicht moet bewaard worden.\nMet Makefiles kan je \u0026ldquo;targets\u0026rdquo; beschrijven die voor jou bepaalde acties uitvoeren. Bijvoorbeeld het opkuisen van binaries, het compileren en het linken, allemaal als aparte stap. Stappen aan elkaar rijgen gaat natuurlijk ook.\n.DEFAULT_GOAL := all CC=gcc clean: rm -rf *.o rm -rf *.out compile: $(CC) -c main.c -o main.o link: $(CC) -o main.out main.o all: clean compile link Typisch wordt de gebruikte compiler als shell variabele gezet (CC=gcc). Je ziet hier dat compileren (gcc met de -c optie linkt niet) en linken opgesplitst is. Dat is in onze oefeningen eigenlijk niet nodig, maar laat hier de organisatorische kracht van Make zien.\nUitvoeren met make als default goal (all) of make compile voor een specifieke goal.\nVoor meer uitleg over Makefile syntax, zie GNU make.\nHerhaaldelijk compileren IDEs Lichtgewichten Een source file bestaat uit platte tekst. Eender welke text editor is voldoende om je C programma te kunnen schrijven. Het kan echter handig zijn om Sublime Text of Visual Studio Code te gebruiken. Deze moderne krachtige editors hebben auto-completion en build tools ingebouwd.\n Sublime Text 3 Build Systems en C/C++ en docs Visual Studio Code C/C++ integratie  Ik houd old-school fans niet tegen om Emacs of Vim te gebruiken.\nZwaargewichten CLion is de perfecte cross-platform en cross-compiler kandidaat om het zware C/C++ ontwikkelwerk van je over te nemen met geïntegreerde debugging, stack inspectie en alles wat men van een IDE verwacht. Dit is gebouwd bovenop IDEA en dus exact hetzelfde als IntelliJ voor Java - inclusief de shortcuts.\nCLion is niet gratis maar voor studenten wel en erg aan te raden. CLion werkt met CMake: CMakeLists.txt bevat instructies om een Makefile te genereren:\n cmake_minimum_required(VERSION 3.10) project(testje) set(CMAKE_CXX_STANDARD 11) add_executable(testje main.cpp biblio.cpp biblio.h dieren.cpp dieren.h)  Een simpel CMake bestand is véél eenvoudiger dan een Make bestand. Zie CMake tutorial. CLion beheert de add_executable voor jou: nieuwe files toevoegen aan je project komen er automatisch in terecht.\nCMake voor Ubuntu Ubuntu\u0026rsquo;s apt-get package manager heeft niet altijd de laatste versie van CMake in zijn repository. Als alternatief kan je op https://cmake.org/download/ de binaries downloaden (shellscript) en dit \u0026ldquo;ergens\u0026rdquo; installeren. Aangeraden is een $CMAKE_HOME omgevingsvariabele te maken en die toe te voegen aan je $PATH. In CLion kan je via CLion settings (File - Settings - Build, Execution, Deployment, Toolchains) een andere CMake executable kiezen.\nLabo oefeningen  Het is oorlog! De orcs vallen aan en zien er hongerig uit! Ze eten al je klinkers op! Schrijf een programma dat de functie char* omnom(char zin[]) implementeert en alle klinkers uit een zin haalt (of ze verdoezelt met een X). Je moet ook een main() functie schrijven die de gebruiker een zin laat ingeven en het resultaat afdrukt op het scherm. (Tip: scanf of fgets, rara?)\n Laten we die smerige orcs eens modelleren. Vraag de gebruiker om een nummer. Dat nummer is het aantal orcs dat in het leger zit. Maak zoveel orc struct instances aan met een random waarde voor de eigenschappen. Druk dit af op het scherm. Een orc heeft de volgende eigenschappen:  aanval levens  De orcs worden gek van honger en eten alvast elkaar op! Breid het programma uit zodat de eerste orc met de volgende vecht (levens - aanval). Voorzie de functie Orc vecht(Orc aanvaller, Orc verdediger). Leeft de verdediger na de aanval nog? Dan is hij de winnaar. Welke orc weet zich tot het laatste te verweren? Druk deze af. Herstructureer je orc struct door het in een header file te zetten. Maak een makefile om alles netjes te compileren met het commando `make.  Je hebt het pointer symbool * in de oefeningen enkel nodig om een array terug te geven, zoals de omnom functie. In Java zou dat gewoon char[] omnom(char[] zin) zijn - merk op waar de vierkante haakjes precies staan: achter het type! In C is dat achter de naam van de variable.\nHint: denk aan de GNU Coding Standards. De C++ Style Guide van Google kan je ook eens bekijken. Merk op dat in C methodes snake-cased zijn: mijn_mooie_methode - ten opzicht van C++ en Java\u0026rsquo;s camel-casing: mijnMooieMethode.\nJe hoeft nog geen rekening te houden met memory leaks.\nC online compileren kan op rextester.com of oefenen op repl.it.\nDenkvragen  Waarom zou je kiezen voor een implementatie in C bij een bepaald probleem, of waarom niet? Beargumenteer je keuze. Op welke manier kan je object-geörienteerd programmeren emuleren in C? Geef een voorbeeld. Wat is het belangrijkste verschil tussen een low-level taal als C en Java of C#? Denk aan het resultaat van compilatie.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/c/labo-2/",
	"title": "Labo 2: Pointers in C en C++",
	"tags": [],
	"description": "",
	"content": " In onderstaande schematische voorbeelden zijn de volgende concepten expliciet te onderscheiden:\n Een naam van een variabele Een waarde van een variabele  En de volgende impliciet:\n Het type van een variabele Het adres van een variabele  Het type van een variabele bepaalt de hoeveelheid geheugen die vrijgemaakt wordt om de waarde te kunnen bewaren. De waarde is ofwel een actuele waarde ofwel een adres dat refereert naar een andere waarde. Elke variabele heeft een uniek adres. Variabelen kunnen dus naar elkaar verwijzen.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[variabelenaamwaarde] B{variabelenaamadres}  Dit voorbeeld visualiseert int a = 5:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[a5]  Waarbij het type, int, afhankelijk van het platform een aantal bytes reserveert (sizeof(int)) op een bepaald adres. Het adres kunnen we zelfs manipuleren in C/C++ en is essentiëel voor het gebruik van onder andere arrays.\n\u0026ldquo;Compound\u0026rdquo; types C/C++ gebruikt een pass-by-value systeem om variabelen door te geven aan functies. Dit wil zeggen dat de waarde gekopiëerd wordt, en die functie geen wijzigingen kan aanbrengen aan de originele waarde. Dat is iets positief: separation of concerns.\nAls we denken aan ons persoon voorbeeld van labo 1, wordt die struct dus telkens overgekopiëerd. Dat kan zeer inefficiënt zijn, naargelang de grootte van de data! Om dit te vermijden, gebruiken we een \u0026ldquo;pointer\u0026rdquo;: een referentie naar de actuele data. Objecten worden in Java standaard pass-by-reference meegegeven - in C moeten we hier nog iets extra voor doen dus.\nIn plaats van is_oud(struct Persoon persoon) wordt de signatuur is_oud(struct Persoon* persoon). Om hier een waarde uit te lezen hebben we twee mogelijkheden:\n De pointer \u0026ldquo;dereferencen\u0026rdquo;: de eigenlijke waarde opvragen, achter de referentie. Via de pointer de members van de struct opvragen met \u0026ldquo;.\u0026rdquo;.  Omdat in C de . operator voorrang heeft op *, moeten we haakjes gebruiken voor optie twee: (*persoon).leeftijd. Dat is vervelend om constant te gebruiken, daarom is er een alternatieve syntax met de arrow -\u0026gt; operator: persoon-\u0026gt;leeftijd.\nIn Java spreek je members natuurlijk altijd aan met ..\nReference types Opgelet - reference types zijn C++ specifiek. Dit is echter een integraal onderdeel van je kennis van compound types en wordt dus hier al uitgelegd. Als je onderstaande voorbeelden wenst te testen, gebruik dan g++ in plaats van gcc!\nEen referentie variabele is niet meer dan een alternatieve naam voor dezelfde variabele. Ze zijn herkenbaar door \u0026amp; na variabele type. Referenties moeten \u0026ldquo;gebind\u0026rdquo; worden bij declaratie:\nint geslacht = 10; int \u0026amp;mannelijkheid = geslacht; int \u0026amp;vrouwelijkheid; // compiler error mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A{\u0026mannelijkheid} --|ref| B[geslacht10]  Referenties kan je zien als \u0026ldquo;constante pointers\u0026rdquo; die automatisch de -\u0026gt; toepassen. Het adres van het doel wordt bewaard, niet de eigenlijke waarde. Referenties zijn geen objecten en hebben geen volwaardig adres op de stack.\nJe kan nog steeds de waarde van het object wijzigen via de referentie: mannelijkheid = 20; zal de variabele geslacht ook wijzigen - die zijn immers hetzelfde. Als je dat wil vermijden heb je const nodig (p60).\nPointer types Een pointer is een \u0026ldquo;veranderbare\u0026rdquo; referentie naar een variabele. Pointers hebben hun eigen geheugenadres op de stack en kunnen op eender welk moment naar iets anders verwijzen: ze zijn niet constant. Ze zijn herkenbaar door * na variabele type.\nint jong = 10; int oud = 80; int *leeftijd = \u0026amp;jong; leeftijd = \u0026amp;oud; mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A{*leeftijd} --|na regel 3| B[jong10] A -- |na regel 4| C[oud80]  Merk op dat we hier toch nog \u0026amp; gebruiken! Dit is geen referentie type maar de address-of operator om het adres van de variabele jong vast te krijgen. Een pointer verwijst naar een adres, niet naar een waarde.\nWat is de output van printf(\u0026quot;%d\u0026quot;, leeftijd);? 1389434244! Huh? We drukken het adres van de pointer af, niet waar de pointer naar verwijst. Om dat te doen heb je weer de * operator nodig: printf(\u0026quot;%d\u0026quot;, *leetijd);. Dit noemen we dereferencen.\nDe compiler geeft dit ook aan als warning:\n warning: format specifies type \u0026lsquo;int\u0026rsquo; but the argument has type \u0026lsquo;int *\u0026rsquo; [-Wformat]\n Pointers kunnen ook verwijzen naar\u0026hellip; pointers naar\u0026hellip; pointers naar \u0026hellip; Genoeg keer * toevoegen.\nint jong = 10; int *ptr = \u0026amp;jong; int **ptr_to_ptr = ptr; // compiler error int **ptr_to_ptr = \u0026amp;ptr; mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A{\"**ptr_to_ptr\"} --|ref| B{\"*ptr\"} B -- |ref| C[jong10]  Waar wijst een nieuwe pointer naar die nog niet geïnstantieerd is?:\nint *ptr; printf(\u0026#34;%d\u0026#34;, *ptr); // print -122O4735835 Whoeps. Merk op dat, afhankelijk van de compiler C implementatie (VC++, clang, GNU C, \u0026hellip;), een ongeïnitialiseerde pointer naar 0 kan evalueren. Ga daar in geen geval van uit, en ken altijd de waarde NULL toe: int *ptr = NULL;.\nNULL is een platform-afhankelijke macro die in C verwijst naar 0, meestal in de vorm van een void pointer. Een void* pointer kan naar eender welk type verwijzen en wordt meestal gebruikt om low-level memory aan te spreken, zoals we zullen zien bij de GBA.\nDe definitie van een pointer schrijft niet voor waar de * precies moet staan: int* leeftijd is hetzelfde als int *leeftijd. Pas om met dingen als int* leeftijd, ouderdom! De laatste veriabele is hier een gewone int, en géén pointer!\nReferenties en pointers kan je mixen: int *\u0026amp;ref_to_ptr = ptr. Lees de tekenreeks van rechts naar links: \u0026ldquo;referentie van\u0026rdquo;, \u0026ldquo;pointer\u0026rdquo;.\nFunctie pointers Een pointer kan ook verwijzen naar een functie (p247), daarvoor heb je dezelfde signatuur definitie nodig:\n#include \u0026lt;stdio.h\u0026gt; int verhoog(int getal) { return getal + 1; } int verdubbel(int getal) { return getal * 2; } int main() { int (*op)(int) = \u0026amp;verhoog; printf(\u0026#34;verhoog 5: %d\\n\u0026#34;, op(5)); op = \u0026amp;verdubbel; printf(\u0026#34;verdubbel 5: %d\\n\u0026#34;, op(5)); return 0; } De definitie van de op pointer ziet er wat vreemd uit, maar de signatuur voorspelt dat we een int retourneren (meest links), en dat er één parameter nodig is, ook in de vorm van een int (tussen haakjes).\nFunctie pointers kan je ook als parameter meegeven, bijvoorbeeld met void exec(int (*op)(int)) {. Een functie kan een functie (pointer) teruggeven, bijvoorbeeld met int (*kies_op(int mod))(int) {. De functie \u0026ldquo;kies_op\u0026rdquo; verwacht 1 int parameter en geeft een functie pointer terug die verwijst naar een functie met 1 int parameter en returnvalue int. Om dat warboeltje te vereenvoudigen wordt meestal typedef gebruikt:\n#include \u0026lt;stdio.h\u0026gt; typedef int(*func_type)(int); int verhoog(int getal) { return getal + 1; } int verdubbel(int getal) { return getal * 2; } func_type kies_op(int mod) { return mod == 0 ? \u0026amp;verhoog : \u0026amp;verdubbel; } void exec(int (*op)(int)) { printf(\u0026#34;exec: %d\\n\u0026#34;, op(5)); } int main() { exec(kies_op(0)); // print 6  exec(kies_op(1)); // print 10  return 0; } Laten we de Persoon struct van labo 1 eens herbekijken in het licht van pointers (en typedefs):\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; struct Persoon { int leeftijd; int (*is_oud)(); }; typedef struct Persoon Persoon; int is_oud(Persoon* this) { printf(\u0026#34;checking leeftijd van persoon: %d\\n\u0026#34;, this-\u0026gt;leeftijd); return this-\u0026gt;leeftijd \u0026gt; 60; } Persoon* create_persoon(int leeftijd) { Persoon* persoon = malloc(sizeof(Persoon)); persoon-\u0026gt;leeftijd = leeftijd; persoon-\u0026gt;is_oud = \u0026amp;is_oud; return persoon; } int main() { Persoon* jaak = create_persoon(40); printf(\u0026#34;is jaak oud? %d\\n\u0026#34;, jaak-\u0026gt;is_oud(jaak)); free(jaak); // niet echt nodig, programma stopt hier toch.  return 0; } Vergeet niet dat we nog steeds in C aan het programmeren zijn.\nWat is er veranderd?\n Persoon is een typedef geworden. Pointers zijn gebruikt om struts door te geven. malloc() komt kijken om geheugen te reserveren voor een nieuwe persoon. Vergeet niet dat we dit zelf moeten terug vrijgeven met free()! Het belangrijkste: een factory method create_persoon is nodig om een nieuwe persoon te assembleren en de is_oud methode aan de struct te plakken.  Dat ziet er al iets gestroomlijnder uit maar vereist nog steeds te veel boilerplating. Zo\u0026rsquo;n constructies ga je zelden tegen komen in de praktijk. Ontwikkelaars die graag objecten maken zullen C links laten liggen.\nPraktisch gebruik van pointers 1. Snel gegevens wisselen Omdat in C alles by-value doorgegeven wordt, kunnen we met pointers de waarden van variabelen in een functie manipuleren die erbuiten gedeclareerd werd. In Java kan je de waarde van member variabelen in objecten ook wijzigen, maar niet primitives! Hoe wissel je twee getallen zonder iets terug te geven?\nvoid swap(int *px, int *py) { int temp; temp = *px; *px = *py; *py = temp; } int x = 10, y = 20; swap(\u0026amp;x, \u0026amp;y); printf(\u0026#34;(%d, %d)\\n\u0026#34;, x, y); // print (20, 10) Zoiets is ondenkbaar in Java - daar hebben we truckjes voor nodig als een int[] dat toch een object is. Natuurlijk is deze implementatie ook nadelig: is het wel duidelijk voor de caller dat variabelen gewijzigd worden? Performante algoritme implementaties profiteren van deze mogelijkheden. Duidelijke domain-driven applicaties niet: daar dient een hogere taal voor.\n2. Snel door char arrays loopen Pointers en arrays gaan hand-in-hand in C. Op pointers kan je ook operaties als ++ en -- uitvoeren die de pointer in het geheugen één plaatsje naar links of rechts opschuiven. Met char *tekst = \u0026quot;sup\u0026quot; verwijst de pointer naar het eerste karakter:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD A{*tekst} A--|begin van array|C['s'] A-.-D['u'] A-.-E['p'] A-.-F['\\0']  Een eigen printf(\u0026quot;%s\u0026quot;, tekst) zou het overlopen van de pointer kunnen zijn, tot er niets meer is, en karakter per karakter afdrukken:\nvoid print_tekst(char *tekst) { while(*tekst != \u0026#39;\\0\u0026#39;) { printf(\u0026#34;%c\u0026#34;, *tekst); tekst++; } } In C is a[i] exact hetzelfde als *(a + i)!\n3. Structuren aan elkaar linken Een gelinkte lijst is een lijst waarbij het volgende element gekoppeld wordt aan het huidige door middel van pointers. Er is geen \u0026lsquo;array\u0026rsquo;, de data structuur is het object zelf. In C wordt hier typisch een struct voor gebruikt:\nstruct itm { void* data; struct itm* next; }; Elk element bevat data, wat het element zelf voorstelt, en bijkomend een link naar het (eventuele) volgende element. Een dubbel gelinkte lijst verwijst zowel naar het volgende als het vorige item. Dit heeft voor- en nadelen. Denk bijvoorbeeld aan wat de waarde van next is bij het laatste item. Denk ook aan performantie: wat als ik van het laatste item naar het eerste wil gaan? Er wordt altijd in context van head en tail gesproken.\nEnkele link:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR A[itm1] B[itm2] C[itm3] E{NULL} A--|next|B B--|next|C C--|next|E  Dubbele link:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR AA{NULL} A[itm1] B[itm2] C[itm3] E{NULL} A--|prev|AA A--|next|B B--|prev|A B--|next|C C--|prev|B C--|next|E  Meer uitleg en praktische voorbeelden via zentut.com C linked list informatie.\nHerhaling: let op met syntax! Zie pagina 53 - symbolen zoals * en \u0026amp; in C en C++ hebben verschillende betekenissen.\n int \u0026amp;r = i; - \u0026amp; na een type: dit is een reference type int *p; - * na een type: dit is een pointer type p = \u0026amp;i - \u0026amp; gebruikt in een experessie als address-of operatie *p = i - * gebruikt in een expressie als dereference operatie  Vergeet niet dat de eerste regel enkel geldig is in C++.\nLabo oefeningen  Implementeer int strcmp_own(char *s, char *t) van \u0026lt;string.h\u0026gt; zelf. Geef het getal 0 terug indien strings gelijk zijn, een getal kleiner dan 0 (bvb. -1) indien s \u0026lt; t en een getal groter dan 0 (bvb. 1) indien s \u0026gt; t. Gebruik je pointer kennis om snel het geheugen te scannen. Jij bent een brave bibliothecaris. En als brave bibliothecaris is het je taak om boeken alfabetisch te sorteren op achternaam. Laat de gebruiker een aantal achternamen ingeven, gescheiden door spatie (tip: strtok, en druk dan gesorteerd de inventaris af. Uiteraard gebruik je pointers.  input: lenaerts zwanskop aerts groeneveld output: aerts groeneveld lenaerts zwanskop  Ohnee, je broer de stoute bibliothecaris is gearriveerd! Hij maakt een zootje van de bibliotheek en sorteert graag omgekeerd van Z naar A, de smeerlap. Voorzie naast void brave_bibliothecaris(char **auteurs, int aantal) ook een void stoute_bibliothecaris(char **auteurs, int aantal) methode. Vraag de gebruiker eerst of hij stout of braaf geweest is. Gebruik functie pointers om te wisselen van bibliothecaris!  input: stout (enter) lenaerts zwanskop aerts groeneveld output: zwanskop lenaerts groeneveld aerts   Tips:\n Voorbeeld gebruik van de standaard strcmp functie. Opnieuw: denk aan de GNU Coding Standards! Een \u0026ldquo;array van strings\u0026rdquo; is in C een pointer naar pointers van characters (char**). Je mag een arbitraire hoeveelheid spaties aannemen. Insertion Sort is goed genoeg, pseudocode staat daar. Gebruik je eigen strcmp! De stoute bibliothecaris mag de brave zijn werk gebruiken en reversen! Pas op met fgets na scanf - deze laat \\n nog in de stream achter die de eerste onterecht verwerkt. Gebruik getchar() om dat karakter te negeren.  Denkvragen  Wat is het verschil tussen char msg[] = \u0026quot;heykes\u0026quot; en char *msg = \u0026quot;heykes\u0026quot;? Verduidelijk je antwoord met een schema. Wat is het verschil tussen int a[10][20] en int *b[10]? Kan je ook iets zeggen over het geheugengebruik? Hoe zouden we de bibliothecaris kunnen veralgemenen naar een sorteerder van eender welk datatype in plaats van enkel char? Denk aan Java\u0026rsquo;s generics. In welk geval zou jij zeker pointers gebruiken in C, en in welk geval niet? Beargumenteer je keuze. Als ik mijn eigen gelinkte lijst wens te implementeren, hoe ziet mijn data structuur er dan uit? Teken ook een schema van zo\u0026rsquo;n lijst als voorbeeld. Hint: zie zentut.com C linked list informatie.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/c/stack-vs-heap/",
	"title": "Labo 2b: De stack VS de heap",
	"tags": [],
	"description": "",
	"content": " De Stack en de Heap Dit hoofdstuk is een kopie van hoofdstuk 8.1: Stack VS Heap uit het vak Besturingssystemen en C voor 2de bachelor ICT/Electronica. Voor het vak Softwareontwerp in C/C++ wordt er eveneens verwacht de nodige kennis te bezitten over de werking van de stack en de heap.\nOptionele begeleidende videos en oefeningen zijn beschikbaar in hoofdstuk 8.2 en 8.3 in bovesntaande cursus.\nProgram Memory  Compiled computer programs are divided into different sections, each with their own specific needs and properties. Together, they form the program memory. The following image represents these sections, from bottom to top:   text Read-only, fixed size. Contains executable instructions.   data Can be modified. Contains global or static variables that are initialized, such as static int i = 5;. Global variables are variables that live outside of any function scope, and are accessible everywhere, such as int i = 5; int main() { printf(\"%d\", i); }.   bss Can be modified. Contains uninitialized data, such as static int i;.   heap Dynamically growing. Contains data maintained by malloc() and free(), meaning most pointer variables. The heap is shared by all threads, shared librarys, and dynamically loaded modules in a process. Can be modified while the process is running.   stack Set size. Contains automatic variables: variables created when (automatically) entered a function, such as int main() { int i = 5; }. Can be modified manually using the command ulimit - but this cannot be modified once the process is running.      \u0026nbsp;  The Stack Besides (automatic) variables, a few more important things also live in the stack section of the program. These are the stack pointer (SP) and the \u0026lsquo;program stack\u0026rsquo; itself.\nContrary to initialized pointers, arrays within functions are also bound to the stack, such as char line[512];.\nThe Heap Contrary to arrays, initialized pointers are bound to the heap, such as char* line = malloc(sizeof(char) * 10) - except for pointer values that are being assigned directly with a string constant such as char* line = \u0026quot;hello\u0026quot;;. Freeing the last line would result in the error munmap_chunk(): invalid pointer.\nThe usage of malloc() and such is required if you want to reserve space on the heap. memcpy() from \u0026lt;string.h\u0026gt; makes it possible to copy values from the stack to the heap, without having to reassign every single property. Make sure to reserve space first!\n#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; typedef struct Data { int one; int two; } Data; Data* from_stack() { Data data = { 1, 2 }; Data *heap_data = malloc(sizeof(Data)); memcpy(heap_data, \u0026amp;data, sizeof(Data)); return heap_data; } int main() { Data* heap = from_stack(); printf(\u0026#34;one: %d, two: %d\\n\u0026#34;, heap-\u0026gt;one, heap-\u0026gt;two); } This is called creating a deep copy, while a shallow copy creates a copy of a pointer, still pointing to the same value in memory space.\nWhat happens when you omit malloc() and simply write Data *heap_data = memcpy(heap_data, \u0026amp;data, sizeof(Data));?\n  As another side node, it is possible to resize variables on the heap, using realloc(). This is simply not possible on the stack: they cannot be resized. Also, using calloc instead of malloc initializes the allocated memory to zero instead of \u0026ldquo;nothing\u0026rdquo;. So now you know how to use malloc, calloc, realloc, and free.\nInspecting program memory in the OS Unix-like operating systems implement procfs, a special filesystem mapped to /proc, that makes it easy for us to inspect program running program state. You will need the process ID (PID) as it is the subdir name. Interesting files to inspect are:\n /proc/PID/maps, a text file containing information about mapped files and blocks (like heap and stack). /proc/PID/mem, a binary image representing the process\u0026rsquo;s virtual memory, can only be accessed by a ptrace\u0026rsquo;ing process.  We will take a closer look at these during the labs.\nMac OSX Does not have procfs. Instead, you will have to rely on commandline tools such as sysctl to query process information.\nShould I use the stack or the heap? Good question. The answer is obviously both. Use the stack when:\n You do not want to de-allocate variables yourself. You need speed (space is managed efficiently by the CPU). Variable size is static.  Use the heap when:\n You require a large amount of space (virtually no memory limit). You don\u0026rsquo;t mind a bit slower access (fragmentation problems can occur). You want to pass on (global) objects between functions. You like managing things yourself. Variable size could be dynamic.  What piece of code could be dynamic in size? Data structures, such as linked lists from chapter 3: pointers and arrays, are a good candidate for this: arrays, sets, maps, and any other form of collection can grow and shrink in size, therefore need dynamic memory mapped. Using [] will, in most cases, not suffice in the C programming language, unless you are doing something very simple.\nMemory management Freeing up space In order to create an instance of a structure and return it, you have to allocate memory using malloc() from \u0026lt;stdlib.h\u0026gt; - we now that already. In contrast with higher level languages such as Java, C requires programmes to clean up the allocaed memory themselves! This means calling free() to free up the space for future use. For instance:\nstruct Stuff { int number; }; typedef struct Stuff Stuff; void do_nasty_things() { // ...  Stuff* ugly = malloc(sizeof(Stuff)); ugly-\u0026gt;number = 10; // ... } int main() { do_nasty_things(); // other things } As soon as the method do_nasty_things() ends, ugly is not accessible anymore because it was not returned and there are no other references to it. However, after the function, memory is still reserved for it. To counter memory leaks such as these, you can do a few things:\n Keep things local, by keeping things on the stack. The Stack, for that function, will be cleared after calling it. Change Stuff* to Stuff. Free the pointer space at the end of the function by calling free(ugly).  Since this is a small program that ends after main() statements are executed, it does not matter much. However, programs with a main loop that require a lot of work can also contain memory leaks. If that is the case, leak upon leak will cause the program to take op too much memory and simply freeze.\nDo not make the mistake to free up stack memory, such as in this nice example, from the \u0026lsquo;Top 20 C pointer mistakes\u0026lsquo;:\nint main() { int* p1; int m = 100; // stack var  p1 = \u0026amp;m; // pointer to stack var  free(p1); // BOOM headshot!  return 0; }  a.out(83471,0x7fff7e136000) malloc: *** error for object 0x7fff5a24046c: pointer being freed was not allocated *** set a breakpoint in malloc_error_break to debug Abort trap: 6  Dangling pointers A second mistake could be that things are indeed being freed, but pointers still refer to the freed up space, which is now being rendered invalid. This is called a dangling pointer, and can happen both on the heap (while dereferencing an invalid pointer after freeing up space):\nint *p, *q, *r; p = malloc(8); // ... q = p; // ... free(p); r = malloc(8); // ... something = *q; // aha!  , and on the stack (while dereferencing an invalid pointer after returning an address to a local variable that gets cleaned up because it resides on the stack):\nint *q; void foo() { int a; q = \u0026amp;a; } int main() { foo(); something = *q; // aha! } Garbage Collection - not happening in C\u0026hellip; The above mistakes are easily made if you are used to Java:\nvoid foo() { Animal cow = new Animal(); cow.eat(); // ... } public static void main(String[] args) { foo(); // cow instances are cleaned up for you... } This cleaning process, that automatically frees up space in multiple parts of the allocated memory space, is called garbage collecting.  And it is completely absent in C, so beware!\nWhat happens when the stack and heap collide? That is platform-dependent and will hopefully crash instead of cause all forms of pain. There are a few possibilities:\n Stack \u0026ndash;\u0026gt; heap. The C compiler will silently overwrite the heap datastructure! On modern OS systems, there are guard pages that prevent the stack from growing, resulting in a segmentation fault. Also, modern compilers throw exceptions such as stack overflow if you attempt to go outside the reserved space (= segfault). Heap \u0026ndash;\u0026gt; Stack. The malloc() implementation will notice this and return NULL. It is up to you to do something with that result.  Write a program with an infinite loop that puts stuff on the stack. What is the program output? Do the same with infinite malloc()\u0026rsquo;s. What happens now?\n  What\u0026rsquo;s a stack overflow? The stack is a limited, but fast piece of program memory, made available for your program by the OS. The keyword here is limited. Unlike the heap, it will not dynamically grow, and it is typically hard-wired in the OS. Simply keeping on adding stuff to the stack, such as calling methods within methods without a stop condition (infinite recursion), will cause a stack overflow exception, signaling that the OS prevented your program from taking over everything:\n// forward definition void flow(); void flow() { // on the stack  int x = 5; // on the stack  flow(); // keep on going } int main() { flow(); } This causes a segmentation fault on my OSX machine, signaling that it was killed by the OS. Add printf() statements to your liking.\nHow do I know how big the stack can be on my OS? Use ulimit -a to find out:\n outers-MacBook-Air:ch8-stack wgroeneveld$ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited file size (blocks, -f) unlimited max locked memory (kbytes, -l) unlimited max memory size (kbytes, -m) unlimited open files (-n) 4864 pipe size (512 bytes, -p) 1 stack size (kbytes, -s) 8192 **BINGO** cpu time (seconds, -t) unlimited max user processes (-u) 709 virtual memory (kbytes, -v) unlimited  So it\u0026rsquo;s 8.19 MB.\nOptimizing C code Compiler flags Depending on your compiler and your target platform, the C compiler will try to optimize code by rearranging declarations and possibly even removing lines such as completely unused variables. The GNU and LLVM gcc compilers offer multiple levels of optimization that can be enabled by passing along -O1, -O2, and -O3 flags (O = Optimize). Consider the following code:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;void stuff() { char dingdong[] = \u0026#34;hello? who\u0026#39;s there?\u0026#34;; printf(\u0026#34;doing things\\n\u0026#34;); } int main() { stuff(); } stuff is not doging anything with the char array. Compile with gcc -g -O3 test.c to enable debug output and optimize. When disassembling using lldb (LLVM) or gdb (GNU), we see something like this:\n (lldb) disassemble --name stuff a.out`stuff at test.c:3: a.out[0x100000f30]: pushq %rbp a.out[0x100000f31]: movq %rsp, %rbp a.out[0x100000f34]: leaq 0x4b(%rip), %rdi ; \"doing things\" a.out[0x100000f3b]: popq %rbp a.out[0x100000f3c]: jmp 0x100000f64 ; symbol stub for: puts a.out`main + 4 [inlined] stuff at test.c:12 a.out`main + 4 at test.c:12: a.out[0x100000f54]: leaq 0x2b(%rip), %rdi ; \"doing things\" a.out[0x100000f5b]: callq 0x100000f64 ; symbol stub for: puts a.out[0x100000f60]: xorl %eax, %eax  Where is dingdong? The compiler saw it was not used and removed it. Without the -O3 flag:\n (lldb) disassemble --name stuff a.out`stuff at test.c:3: a.out[0x100000e90]: pushq %rbp a.out[0x100000e91]: movq %rsp, %rbp a.out[0x100000e94]: subq $0x30, %rsp a.out[0x100000e98]: movq 0x171(%rip), %rax ; (void *)0x0000000000000000 a.out[0x100000e9f]: movq (%rax), %rax a.out[0x100000ea2]: movq %rax, -0x8(%rbp) a.out[0x100000ea6]: movq 0xc3(%rip), %rax ; \"hello? who's there?\" a.out[0x100000ead]: movq %rax, -0x20(%rbp) a.out[0x100000eb1]: movq 0xc0(%rip), %rax ; \"ho's there?\" a.out[0x100000eb8]: movq %rax, -0x18(%rbp) a.out[0x100000ebc]: movl 0xbe(%rip), %ecx ; \"re?\" a.out[0x100000ec2]: movl %ecx, -0x10(%rbp) a.out[0x100000ec5]: movl $0x0, -0x24(%rbp) a.out[0x100000ecc]: cmpl $0xa, -0x24(%rbp) a.out[0x100000ed3]: jge 0x100000ef2 ; stuff + 98 at test.c:5 a.out[0x100000ed9]: movslq -0x24(%rbp), %rax a.out[0x100000edd]: movb $0x63, -0x20(%rbp,%rax) a.out[0x100000ee2]: movl -0x24(%rbp), %eax a.out[0x100000ee5]: addl $0x1, %eax a.out[0x100000eea]: movl %eax, -0x24(%rbp) a.out[0x100000eed]: jmp 0x100000ecc ; stuff + 60 at test.c:5 a.out[0x100000ef2]: leaq 0x8b(%rip), %rdi ; \"doing things\\n\" a.out[0x100000ef9]: movb $0x0, %al a.out[0x100000efb]: callq 0x100000f46 ; symbol stub for: printf a.out[0x100000f00]: movq 0x109(%rip), %rdi ; (void *)0x0000000000000000 a.out[0x100000f07]: movq (%rdi), %rdi a.out[0x100000f0a]: cmpq -0x8(%rbp), %rdi a.out[0x100000f0e]: movl %eax, -0x28(%rbp) a.out[0x100000f11]: jne 0x100000f1d ; stuff + 141 at test.c:9 a.out[0x100000f17]: addq $0x30, %rsp a.out[0x100000f1b]: popq %rbp a.out[0x100000f1c]: retq a.out[0x100000f1d]: callq 0x100000f40 ; symbol stub for: __stack_chk_fail  You can fiddle with options and such yourself in godbolt.org.\nInstead of bootstrapping the debugger to inspect disassembly, you can also simply dump the object contents using objdump -D (GNU) or otool -tV (OSX).\n volatile When heavily optimizing, sometimes you do not want the compiler to leave things out. This is especially important on embedded devices with raw pointer access to certain memory mapped spaces. In that case, use the volatile keyword on a variable to tell the compiler to \u0026ldquo;leave this variable alone\u0026rdquo; - do not move it\u0026rsquo;s declaration and do not leave it out. For instance:\nint array[1024]; int main (void) { int x; for (int i = 0; i \u0026lt; 1024; i++) { x = array[i]; } } Does pretty much nothing. Compiling with -O3 results in 2 assembly instructions:\n main: xor eax, eax ret  However, if you want x to be left alone, use volatile int x; and recompile:\n main: mov eax, OFFSET FLAT:array .L2: mov edx, DWORD PTR [rax] add rax, 4 mov DWORD PTR [rsp-4], edx cmp rax, OFFSET FLAT:array+4096 jne .L2 xor eax, eax ret  That\u0026rsquo;s a big difference.\nFunction call order Another part of optimizing code is the determination of function call order. For instance, consider the following statement: x = f() + g() * h(). Which function gets called first?\nThe answer is we do not know. Do not rely on function order to calculate something! Each function should be completely independant. There should not be a global variable manipulated in f() which will then be needed in g() or h(). You can inspect disassembled code for different compilers on https://godbolt.org/. It will differ from platform to platform, and from compiler to compiler (and even from option flag to flag).\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-c/labo-3/",
	"title": "Labo 3: Introductie in GBA Programming",
	"tags": [],
	"description": "",
	"content": " Je hebt nu een crashcrusus C achter de kiezen met een grondige focus op pointers. Hoog tijd om die kennis om te zetten in iets concreet én plezant. We gaan een héél simpel Gameboy Advance (GBA) spel ontwikkelen.\nDe GBA is een goede keuze om de kracht (en zwakheden) van C te demonstreren. Er is immers géén besturingsyssteem aanwezig. Er zijn géén libraries aanwezig voor memory management, IO, files, error handling, \u0026hellip; Het is een embedded hardware systeem dat een cross-compiler vereist: een compiler op onze PC\u0026rsquo;s dat compileert voor een ander platform en CPU, namelijk een 32-bit ARM op 16.78 Mhz.\n  Het resultaat van veel hard werk in C (en Assemly)\u0026hellip; \nGBA Programming: een introductie Om eender wat gedaan te krijgen op een GBA zullen we alles met memory-mapped IO moeten doen, door rechtstreeks bits weg te schrijven in geheugenadressen die zaken als het scherm, knoppen en het geluid voorstellen. Er is niet eens een printf() functie! In de plaats daarvan moeten we \u0026ldquo;hello world\u0026rdquo; tekenen op het scherm, wat véél meer werk vereist.\nProgrammeren op een extern systeem brengt véél hardwarematige complexiteit met zich mee. We gaan hier niet alles behandelen. De geïnteresseerden kunnen hier terecht voor meer diepgaande tutorials:\n http://www.loirak.com/gameboy/gbatutor.php https://www.coranac.com/tonc/text/first.htm  Laten we het eenvoudigste eerst proberen: de achtergrond te kleuren.\nHet geheugen layout van de GBA Een duidelijk zicht op I/O adressen en hun functie zijn belangrijk. Adressen vallen in een range, afhankelijk van de grootte van het geheugen van elk systeem. Hieronder een kort overzicht (bron):\n 0x00000000 - 0x00003FFF - 16 KB System ROM (executable, but not readable) 0x02000000 - 0x02030000 - 256 KB EWRAM (general purpose RAM external to the CPU) 0x03000000 - 0x03007FFF - 32 KB IWRAM (general purpose RAM internal to the CPU) 0x04000000 - 0x040003FF - I/O Registers 0x05000000 - 0x050003FF - 1 KB Colour Palette RAM 0x06000000 - 0x06017FFF - 96 KB VRAM (Video RAM) 0x07000000 - 0x070003FF - 1 KB OAM RAM (Object Attribute Memory — discussed later) 0x08000000 - 0x???????? - Game Pak ROM (0 to 32 MB) 0x0E000000 - 0x???????? - Game Pak RAM  Display setup Er zijn 6 verschillende \u0026ldquo;Video Modes\u0026rdquo; beschikbaar die je moet aan- of uitzetten voordat je iets kan tekenen op het scherm. De GBA ondersteunt tilesets om sprites efficiënter te tekenen (de 3 laatste modes), maar wij hebben voorlopig genoeg aan pixel per pixel de kleur te zetten (de 3 eerste modes). De eenvoudigste mode zonder buffering is video mode 3. Dit heeft een resolutie van 240x160. Elke pixel RGB waardes om aan te spreken.\nNaast mode 3 moeten we ook een \u0026ldquo;Background mode\u0026rdquo; kiezen. Er zijn 4 achtergrond lagen beschikbaar die het mogelijk maken om een 3D illusie te creëren door laag per laag te tekenen. BG mode 2 volstaat voorlopig.\nDe video parameters worden weggeschreven in controleregister 0x4000000. De combinatie van BG2 en Mode3 kunnen we met een bitwise operator | samen plakken, maar je kan evengoed de bits apart manipuleren. Om de cryptische registers wat te verduidelijken gebruiken we preprocessor defines.\n#define MODE3 0x0003 #define BG2 0x0400  volatile unsigned int *display_control = (volatile unsigned int*) 0x4000000; int main() { *display_control = MODE3 | BG2; } Zie Hardware Specifications documentatie.\nWat doet die volatile daar? Dit zijn low-level registeradressen die op eender welk moment door de hardware zelf veranderd kunnen worden. Het volatile keyword zegt tegen de compiler dat dit stukje code niet geoptimaliseerd mag worden. De compiler kan anders nog beslissen om instructies van volgorde te wisselen met vreemde werking tot gevolg.\nSimpele display manipulatie De vereiste display setup is gebeurd, laten we wat pixels wegschrijven in het scherm register op 0x6000000:\n#define WIDTH 240 #define HEIGHT 160 volatile unsigned short *vram = (volatile unsigned short*) 0x6000000; vram[80*WIDTH + 115] = 0x001F; // 000000000011111 = R vram[80*WIDTH + 120] = 0x03E0; // 000001111100000 = G vram[80*WIDTH + 125] = 0x7C00; // 111110000000000 = B  while(1); Prachtig, een rode, groene en blauwe pixel opgelicht!\nVRAM is een (short, 16-bit) pointer naar een adres, om de X en Y coördinaten te bepalen gebruiken we een formule vram[X*WIDTH +Y]. De oneindige lus zorgt er voor dat het spel niet plots \u0026ldquo;stopt\u0026rdquo; - vergeet niet dat er geen OS is, dus zo\u0026rsquo;n gevaarlijke code moet zelfs op de GBA.\nKleuren worden voorgesteld als een aaneenschakeling van binaire nummers. Het aantal bits geeft ons een idee hoeveel unieke kleuren we hebben. De originele Gameboy had 2 bits: zwart, wit, en twee schakeringen van grijs tussenin (00, 01, 10, 11). De GBA heeft er 15 (1 bit ongebruikt), met 5 bits per interval:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR; A[--] --- B[B] B --- C[B] C --- D[B] D --- E[B] E --- F[B] F --- G[G] G --- H[G] H --- I[G] I --- J[G] J --- K[G] K --- L[R] L --- M[R] M --- N[R] N --- O[R] O --- P[R] style B stroke:blue style C stroke:blue style D stroke:blue style E stroke:blue style F stroke:blue style G stroke:green style H stroke:green style I stroke:green style J stroke:green style K stroke:green style L stroke:red style M stroke:red style N stroke:red style O stroke:red style P stroke:red  Hexadecimale kleuren tekenen is onbegonnen werk natuurlijk, laten we een functie maken die de juiste bits shift afhankelijk van een R,G,B waarde van 0 tot 31 (unsigned int):\nunsigned short color(unsigned int r, unsigned int g, unsigned int b) { unsigned short c = (b \u0026amp; 0x1f) \u0026lt;\u0026lt; 10; c |= (g \u0026amp; 0x1f) \u0026lt;\u0026lt; 5; c |= (r \u0026amp; 0x1f); return c; } Ox1f verzekert 5-bits (11111 binair), met eerst blauw, dan groen en dan rood op de juiste plaats geshift. 240x160 = 38.400 kleuren x 16-bit = 614.400 bits / 8 = 76.800 bytes. Adres 0x6000000 gaat dus tot 0x6012c00.\nOm niet altijd het adres rechtstreeks aan te spreken met de breedte berekening, wrappen we dat ook nog in een functie:\nvoid set_pixel(int x, int y, unsigned short color) { vram[x*WIDTH + y] = color; } Een loop over X en Y waardes van het scherm zorgt voor een vrolijke kleur op je Gameboy scherm. Download het labo-3-gbabg.c hier. Merk op dat dit pushen van pixel per pixel natuurlijk erg inefficiënt is: daarvoor zijn de tile video modes 0, 1 en 2.\nDit is wat je te zien krijgt:\n \nKeypad input Oké, we hebben en \u0026ldquo;spel\u0026rdquo; geschreven met een blauwe achtergrond. Hoe passen we dit aan afhankelijk van een bepaalde toetsencombinatie? Volgens de GBA Keypad input specificaties moeten we hiervoor IO register 0x04000130 uitlezen.\nBit 6 staat bijvoorbeeld voor \u0026ldquo;up\u0026rdquo;. Geconverteerd van binary naar hex levert 1000000, ofwel 40 (dus 0x40) op (6de bit op 1, beginnend vanaf bit nummer 0 in plaats van 1!). We kunnen key up dus definiëren als #define KEY_UP 0x0040. Je kan ook dynamisch 6 bits shiften: #define KEY_UP (1 \u0026lt;\u0026lt; 6). Een derde mogelijkheid is in machten van 2 te werken (bits): #define KEY_UP 64.\nHet is een goed idee om maar 1x tijdens de game loop alle key states uit te lezen. Een mask die alle input bits checkt is daarvoor nodig:\n#define KEY_ANY 0x03FF  int main() { unsigned int keys; while(1) { keys = ~*key_input \u0026amp; KEY_ANY; // do stuff  if(keys \u0026amp; KEY_UP) { // do more stuff  } } } Merk de ~ op: het register bewaart de state omgekeerd.\nCompileren voor de GBA De gcc compiler kan je C programma ook compileren - het is tenslotte in de C taal geschreven. De register adressen verwijzen echter niet naar het juiste als je die binary op je PC wil uitvoeren, wat resulteert in \u0026ldquo;Segmentation Fault\u0026rdquo; waarschuwingen.\nDe cross-compiler De \u0026ldquo;DevkitPro\u0026rdquo; toolchain installeren levert je een aantal cross-compilers en linkers op die een C source file omzetten ine en GBA binary. Zie installatie instructies per OS. Via de meegeleverde package manager pacman kan je op OSX de package gba-dev installeren. Voor Windows is er een installer voorzien.\nJe hebt 2 dingen nodig:\n arm-none-eabi-gcc, de cross-compiler arm-none-eabi-objcopy, de linker  Download een Makefile voor gba dev hier. Pas je emulator pad en source bestandsnaam aan.\nUbuntu specifieke installatie Voor Ubuntu moet je eerst de devkitpro-pacman .deb file installeren die je hier op Github kan vinden. Het pacman commando is dan het dkp-pacman commando om verwarring met apt te vermijden. Installeer alle gba dev tools met sudo dkp-pacman -S gba-dev. De compilers zijn dan geïnstalleerd in /opt/devkitpro/devkitARM/bin dus voeg die folder toe aan je $PATH.\nJe GBA file emuleren op PC Compileren met een cross-compiler gaat, maar de binaries kan je nooit op een ander systeem draaien dan waarvoor het gecompileerd is - tenzij je dit emuleert. Een .gba binary kan je emuleren op de PC met mGBA.\nJe GBA file spelen op een echte Gameboy De aanschaf van een EZ-FLASH Omega bord maakt het mogelijk om met microSD kaarten .gba roms in te laden op je Gameboy Advance. Zo\u0026rsquo;n cartridges bestaan al jaren: vroeger was EZ-Flash IV en Supercard populair. Tegenwoordig kan je met een SD adapter files drag- en droppen.\n \nHet plastieken omhulsel open gevezen geeft zicht op het bord:\n \nDit is een deel van labo 4 op de eigenlijke hardware:\n \nEen EZ-FLASH Omega kaart kost ongeveer €30 op Ebay. Dit is uiteraard volledig vrijblijvend: een minimum vereiste is de werking van je creatie op een emulator. Een rom uitvoeren op de eigenlijke hardware kàn verrassend zijn; sommige emulatoren zijn flexibeler in werking.\nBits en bytes beter begrijpen in C Om hexadecimale geheugenadressen en bit flags beter te begrijpen op de GBA moeten we ontdekken hoe bitwise operatoren, sizeof() en shifts werken in C. De implementatie van byte groottes wijzigt per computer maar is (bijna) altijd 8 bits: 00000000. De GBA vereist vaak - zoals het definiëren van kleuren - 16 bits: 8x2. Die kracht van 2 is geen toeval in de binaire wereld. We gebruiken 3 types in zo\u0026rsquo;n embedded systeem:\n 8 bits: typedef unsigned char uint8 16 bits: typedef unsigned short uint16 32 bits: typedef unsigned int uint32  Elke individuele bit op 1 of op 0 zetten kan je doen met hulp van binaire of bitshift operatoren. Een 16-bit variabele kan in feite 16 individuele eigenschappen opslaan (die actief of inactief staan). In een moderne taal als Java, op een moderner besturingssysteem, speelt geheugengebruik op zo\u0026rsquo;n niveau geen rol meer. Daar definiëren we voor praktische redenen gewoon 16 aparte boolean variabelen.\nOp de GBA speelt geheugengebruik een zeer belangrijke rol en kunnen we met \u0026ldquo;bit masks\u0026rdquo; alle eigenschappen samen proppen in 2 bytes. Vergeet niet dat er bijvoorbeeld maar 96KB aan 16-bit VRAM beschikbaar is. De technische GBA Memory Map pagina geeft weer hoeveel geheugen er bij welk IO adres beschikbaar is.\nDownload het voorbeeldprogramma hier om wat te experimenteren met deze gegevens. Hex naar Binary converters en Wikipedia kunnen helpen.\nhoeveel bits zit er in ene byte hier? 8 sizeof BYTES unsigned short 2 - unsigned int BYTES: 4 sizeof BITS unsigned short 16 - unsigned int BITS: 32 sizeof arr8 uint32: 32 key right (1 \u0026lt;\u0026lt; 4): 0000 0000 0001 0000 key right na nog 1 bitshift: 0000 0000 0010 0000 opgeteld met bitwise OR |: 0000 0000 0011 0000 inverse met bitwise ~: 1111 1111 1100 1111 x mask: 0000 0001 1111 1111 y mask: 0000 0000 1111 1111 Labo oefeningen  Vorm het voorbeeld in de tekst om naar een \u0026ldquo;hi!\u0026rdquo; hello world applicatie. Teken de symbolen per pixel. Download het labo-3-gbabg.c hier. Download een Makefile voor gba dev hier. Probeer eerst het bestaande te compileren met make. Laten we het iets dynamischer maken. Lees het key input register in en maak gebruik van de pijltjes om je \u0026ldquo;hi!\u0026rdquo; tekst te verschuiven. Wat een spannend spel is dit aan het worden! Definiëer het input register op exact dezelfde manier als vram in de tekst.  Denkvragen  Waarom denk je dat Video mode 3 inefficiënt is? Kan je een alternatief verzinnen en dit vergelijken met mode 3 in termen van werking? Nu je gezien hebt hoe we iets compileren voor een andere architectuur (ARM en niet x86), kan je ook een definitie geven van een embedded system? Hoe past een cross-compiler in dat plaatje? Wat gebeurt er met de output van het x en y mask als je in het bits voorbeeldprogramma in main uint16 nr; herdefiniëert als een uint8? Kunnen we dit om geheugen te besparen overal toepassen?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/gba-in-c/labo-4/",
	"title": "Labo 4: GBA Tilesets, een simpel spel",
	"tags": [],
	"description": "",
	"content": " In labo 3 maakten we kennis met de Gameboy Advance en het ontwikkelplatform - als je het zo kan noemen. We gebruikten mode 3 om pixels te manipuleren. Natuurlijk is dat erg onpraktisch en veel te belastend wanneer er veel op het scherm getekend moet worden. Als doelstelling voor labo 4 willen we een simpel geïntegreerd spelletje maken waar we video mode 1 en tilesets voor nodig hebben.\nHet overzicht van I/O registers leert ons dat 0x06000000 - 0x06017FFF 96kb aan Video RAM of VRAM voorziet waar we mee kunnen spelen zonder pixel per pixel te manipuleren.\nTileset modes Rechtstreekse pixels aanspreken is flexibel maar niet bepaald handig. De GBA kan hardwarematig \u0026ldquo;tiles\u0026rdquo; zelf renderen zonder trailing pixels na te laten: wij moeten bij transformaties niet pixel per pixel zelf verplaatsen. Een beetje moderniteit in een embedded systeem dus.\nEen \u0026ldquo;tile\u0026rdquo; is een 8x8 bitmap met 4 of 8 bits per pixel (bpp): 32 of 64 bytes in grootte. Herinner je dat voor de GBA we 15 bits nodig hebben om kleuren in een pixel op te slaan. 15 bits passen niet in die 4 of 8 bits! Daarvoor dienen kleurenpaletten die een kleur mappen op een index, met een maximum van 512. Het voorgrond palet register leeft op 0x05000000 -voor het achetgrond palet tel je 0x200 erbij.\nAls je goed kijkt zie je in de eerste screenshot allemaal 8x8 tiles tegen elkaar geplakt die het titel scherm en het Konami logo voorstellen voor het spel Castlevania: Aria of Sorrow:\nDit is de tileset: de unieke collectie van alle 8x8 tiles die we nodig hebben om een achtergrond of sprite te renderen. Getekend op het scherm ziet dat er zoals verwacht zo uit:\n   Om tegen de GBA te zeggen welke tile op welke plaats in het scherm moet komen hebben we een tilemap nodig. Een tilemap kan wél heel groot worden en stelt letterlijk het \u0026ldquo;level\u0026rdquo; of de \u0026ldquo;map\u0026rdquo; voor, met op elke plaats in de 2-dimensionele lijst een referentie naar een tile. Zie Metroid Level voorbeeld.\nAls we een deeltje van de \u0026ldquo;a\u0026rdquo; van Castlevania zoals aangeduid opblazen zie je duidelijk de 8x8 structuur:\nElke zichtbare bit stelt een kleur voor die in het palet is opgeslagen, aangeduid met een nummer als index: de tileindex. Merk op dat objecten die je ziet als je een spel speelt bijna altijd bestaan uit verschillende tiles. Elke tile wordt maar één keer opgeslagen en kan oneindig keren herhaald worden in de tile map. Bovenstaande \u0026ldquo;a\u0026rdquo; kan ruwweg vertaald worden naar deze tabel (eigen interpretatie):\nBitmap tabel:  1 5 4 3 3 3 3 6   1 1 3 4 2 2 2 2   1 1 4 5 4 2 2 2   3 4 2 4 3 3 4 2   7 5 2 3 3 1 3 6   6 2 6 3 1 1 3 6   5 2 4 3 1 1 3 6   5 5 4 3 1 1 3 6    Palet tabel:  index kleur   1  - zwart   2  - groen   3  - rood   4  - wit   5  - blauw   6  - paars (transparant)   7  - geel     We onderscheiden dus 4 belangrijke concepten om een image te renderen op de Gameboy Advance:\n Een 8x8 tile met indices die verwijzen naar het palet Een tileset waar alle tiles achter elkaar gepropt leven Een tilemap waar een image uit bestaat die verwijst naar indices in de set Een palet met kleuren  Images inladen in video RAM Anders als in mode 3 kan je dus geen tiles mappen op pixels. Het VRAM voor tilesets werkt helemaal anders: het is opgesplitst in \u0026ldquo;character blocks\u0026rdquo; (voor image data, onze tileset) en \u0026ldquo;screen blocks\u0026rdquo; (tile map data). Per 8 screen blokken van 2kb is er één character block beschikbaar. Een char block is dus 16kb en kan 512 4bpp tiles opslaan - 6 in het heel VRAM in totaal dat inderdaad 96kb oplevert.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD subgraph background blocks subgraph char block 0 A[screen blocks 0 - 70x6000000 - 0x60003800] end subgraph char block 1 A -- B[screen blocks 8 - 150x6004000 - 0x60007800] end subgraph char block 2 B -- C[screen blocks 16 - 230x6008000 - 0x6000b800] end subgraph char block 3 C -- D[screen blocks 24 - 310x600c000 - 0x6000f800] end end subgraph sprite blocks subgraph char block 4 E[screen blocks 32 - 390x6010000 - 0x6013800] D -- E end subgraph char block 5 E -- F[screen blocks 40 - 470x6014000 - 0x60107800] end end  Character blocks 0 tot 3 (background RAM) worden gebruikt voor achtergrond, en 4 (0x6010000) tot 5 (0x6014000), Object VRAM (OVRAM), voor sprites. Het palet geheugen is ook opgesplitst in 2x16 voor achtergrond en sprites. We zijn voorlopig niet geïnteresseerd in de achtergrond: voor ons spel volstaan sprites. Tilemaps worden ook enkel gebruikt om grote images zoals een achtergrond te renderen, zoals het titelscherm en logo van Castlevania.\nOm van char block naar char block te springen tellen we 0x4000 bij elke block (15de bit - 16kb). Om van screen block naar screen block te springen tellen we 0x800 bij elke block (16de bit, 2kb).\nMerk op dat character block 0 en screen block 0 beiden naar adres 0x6000000 verwijzen! Dat wil zeggen dat als tilesets in char block 0 opgeslagen worden, we niet screen block 0 maar bijvoorbeeld 8 of 16 moeten gebruiken voor onze tilemap - opschuiven afhankelijk van de grootte van de tileset. Herinner je de gelijkenis tussen pointers en arrays uit labo 2.\nOm het behandelen van deze hexadecimale adressen te vereenvoudigen kunnen we functies schrijven die het adres berekent van blokken zoals hier:\nvolatile unsigned short* char_block(unsigned long block) { return (volatile unsigned short*) (0x6000000 + (block * 0x4000)); } volatile unsigned short* screen_block(unsigned long block) { return (volatile unsigned short*) (0x6000000 + (block * 0x800)); } Dat heeft als nadeel dat je moet weten dat char_block(4) een sprite block is en 0-3 niet, en dat je moet weten dat screen_block(8) bij char block 1 hoort. Dat tweede nadeel kunnen we wegwerken met typedefs en arrays zoals hier:\ntypedef unsigned short uint16; typedef unsigned int uint32; typedef struct { uint32 data[8]; } TILE, TILE4; // tile 8x8@4bpp: 32bytes; 8 ints typedef TILE CHARBLOCK[512]; typedef uint16 SCREENBLOCK[1024]; #define MEM_VRAM 0x06000000 #define tile_mem ((CHARBLOCK*)MEM_VRAM) #define se_mem ((SCREENBLOCK*)MEM_VRAM) Dat maakt het mogelijk om met TILE *ptr= \u0026amp;tile_mem[4][12] het OVRAM (block 4) op tile 12 aan te spreken en data te kopiëren zoals memcpy(\u0026amp;tile_mem[4][12], spriteData, sizeof(spriteData)).\nDe library LibTonc (source) voorziet een aantal defaults.\nSprites Een sprite in Computer Graphics is een 2D image die deel is van een scene. De GBA kan sprite objecten voor ons renderen zonder dat wij alle pixels moeten manipuleren - dat moeten we dan nog aan zetten met bit 13 of 0x1000 in het controleregister.\nDe GBA voorziet een rudimentair object-model, \u0026ldquo;Object Attribute Memory\u0026rdquo; - zie specificaties. Een object heeft 3 sets van 16-bit attributen:\n 0: y coordinaat, vorm, 4 of 8 bpp mode 1: x coordinaat, grootte 2: tile index, welke kleur van het palet te gebruiken  Een combinatie van \u0026ldquo;vorm\u0026rdquo; en \u0026ldquo;grootte\u0026rdquo; eigenschappen bepalen de vorm van het object. Complexe vormen bestaan uit verschillende deelobjecten. We gaan het niet te ingewikkeld maken: prutsen met bits is al erg genoeg!\nOm een een \u0026ldquo;object\u0026rdquo; te definiëren gebruiken we deze struct:\ntypedef struct object { uint16 attr0; uint16 attr1; uint16 attr2; uint16 unused; } object; #define OAM_MEM ((volatile object *)0x07000000) Objecten wegschrijven doen we in register 0x07000000. Omdat OAM_MEM een pointer is, kunnen we objecten met [] wegschrijven - herinner je dat de pointer index verschuiven hetzelfde als de array index is.\nEen nieuw object maken is relatief simpel: volatile object *sprite = \u0026amp;OAM_MEM[0];. De attributen goed zetten is een ander paar mouwen omdat de bits in sets samengepakt zitten. De Tonc documentatie beschrijft elke bit van elk attribute in detail. We hebben bit 0 tot 7 voor de y coordinaat nodig, en bit 14 tot 15 voor de vorm (square = 00, wide = 10, tall = 01).\nAls we willen starten op y coordinaat 50 met een wide object en 4bpp moeten we 50 omzetten naar 8 bits (gebruik deze converter) en bits 14 en 15 goed zetten: dat levert 1000000000110010 op, of 0x8032.\nAlles samen zetten Om deze low-level bit manipulaties in de code wat leesbaar te maken gebruiken we de voorziene typedefs en definities tile_mem, se_mem en oam_mem die hierboven zijn uitgelegd.\nEen spel: Arkanoid Geïnspireerd op dit en dit.\nLaten we de basis leggen voor een Arkanoid clone op de GBA. We hebben een \u0026ldquo;paddle\u0026rdquo; nodig onderaan het scherm, dat is sprite #1. Daarnast moet er een balletje rondvliegen die blokjes raakt, dat is sprite #2. De blokjes zelf laten we voorlopig even achterwege.\nVoor de gemakkelijkheid negeren we de (x,y) coordinaten in de attribute bits van de objecten bij de OAM initializatie - die zetten we daarna wel.\nDe bal Een simpele 8x8 square sprite, dus 1 tile is voldoende. Kleur wit.\n// 1. kleur PALETTE_MEM[0][1] = color(31, 31, 31); // wit - zie labo 3  // 2. tile volatile uint16 *ball_tile = (uint16*) TILE_MEM[4][1]; // 1 block // vul de tile met de palet index 1 - dit is per rij, vandaar 0x1111 for(int i = 0; i \u0026lt; sizeof(tile_4bpp) / 2; i++) { ball_tile[i] = 0x1111; } // 3. object volatile object *ball_sprite = \u0026amp;OAM_MEM[0]; ball_sprite-\u0026gt;attr0 = 0; // 4bpp, square ball_sprite-\u0026gt;attr1 = 0; // grootte 8x8 met square ball_sprite-\u0026gt;attr2 = 1; // eerste tile, palet 0 Merk op dat TILE_MEM[4] betekent dat we de eerste 3 char of tile blocks overslaan: die dienen immers voor de achtergrond.\nDe paddle Een horizontaal geörienteerde rechthoek (wide) die groter moet zijn dan onze bal, dus meer dan 1 tile zal in beslag nemen. Als we 4 ballen achter elkaar plakken krijgen we een 32x8 sprite. Kleur rood.\nOmdat palet index #0 maar \u0026ldquo;bezet\u0026rdquo; is met één kleur (wit, van onze bal), kunnen we dat rood er bij steken, of kiezen voor een nieuw palet. Dat is het verschil tussen [0][2] (bestaand herbruiken, index 2) of [1][1] (nieuw palet, index 1).\n// 1. kleur PALETTE_MEM[0][2] = color(31, 0, 0); // 2. tile - vanaf hieronder alles bezet tot TILE_MEM[4][6]! volatile uint16 *paddle_tile = (uint16*) TILE_MEM[4][2]; // begin vanaf 2 // vul de tile met de palet index 2 - dit is per rij, vandaar 0x2222 for(int i = 0; i \u0026lt; 4 * sizeof(tile_4bpp) / 2; i++) { paddle_tile[i] = 0x2222; } // 3. object volatile object *paddle_sprite = \u0026amp;OAM_MEM[1]; paddle_sprite-\u0026gt;attr0 = 0x4000; // 4bpp, wide paddle_sprite-\u0026gt;attr1 = 0x4000; // 32x8 met wide shape paddle_sprite-\u0026gt;attr2 = 2; // vanaf de 2de tile, palet 0 Merk op dat voor attr1 (zie 8.4.2) de grootte bepaald wordt in combinatie met de sprite shape. 32x8 of 8x32 zou twee keer 0x4000 vereisen, alleen in attr0 op bit 15 en 16 een andere waarde.\nEen OAM object verplaatsen De x en y coordinaten zijn veruit de belangrijkste die dynamisch wijzigen gedurende het spel. Daarom verdienen deze hun eigen functie om gemanipuleerd te worden:\n#define Y_MASK 0x0FF #define X_MASK 0x1FF  void position(volatile object *obj, int x, int y) { obj-\u0026gt;attr0 = (obj-\u0026gt;attr0 \u0026amp; ~Y_MASK) | (y \u0026amp; Y_MASK); obj-\u0026gt;attr1 = (obj-\u0026gt;attr1 \u0026amp; ~X_MASK) | (x \u0026amp; X_MASK); } We plakken de attribute waardes zonder huidige locatie vast aan de nieuwe locatie, geshift op de juiste plaats. In de game loop, waar onze bal logica zit, gebruiken we dit om de objecten te verplaatsen.\nDe game loop De structuur van het spel ziet er als volgt uit:\n Initialiseer de juiste video registers. Maak objecten aan en alles wat daarbij komt kijken. Plaats op initiële positie. while true:  vsync (??) Lees keys Herpositioneer. Collision, physics, \u0026hellip;   Géén individueel VRAM meer aanspreken dankzij OAM, joepie\u0026hellip; Er is nog slechts één probleempje: het plaatsen van objecten triggert een draw callback. We kunnen objecten niet halverwege het drawen verplaatsen, dan krijgen we \u0026ldquo;tearing\u0026rdquo;: de helft is maar getekend! Om deze synchronizatie problemen te vermijden, moeten we wachten tot de GBA zijn display refresh klaar is.\nVBlanking De GBA tekent lijn per lijn op het scherm, en wij hebben ruimte om iets te doen tussenin. Er is echter méér ruimte nadat het hele scherm refreshed is: die ruimte heet een \u0026ldquo;V-Blank\u0026rdquo;. Tekenen zelf is een V-Draw.\nEr zijn (natuurlijk) IO registers beschikbaar voor ons om te luisteren of de GBA aan het blanken of drawen is, op 0x04000006. Dit register is een teller van scanlines. Wij wachten simpelweg tot dit hoger of gelijk aan 160 is: de resolutie hoogte van het GBA scherm.\n#define REG_VCOUNT (*(volatile uint16*) 0x04000006)  void vsync() { while (REG_VCOUNT \u0026gt;= 160); while (REG_VCOUNT \u0026lt; 160); } Oef! Nu kunnen we alles samen rapen. Download het resultaat hier. Het spel luistert ook naar de keypads om de paddle te bewegen zoals we gezien hebben in labo 3. Hieronder een gif van het spel (links: de download. rechts: labo oefening):\n       Ik hoop dat jullie nu wat meer respect tonen naar programmeurs en spellen van zulke low-level embedded systemen als de GBA. Het kost zoals we gezien hebben véél meer moeite dan een JPEG in te laden in JavaFX.\nDe geïnteresseerden kunnen hieronder eens kijken hoe je externe sprites met hun paletten sprites gebruikt in plaats van ze zelf te definiëren. Die worden meestal gegenereerd gebaseerd op een PCX bestand als aparte header files.\n Sprites and animation png2gba converter tool wingrit bitmap converter tool (bestaat ook een UNIX versie van)  Labo oefeningen Er ontbreken nog een aantal belangrijke zaken in ons spel.\n Download de opgave hier. Gebruik de makefile uit het vorige labo (pas de bestandsnaam aan!) De bal sprite beweegt niet! Oei? Verzin een simpele implementatie in de main loop die de x en y waardes van de bal OAM manipuleert. Rekening houden met physics hoeft nog niet, maar wel met de edges van het scherm. Er zijn helemaal geen blokjes om tegen te botsen bovenaan. Wat een klote spel. Maak nieuwe sprites aan die je een eigen kleur geeft, en bovenaan positioneert. Merk op dat je sprites kan herbruiken! Tijd voor wat basis collision detection. Als de bal botst tegen één van de blokjes die je hebt bijgemaakt, verdwijnt dat blokje. Zichtbaarheid is ook een bit in OAM, raadpleeg de documentatie. Extra: Kuis de code een beetje op. create_paddle en create_ball zijn nu van elkaar afhankelijk door indices in register pointers. Voorzie een globale variabele om dit allemaal te beheren. Extra: Geef elke rij van blokjes een andere kleur. De kleur stelt de hardheid voor: bijvoorbeeld voor groene blokjes te breken moet je 2x het blokje raken en voor blauwe 3x. Denk er aan om zo nauwkeurig mogelijk tewerk te gaan zonder code doelloos te kopiëren. Extra: Hoe zou je de score bij kunnen houden? En wat als je die effectief wil laten zien aan de speler? Bedenk minstens 3 verschillende implementaties en werk daarna 1 versie uit.  Denkvragen  Kan je je een ideaal soort spel inbeelden waarin video mode 1 bruikbaar zou kunnen zijn? En wanneer zou video mode 3 (of 4 met buffering) wel handig zijn? Tip: er zijn wel degelijk spellen ontwikkeld in mode 4, zoals James bond 007: Nightfire. Weet jij waarom sommige macro\u0026rsquo;s gedefiniëerd zijn als (*(volatile uint16*) 0x0) en anderen als (volatile uint16*) 0x0? Het beheren van de OAM is heel vervelend: geheugen vrijgeven verknoeit de index pointer, en de Z-index van sprites is afhankelijk van de geheugenlocatie. Een sprite manager die dit voor ons beheert zou niet misstaan. Wat is een mogelijke implementatie hiervan? Tip: lees het Gamasutra GBA Resource management artikel.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/cpp/labo-5/",
	"title": "Labo 5: Weg met C, Hallo C++",
	"tags": [],
	"description": "",
	"content": " De ++ in C++ De introductie van C++ in 1985 geeft de ervaren C programmeur enkele extra mogelijkheden om zijn of haar code te structureren. C++ wordt nog steeds omschreven als een \u0026ldquo;general purpose\u0026rdquo; low-level taal op Wikipedia:\n C++ is a general-purpose programming language. It has imperative, object-oriented and generic programming features, while also providing facilities for low-level memory manipulation.\n \u0026ldquo;Object-oriented\u0026rdquo; en \u0026ldquo;generic\u0026rdquo; zijn de sleutelwoorden hier. De C++ taal is geschreven als een extensie van C waarbij high-level features gebruikt kunnen worden om code te structureren. Kenners van Java voelen hun hier waarschijnlijk iets meer thuis (abstracts, classes, generics, grote STL bibliotheek, overloading) en dat verbaast niemand: de Java taal is sterk beïnvloed door C++.\nDingen die opvallen: wel in C++(11), niet in C Enkele belangrijke zaken die onmiddellijk opvallen:\n de aanwezigheid van bool los van std::string (bovenop char) en std::wstring (bovenop wchar_t), Extra Integral types:  wchar_t, char16_t, char32_t (voor Unicode)  Zelf te definiëren operaties:  scope resolutie :: en namespaces \u0026lt;\u0026lt;, \u0026gt;\u0026gt; streams  class en alles wat daar mee te maken heeft  new, delete in plaats van malloc() en free()  nullptr in plaats van NULL, smart pointers voor auto garbage collection auto als type inference zoals var in C#, decltype in plaats van typeof Exception handling  Classes in C++ Terug naar de is_oud opgave van labo 1, maar dan in C++ Het is tijd om malloc() en struct achterwege te laten:\n#include \u0026lt;iostream\u0026gt; class Persoon { private: int leeftijd; public: Persoon(int leeftijd); bool isOud() const { std::cout \u0026lt;\u0026lt; \u0026#34;checking leeftijd van persoon \u0026#34; \u0026lt;\u0026lt; leeftijd \u0026lt;\u0026lt; std::endl; return leeftijd \u0026gt; 60; } int getLeeftijd() const { return leeftijd; } }; Persoon::Persoon(int leeftijd) { this-\u0026gt;leeftijd = leeftijd; } int main() { auto jaak = new Persoon(70); std::cout \u0026lt;\u0026lt; \u0026#34;is jaak oud? \u0026#34; \u0026lt;\u0026lt; jaak-\u0026gt;isOud() \u0026lt;\u0026lt; std::endl; }  Dat ziet er al heel wat properder uit:\n We hebben een constructor gebruikt om een persoon aan te maken met leeftijd, zoals we kennen vanuit Java. De this pointer verwijst naar de huidige instance van de klasse. We hebben methodes (inline) gedeclareerd in de klasse Persoon. Jaak aanmaken hoeft geen type definitie als Persoon * met C++11\u0026rsquo;s auto keyword. Leer auto goed kennen en gebruiken: overtuig jezelf!  Type inference is in combinatie met top-level const en references niet zo triviaal, zie p.68.\nDe Klasse structuur Een klasse definiëren is niet meer dan een beschrijving van een structuur. Binnen de class accolades { } leven niet alle declaraties van de functies in de klasse zelf! Dit is nog een erfenis van C. Elke klasse heeft zijn eigen scope en functies declareren doe je na de definitie met de scope operator :::\nclass Getal { private: int getal; public: int get() const { return getal; } void telOpMet(int ander); void vermenigvuldigMet(int ander); }; void Getal::telOpMet(int ander) { this-\u0026gt;getal += ander; } void Getal::vermenigvuldigMet(int ander) { this-\u0026gt;getal *= ander; } De locatie van klassen Twee van de drie methodes staan buiten de klasse definitie. We maken hier typisch twee files voor aan:\n getal.h waar de klasse definitie in leeft getal.cpp waar de methode declaraties in leven  Verschillende andere source files kunnen de Getal klasse gebruiken met #include \u0026quot;getal.h\u0026quot;. De klasse kan maar 1x gedefiniëerd worden, en 2x de header includen in je programma geeft een compilatiefout:\n Wouters-MacBook-Air:c-course-gba wgroenev$ g++ -std=c++11 dubbel.cpp getal.o In file included from dubbel.cpp:4: ./getal.h:1:7: error: redefinition of 'Getal' class Getal { ^ ./getal.h:1:7: note: previous definition is here class Getal { ^ 1 error generated.  Dit lossen we op met een preprocessor constructie in de getal.h header file:\n#ifndef _GETAL_H_ #define _GETAL_H_  class Getal { }; #endif Circulaire dependencies Zoals in veel andere programmeertalen, kan klasse 1 wel naar klasse 2 verwijzen, maar dan niet omgekeerd. Een mooi gesloten lus maken in schemavorm noemen we een circulaire dependency: object 1 is afhankelijk van object 2, die op zijn beurt terug afhankelijk is van object 1:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph LR K1[class 1] K2[class 2] K1 -- K2 K2 -- K1q  Het is niet mogelijk om twee klassen naar elkaar te laten verwijzen door middel van een #ìnclude statement. De volgende foutboodschap schept hierin genoeg duidelijkheid:\n In file included from ./inc2.h:2: In file included from ./inc1.h:2: In file included from ./inc2.h:2: In file included from ./inc1.h:2: In file included from ./inc2.h:2: In file included from ./inc1.h:2: [...] ./inc2.h:4:7: error: redefinition of 'Inc2' class Inc2 { ^ ./inc2.h:4:7: note: previous definition is here class Inc2 { ^ fatal error: too many errors emitted, stopping now [-ferror-limit=] 20 errors generated.  Inline functies Waarom is de eerste methode in de body gedeclareerd? Dit is een inline functie (zie doc). Dit zijn typisch one-liners die vaak aangeroepen worden en door de compiler geoptimaliseerd kunnen worden: de aanroep instructie vervangen door de implementatie, zoals de preprocessor doet met #define.\nWanneer schrijven we een inline functie?\n Duidelijkheid: Als de functie zeer klein is en die in de header file kan leven zodat gebruikers hiervan ondubbelzinnig kunnen zien wat dit doet. Optimalisatie kàn ook.  In-class initialization Sinds C++ 11 kan je ook default values meegeven aan data members in de definitie van de klasse zelf. Dit klinkt belachelijk omdat zoiets in Java vanaf het begin al kon. In de private sectie van de Getal klasse kunnen we dus int getal = 5; zetten. Als er geen constructor deze member initialiseert wordt getal op 5 gezet.\n\u0026ldquo;this\u0026rdquo; en Constante functies De magische this variabele wordt impliciet aangemaakt zodra je een methode van een instantie op een klasse uitvoert. This is het adres van de locatie van diezelfde instantie:\nauto g = new Getal(); g-\u0026gt;telOpMet(5); // compiler interpretatie: Getal::telOpMet(\u0026amp;g, 5); Het const keyword achter de get methode verandert de this pointer naar een constante pointer. Op die manier kan de body van de methode geen wijzigingen doorvoeren, enkel opvragen. (Zie p. 258)\n(auto-generated) Constructoren Een klasse instantiëren roept de (default) constructor aan. Als er geen eigen gedefiniëerde constructor aanwezig is, genereert de compiler die voor u, net als in Java. Zodra je één constructor definiëert, zal C++ geen enkele zelf genereren.\nclass Getal { private: int *x; public: Getal(int x) : x(new int(x)) {} }; auto g = new Getal(5); // ok: eigen constructor aangeroepen auto g = new Getal(); // error: Too few arguments, expects 1 De default constructor is makkelijk zelf te voorzien met Getal() {} maar met Getal() = default; zeggen we tegen de compiler dat hij expliciet wél eentje moet genereren.\nMerk op dat we hier een memory leak introduceren door *x niet zelf op te kuisen! Als een klasse resources zoals pointers bevat is het de bedoeling dat deze zelf verantwoordelijk is voor de opkuis. Dit gebeurt in de destructor prefixed met ~:\nclass Getal { private: int *x; public: Getal() = default; ~Getal() { delete x; } Getal(int x) : x(new int(x)) {} }; Java heeft geen destructors omdat objecten op de heap leven en door de Garbage Collector opgeruimd worden zonder invloed van de programmeur. Er is wel een finalize die je zelf kan aanroepen om resources op te kuisen. In C# wordt ook de ~Object(){} notatie gebruikt, maar dat is ook een soort van finalizer en geen échte destructor.\nEen derde soort constructor, de \u0026ldquo;copy constructor\u0026rdquo;, wordt ook door C++ voorzien en aangeroepen wanneer de expressie getal1 = getal2 geëvalueerd wordt. De compiler maakt een nieuwe Getal instance aan en kopiëert alle velden over.\nDit is echter helemaal niet wat we willen als we resources als members hebben zoals *x: de pointer wordt gekopiëerd maar niet de inhoud. Beide getal instances verwijzen dan dezelfde x waarde:\nWat is de output van dit programma?\nint main() { auto g = new Getal(5); auto g2 = g; g2-\u0026gt;x = new int(10); cout \u0026lt;\u0026lt; *(g2-\u0026gt;x) \u0026lt;\u0026lt; endl; // ?  cout \u0026lt;\u0026lt; *(g-\u0026gt;x) \u0026lt;\u0026lt; endl; // ? } Oeps. Voorzie in dat geval je eigen copy constructor met Getal(const Getal\u0026amp; other) : x(new int(*(other.x))) {}. Copy constructors kan je ook defaulten.\nMethodes in Klassen en Reference types Herinner je uit labo 2 reference type definities zoals int \u0026amp;getal. Deze notatie ga je veel tegen komen in C++ methode argumenten. Objecten die meegegeven worden zijn bijna altijd reference types in plaats van pointers. Waarom legt de C++ FAQ uit:\n Use references when you can, and pointers when you have to. References are usually preferred over pointers whenever you don’t need “reseating”. This usually means that references are most useful in a class’s public interface. References typically appear on the skin of an object, and pointers on the inside.\n Zo kunnen we in Getal methodes toevoegen die andere Getal instanties gebruiken:\n// getal.h class Getal { void telOpMet(const Getal \u0026amp;ander); } // getal.cpp void Getal::telOpMet(const Getal \u0026amp;ander) { this-\u0026gt;getal += ander.getal; } // dubbel.cpp, in main auto g = new Getal(); auto nieuwGetal = new Getal(); nieuwGetal-\u0026gt;telOpMet(*g); We moeten g dereferencen om als reference mee te kunnen geven. const wordt hier gebruikt om zeker te zijn dat het binnenkomende getal niet gewijzigd kan worden. Alternatief kunnen we new twee keer weglaten: auto g = Getal(); en dan nieuwGetal.telOpMet(g);.\nWanneer gebruik ik \u0026ldquo;new\u0026rdquo; en wanneer niet? Een pointer naar een object in het geheugen aanmaken (en geheugen reserveren) met new vereist dat je die zelf opkuist met delete! Als je dit niet doet blijft dat geheugen bezet en krijg je wat men noemt \u0026ldquo;memory leaks\u0026rdquo;: hoe langer men je programma gebruikt, hoe meer geheugen het (ongewenst) in beslag neemt.\nOm dat te vermijden gebruik je best binnen functies nooit new:\nvoid telOpAutoClean() { auto g = Getal(3); g.telOpMet(5); // block eindigt: g wordt opgekuist } void telOpManualClean() { auto g = new Getal(5); g-\u0026gt;telOpMet(5); // block eindigt: g blijft bestaan!  delete g; } Getal(3) zonder new ziet er vreemd uit als je talen als C# en Java gewoon bent, maar de constructor wordt evenzeer aangeroepen en een object wordt evenzeer voor je geïnstantieerd.\nDe Stack Lokale variabelen worden op de stack bewaard. De stack bevat een tijdelijke workspace aan geheugen wanneer functies aangeroepen worden, die automatisch opgeruimd worden als die functies klaar zijn met hun werk. De Stack is een LIFO lijst.\nDe Heap De heap is geheugen dat opzij gezet wordt voor dynamische allocatie. Zodra je een pointer aanmaakt komt dit op de heap terecht en ben je zelf verantwoordelijk voor het opruimen hiervan. In Java zijn instance variabelen en objecten deel van de heap, in C++ is dat wat complexer.\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; subgraph De Stack D[Getal ptr_getal = new Getal] C[Getal getal = Getal] A[int main] B[void telOp] B -- A C -- B D -- B end subgraph De Heap E[Getal geheugen] D -.- E end  Het adres in ptr_getal leeft op de stack binnen de telOp() methode, maar het geheugen waar het naar verwijst leeft op de heap. Het adres verdwijnt als alles van telOp weggegooid wordt in de stack - maar het getal geheugen blijft bestaan totdat iemand met delete de opkuis doet.\nDe dotted pijl van ptr_getal naar getal in de heap verdwijnt en is nooit meer toegankelijk: dit noemt men \u0026ldquo;leaking\u0026rdquo;. Moderne C++ programma\u0026rsquo;s maken zelden gebruik van \u0026ldquo;raw pointers\u0026rdquo; (*) en laten de compiler en het OS beslissen of zaken op de stack of de heap moeten komen.\nSmart pointers in C++ 11 In plaats van zelf geheugen te managen - we hebben immers wel wat beters te doen - laten we dat over aan de taal door \u0026ldquo;smart pointers\u0026rdquo; te gebruiken. Dit zijn STL wrappers (zie onder) die een object encapsuleren. Als een block stopt, kuist deze smart variabele je wrapped object zelf ook op:\nunique_ptr\u0026lt;Getal\u0026gt; g (new Getal()); // zonder auto auto nieuwGetal = unique_ptr\u0026lt;Getal\u0026gt;(new Getal()); // met auto nieuwGetal-\u0026gt;telOpMet(*g); We komen later nog op de template \u0026lt;\u0026gt; notatie terug. Neem hier aan dat dit werkt als Generics in Java.\nZie p.470 of Smart pointers in modern C++.\nVergeet niet dat smart pointers niet werken in combinatie met variabelen op de stack (dus altijd new gebruiken). Stel dat een klasse een referentie naar een unique_ptr heeft die automatisch de pointer zou moeten opkuisen:\nclass Holder { public: unique_ptr\u0026lt;Iets\u0026gt; autoDeleted; Holder() { Iets iets(\u0026#34;1\u0026#34;); this-\u0026gt;autoDeleted = unique_ptr\u0026lt;Iets\u0026gt;(\u0026amp;iets); } } De deconstrutor van de holder gaat automatisch de waarde die autoDeleted vasthoudt terug vrijgeven, maar de variabele iets bestaat al niet meer omdat die enkel op de stack binnen de constructor functie leeft. \u0026amp;iets verwijst nu naar \u0026ldquo;niks\u0026rdquo; en dit crasht.\nDe C++ Standard Library Merk op dat in bovenstaande Persoon klasse printf() verdwenen is. In C++ gebruiken we streams: cout als stdout en cin als stdin. Deze leven in de std namespace zodra je iostream include. Laat de \u0026ldquo;.h\u0026rdquo; suffix achterwege bij het includen van systeembibliotheken van C++. Laat het maar aan de compiler over om de systeembestanden te zoeken tijdens het linken.\nDe Standard Template Library STL is een bibliotheek die meegeleverd wordt bij de meeste moderne C++ compilers waar iostream in leeft. Deze implementeert de nieuwe standaarden, zoals C++11. Compilers vragen soms wel een flag om te kiezen met welke library er gelinkt wordt: g++ -std=c++11.\nSTL bevat een hoop dingen die je het leven makkelijker maakt: strings (gek genoeg nog steeds geen deel van de taal zelf), collecties, streams, IO, \u0026hellip; Bekijk het als de .NET library voor de C# taal of de meegebakken java.* klassen en methodes voor Java. \u0026ldquo;Part II: The C++ Library (p. 307)\u0026rdquo; behandelt deze zaken in het handboek.\nIn plaats van constant std::cout te moeten typen kunnen we alles wat in die namespace zit ook \u0026ldquo;importeren\u0026rdquo; zoals een Java import java.io.* met using namespace std;. cout is een instantie van de klasse ostream.\nInitialisatie van objecten In C++ kan je op twee manieren aan objecten een waarde toekennen (Zie p.43). Het is belangrijk om de verschillende nuances te kunnen onderscheiden omdat met objecten verschillende constructoren gemoeid zijn.\nDirect initialization int x(5) of Getal g(5)\nHiervoor is een constructor (met argument) nodig.\nWaarom zou je () doen in plaats van =? Omdat impliciete conversie enkel via direct initialization gebeurt. Stel, ik wil een string in de constructor aanvaarden. Strings met quotes in C++ zijn nog steeds char arrays vanuit C. Dit gaat niet:\n// C++ class Groet { public: Groet(std::string s) {} void zegIets() {}; }; Groet heykes = \u0026#34;sup\u0026#34;; // error: no conversion from const char[3] to Groet Groet heykes(\u0026#34;sup\u0026#34;): // ok: impliciete conversie Groet hekyes = \u0026#34;sup\u0026#34;s; // ok: char[] zelf omgezet, zie strings sectie Groet heykes; // ok: heykes is nieuw leeg Groet object op stack heykes.zegIets(); // ok Vergeet niet dat het verschil tussen C++ en Java op gebied van initialisatie groot is! In Java zijn objecten na hun declaratie altijd null:\n// Java class Groet { public Groet(String s) {} public void zegIets() {} } Groet heykes(\u0026#34;sup\u0026#34;); // error: impliciete conversie gaat nooit lukken Groet heykes; // ok: heykes verwijst naar null heykes.zegIets(); // error: NullPointerException heykes = new Groet(); // ok: object op heap aangemaakt heykes.zegIets(); // ok Copy initialization int x = 5 of Getal g = Getal(5) of int x = { 5 }\nHiervoor is een copy constructor nodig.\nMerk op dat gebruik van accolades { } eigenlijk copy initialisatie doorvoert, evenals single return statements als return 3 + 4. Dit kan je omzetten naar direct initialization met int retval(3 + 4); return retval;.\nConstructors en copy constructors hoeven niet zelf aangemaakt te worden: C++ voorziet defaults. Een lege constructor maakt een leeg object aan. Een lege copy constructor voert eenm ember-wise (shallow) copy door. Als je die toch wil maken doe je dat zo:\nclass Punt { private: int x, y; public: Punt() : x(1), y(1) { } // default  Punt(const Punt\u0026amp; other) : x(other.x), y(other.y) { } // copy } Strings std::string in #include \u0026lt;string\u0026gt; is de vervanger van de rudimentaire char* in C++. Met strings kan je zoals in Java dingen doen als:\n Grootte opvragen met .size() of .empty() Concatenaties doorvoeren met de + operator Karakters opvragen met [] Vergelijkingen uitvoeren met \u0026lt;(=), \u0026gt;(=)  De grootte van een strings is niet een int maar een std::size_type \u0026ldquo;companion type\u0026rdquo; om STL op eender welke machine op dezelfde manier te kunnen gebruiken (p.88). Dat is een van de nadelen van C(++) doordat we voor een specifiek systeem compileren.\nKarakters individueel behandelen Gebruik de C++ 11 range for notatie die we van C# en Java kennen:\nauto str = string(\u0026#34;sup\u0026#34;); for(auto c : str) { cout \u0026lt;\u0026lt; c; } Als c een reference is kan je in de loop zelf de karakters ook wijzigen.\nCollecties: Vector In plaats van met vaste array waardes te werken kunnen we ook lijsten gebruiken. STL voorziet er een aantal, waarvan vector de belangrijkste is - Java\u0026rsquo;s ArrayList tegenhanger. Vanaf C++ 11 kan je die ook snel initialiseren met copy initialization:\nvector\u0026lt;string\u0026gt; tekst = { \u0026#34;roe\u0026#34;, \u0026#34;koe\u0026#34;, \u0026#34;zei\u0026#34;, \u0026#34;de\u0026#34;, \u0026#34;duif\u0026#34; }; // lijst van 5 strings vector\u0026lt;string\u0026gt; leeg; // lege lijst van strings, grootte 9 tekst = leeg; // copy constructor gebruikt; tekst is nu ook leeg tekst[0] = \u0026#34;nul\u0026#34;; // segmentation fault: tekst heeft size 0 tekst = vector\u0026lt;string\u0026gt;(1); // lege lijst van strings, grootte 1 tekst[0] = \u0026#34;nul\u0026#34;; // ok p.98 of cppdocs bevat basis manipulaties voor vectoren, zoals:\n elementen toevoegen met push_back() loopen over elementen met for(auto i : v) grootte controleren met size() en empty() zoals std::string correct gebruik van iterators begin() en end()  Labo oefeningen  bibliothecaris labo 2 redux: herimplementeer de bibliothecaris oefening in C++. Let op de verplichte aanwezigheid van:  een klasse Bibliotheek die een lijst van boeken (als simpele string) bevat een klasse Bibliothecaris die de operaties op de bibliotheek uitvoert cin \u0026gt;\u0026gt; var om de boeken van de gebruiker in te lezen. sorteerfuncties van STL  GBA games worden vanwege het beperkt geheugen altijd in C in plaats van C++ ontwikkeld. Wij gaan daar geen rekening mee houden, en toch overschakelen. Herimplementeer deze Download, de opgave van labo 4, in C++. Welke klasses heb je nodig? Denk aan de paddle, de ball, enzovoort. De C++ nodige cross-compiler is arm-none-eabi-g++. Extra: maak een Dierentuin klasse. Een dierentuin kan verschillende dieren (Dier klasse) ontvangen (ontvang() functie). Elk dier heeft een grootte en een naam: Neushoorn(40), Giraf(25), Poema(10). Elke dierentuin heeft x beschikbare ruimte. Wat doet het bestuur van je dierentuin als het te ontvangen dier te groot is? Bijvoorbeeld: dierentuin(20), leeuw(15) en panda(10). 15 + 10 \u0026gt; 20. Extra: We starten met een taxi bedrijf dat chauffeurs in dienst neemt en wagens koopt om mee rond te rijden. Welke klassen denk je nodig te gaan hebben, en waarom? Teken eerst een model en trek pijlen die relaties voorstellen. Voorzie ook het concept \u0026ldquo;klant\u0026rdquo;, die kan vervoerd worden. Welke methodes ga je voorzien in je klassen? Extra: Orc labo 1 redux: herimplementeer het Orc model in een C++ klasse (opgave 2 en 3). Let op met memory leaks als orcs dood gaan! Hoe ziet de oude C functie Orc vecht(Orc aanvaller, Orc verdediger) er nu uit?  Vergeet het volgende niet:\n C++ Style Guide te volgen en gebruik camelCasing voor C++ in plaats van snake casing voor C! C++ online compileren kan op rextester.com. C++ Style and Technique FAQ  Denkvragen  Kan je je een situatie inbeelden waarin het gebruik van raw pointers in een methode van een klasse toch aangewezen is? Wat is het fundamenteel verschil tussen een struct in C en een class in C++? Wat betekent de foutboodschap \u0026ldquo;Segmentation fault\u0026rdquo; precies? Wanneer wordt een copy constructor aangeroepen? Leg aan de hand daarvan het verschil tussen initialisatie en toekenning uit.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/cpp/labo-6/",
	"title": "Labo 6: C++ Class Inheritance, operators en templates",
	"tags": [],
	"description": "",
	"content": " C++ Classes revisited Nu je een basis van klassen hebt opgedaan in C++ gaan we erving introduceren. Gegeven de volgende modellen:\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[Dier] B[Viervoeter] C[Hond] D[Kat] E[Vlinder] F[Vlees] G[Groenten] H[Voedsel] B -- A C -- B D -- B E -- A F -- H G -- H  Gegeven de volgende acceptatie criteria:\n Elk dier kan een aantal centimeter bewegen.  Bij viervoeten hangt dit van de snelheid van het dier af in combinatie met het aantal poten. Een kat beweegt sneller dan een hond maar is na 2x moe. Een vlinder beweegt liniair met de grootte van zijn vleugels.  Elk dier eet voedsel.  Een hond eet alles. Een kat eet enkel vlees. Een vlinder eet enkel groenten.   Een voorbeeldimplementatie in Java zou dit kunnen zijn:\npublic abstract class Voedsel { } public class Vlees extends Voedsel { } public class Groenten extends Voedsel { } public abstract class Dier { public abstract boolean kanEten(Voedsel voedsel); public abstract int beweeg(); } public abstract class Viervoeter extends Dier { protected int aantalPoten = 4; } public class Hond extends Viervoeter { @Override public boolean kanEten(Voedsel voedsel) { return true; } @Override public int beweeg() { return 10 * aantalPoten; } } public class Kat extends Viervoeter { private int aantalKeerBewogen; @Override public boolean kanEten(Voedsel voedsel) { return voedsel instanceof Vlees; } @Override public int beweeg() { aantalKeerBewogen++; int velocity = aantalKeerBewogen \u0026gt;= 2 ? 5 : 15; return velocity * aantalPoten; } } public class Vlinder extends Dier { private int vleugelGrootte = 4; @Override public boolean kanEten(Voedsel voedsel) { return voedsel instanceof Groenten; } @Override public int beweeg() { return 2 * vleugelGrootte; } } De noties van abstract, de @Override annotatie en access modifiers bestaan natuurlijk ook in C++ - zie hoofdstuk 15. Bovenstaande Java code omgezet naar C++:\nclass Voedsel { public: virtual int voedingswaarde() = 0; }; class Vlees : public Voedsel { int voedingswaarde() override { return 10; } }; class Groenten : public Voedsel { int voedingswaarde() override { return 15; } }; class Dier { public: virtual bool kanEten(const Voedsel\u0026amp; voedsel) = 0; virtual int beweeg() = 0; }; class Viervoeter : public Dier { protected: int aantalPoten; public: Viervoeter() : aantalPoten(4) {} }; class Hond : public Viervoeter { public: int beweeg() override { return 10 * aantalPoten; } bool kanEten(const Voedsel \u0026amp;voedsel) override { return true; } }; class Kat : Viervoeter { private: int aantalKeerBewogen; public: bool kanEten(const Voedsel \u0026amp;voedsel) override { return typeid(voedsel) == typeid(Vlees); } int beweeg() override { aantalKeerBewogen++; int velocity = aantalKeerBewogen \u0026gt;= 2 ? 5 : 15; return velocity * aantalPoten; } }; class Vlinder : Dier { private: int vleugelGrootte; public: Vlinder() : vleugelGrootte(4) {} private: bool kanEten(const Voedsel \u0026amp;voedsel) override { return typeid(voedsel) == typeid(Groenten); } int beweeg() override { return 2 * vleugelGrootte; } }; typeid() leeft in de \u0026lt;typeinfo\u0026gt; header. Een alternatief is dynamische pointers casten (zie onder). Voor de rest zijn de grootste verschillen - buiten de syntax:\n C++11\u0026rsquo;s override na een methode wordt ook door de compiler gebruikt om te controleren of wat je override wel een virtuele methode is. In Java is @Override enkel ter documentatie. abstract op een klasse bestaat niet. Daarvoor moet je een \u0026ldquo;pure virtuele methode\u0026rdquo; (= 0) aanmaken. Access modifiers bij een te overerven klasse beslissen of de methodes van die superklasse publiek zijn of niet. Dit bestaat niet in Java. Methodes die je overschrijfbaar wil maken moet je prefixen met virtual. In Java zijn alle methodes virtual.  Als je de access modifiers in de klasse definitie vergeet wordt private aangehouden. Voor een struct is dit standaard public.\nWat is de output van het volgende programma?\nint main() { Groenten g; // vergeet niet dat dit in Java null zou zijn.  Vlees v; Kat k; std::cout \u0026lt;\u0026lt; \u0026#34;kan een kat groenten eten? \u0026#34; \u0026lt;\u0026lt; k.kanEten(g); std::cout \u0026lt;\u0026lt; \u0026#34;kan een kat vlees eten? \u0026#34; \u0026lt;\u0026lt; k.kanEten(v); } En wat is de output van Dier d;? Juist: error: variable type \u0026lsquo;Dier\u0026rsquo; is an abstract class.\nExtra Flexibiliteit  Gebruik final als suffix als een subklasse deze virtuele methode niet meer mag overschrijven. Kan op klasse of methode niveau. Gebruik de :: operator als je toch een virtual base methode wil aanspreken die reeds overschreven is: kat.Dier::iets() waarbij iets zowel op Kat als op Dier gedefiniëerd is. Gebruik friend als prefix om een klasse instantie toegang te geven tot private fields van de andere. Kan op klasse of methode niveau. Zie InternalsVisibleTo C# AssemblyInfo. Gebruik using Base::member als prefix om bepaalde members toch public access te geven als alles als private gedeclareerd is.  De method shadowing regels volgen ongeveer dezelfde als die van Java: een non-virtual functie met dezelfde naam en argumenten kan een functie hiden van een superklasse.\nExtra (ongewenste) flexibiliteit: static VS dynamic binding Kijk eens goed naar het volgende voorbeeld:\nclass A { public: virtual int a() { return 3; } }; class B : public A { public: int a() { return 5; } }; int main() { A b = B(); std::cout \u0026lt;\u0026lt; b.a() \u0026lt;\u0026lt; std::endl; } Wat is de output? 3, en niet 5, ook al is het type van b een instantie van klasse B. Huh? Calls naar virtuele functies kunnen at run-time resolved worden, maar dat \u0026ldquo;hoeft\u0026rdquo; niet (zie p.604). De enige uitzondering hier is het gebruik van pointers: met A* b = new B(); geeft b-\u0026gt;a() wél 5 terug.\ntypeid(b).name() blijft \u0026ldquo;1A\u0026rdquo; teruggeven omdat de variabele als type A gedeclareerd is.\nUpcasten en downcasten C++ voorziet een hele resem aan cast methodes die in het licht van klassen en subklassen nodig kunnen zijn:\n dynamic_cast\u0026lt;T\u0026gt;(t): downcaster in gebruik. Geeft nullptr terug indien niet gelukt. Dit is Java\u0026rsquo;s aangenomen instanceof manier. static_cast\u0026lt;T\u0026gt;(t): impliciete conversie ongedaan maken (zie elders). Als je bijvoorbeeld weet dat een void* eigenlijk een Punt* is.Dit kan fouten at compiletime geven. reinterpret_cast\u0026lt;T\u0026gt;(t): pointer conversies in lijn van C. Dit kan fouten at runtime geven. const_cast\u0026lt;T\u0026gt;(t): verwijdert of voegt const speficier toe.  De C-style cast (Punt*) pt wordt aanzien als bad practice in de C++ wereld.\nOperatoren en klassen mixen C++ biedt zoals verwacht zelfs op operator niveau flexibiliteit: je kan je eigen operatoren implementeren in klassen (p.552). Op die manier kan je bijvoorbeeld twee 2D punten met elkaar optellen: punt1 + punt2. In Java zal je een methode moeten maken: punt1.plus(punt2) dat een nieuw punt teruggeeft.\nAlle mogelijke operatoren kunnen overloaded worden, behalve ::, .*, . en ?:. Dit brengt ook potentiële problemen met zich mee! Stel je voor dat -\u0026gt; overloaded is en je klasse zich heel anders gedraagt dan een standaard pointer reference. With great power comes great responsibility\u0026hellip;\nEen voorbeeld:\nusing namespace std; class Punt { private: int x, y; public: Punt(int theX, int theY) : x(theX), y(theY) {} Punt operator +(const Punt\u0026amp; other) { return Punt(x + other.x, y + other.y); } friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, Punt punt); }; ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, Punt punt) { os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; punt.x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; punt.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return os; } int main() { Punt a(1, 2); Punt b(3, 4); cout \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; // print (4,6) } Operators kan je ook rechtstreeks aanroepen met punt.operator+(other). Ze zijn niet verplicht om member te zijn van de klasse zelf maar ik zie geen reden om dingen die samen te horen niet samen te zetten. Een duidelijke uitzondering zijn IO operators! (p.557)\nAndere veelgebruikte operatoren:\n \u0026lt;\u0026lt; als toString() in Java naar stdout. == als equals() in Java. Vergeet niet != ook te implementeren dan! = als in-assignment om { } te gebruiken. [] als lijst-accessor.  Conversion operators Een conversie tussen twee types gebeurt impliciet als de compiler een match kan vinden. Je kan de compiler een handje helpen door er zelf in je klasse bij te definiëren: operator int() (zonder return type). Vanaf dan compileert Punt p; p + 5; in combinatie met de plus operator!\nImpliciete conversies zijn niet altijd wenselijk, daarvoor dient de prefix explicit (ook toepasbaar op constructoren). Expliciete conversies doe je zelf met static_cast\u0026lt;int\u0026gt;(p) - gegeven dat de operator geïmplementeerd is natuurlijk.\nTemplating: \u0026ldquo;generics\u0026rdquo; Herinner je de STL vector klasse. Deze collectie kan integers opslaan, of Punt instances, door tussen \u0026lt;\u0026gt; een type mee te geven: vector\u0026lt;Punt\u0026gt; punten;. Er is een template voor gedefiniëerd. Stel dat ik de punt klasse wens uit te breiden met de mogelijkheid niet alleen integers maar ook doubles als coordinaten te gebruiken:\ntemplate\u0026lt;typename T\u0026gt; class Punt { private: T x, y; public: Punt(T theX, T theY) : x(theX), y(theY) {} }; Punt\u0026lt;double\u0026gt; pt(1.2, 3.4); Punt\u0026lt;int\u0026gt; pt2(3, 5); Templates kunnen ook op functie niveau gedefiniëerd worden, als losstaande functie en als deel van een klasse genaamd member templates. (p.672)\nHercompilatie van templates De C++ compiler maakt voor elk template argument in je code (hier double en int) een aparte versie van de Punt klasse. In Java wordt dat weggecompileerd en dienen generics enkel als syntaxtisch hulpmiddel. Dit heeft wel als negatief gevolg dat de binary erg groot kan worden als die vol zit met duplicate versies van Punt!\nEr zijn mogelijkheden tot compiler- en objectoptimalisatie met het keyword extern. Aanschouw het volgende schema met bijhorende code:\n// header.h #ifndef _header_h #define _header_h template\u0026lt;typename T\u0026gt; T punt(T t) { return t; } #endif // source1.cpp #include \u0026#34;header.h\u0026#34;void punt1() { auto pt = punt\u0026lt;int\u0026gt;(5); // template\u0026lt;int\u0026gt; compiled } // source2.cpp #include \u0026#34;header.h\u0026#34;void punt2() { auto pt = punt\u0026lt;int\u0026gt;(4); // template\u0026lt;int\u0026gt; compiled - opnieuw!! } mermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; subgraph source code H[header.h template definitie van Punt] A[source1.cpp gebruik Punt van int] B[source2.cpp gebruik Punt van int] A -- H B -- H end subgraph object output O[source1.o compilatie Punt van int] P[source1.o compilatie Punt van int] end  Als we een source file compileren én proberen te linken vinden we geen main() functie:\n Wouters-MacBook-Air:cmake-build-debug wgroenev$ g++ -std=c++11 source1.cpp Undefined symbols for architecture x86_64: \"_main\", referenced from: implicit entry/start for main executable ld: symbol(s) not found for architecture x86_64 clang: error: linker command failed with exit code 1 (use -v to see invocation)  Vergeet de -c optie dus niet. Door de symbol table van de machine code van source1.o te inspecteren krijgen we inzicht in de zonet gecompileerde bytes. Op Unix kan dit met nm:\n Wouters-MacBook-Air:cmake-build-debug wgroenev$ nm source1.o | c++filt 0000000000000070 short EH_frame0 0000000000000020 S int punt(int) 00000000000000b0 S int punt(int) (.eh) 0000000000000000 T punt1() 0000000000000088 S punt1() (.eh)  Je ziet op adres 00000000000000b0 de nieuwe functie die als \u0026lt;int\u0026gt; gecompileerd is. Dit zit dubbel en ook in source2.cpp! Dit lossen we op door in één van de twee cpp bestanden extern template int punt(int x); toe te voegen zodat de compiler dit niet opnieuw behandelt:\n Wouters-MacBook-Air:cmake-build-debug wgroenev$ nm source1.o | c++filt 0000000000000040 short EH_frame0 U int punt(int) 0000000000000000 T punt1() 0000000000000058 S punt1() (.eh)  De U duidt aan dat dit een onbekende functie is die naderhand (hopelijk) gelinkt zal worden en binnen een ander object leeft. Lees meer over interessante object files en symbolen. In de praktijk geldt dit ook voor STL klassen als vector\u0026lt;int\u0026gt;: externals worden meestal in een gedeelde header file geplaatst.\nOmdat een Punt\u0026lt;double\u0026gt; dus een andere klasse is dan een Punt\u0026lt;int\u0026gt; zijn ze niet compatibel met elkaar: het zijn twee unieke klassen. Dit is het grootste verschil tussen Templates in C++ en Generics in Java. De notatie \u0026lt;T extends BaseClass\u0026gt; is hierdoor niet nodig (maar kan wel met enable_if).\nHerdeclaratie van templates De constructor - of eender welke methode met T buiten de klasse template definiëren betekent dat we de template notatie zullen moeten herhalen want de compiler weet dan niet meer wat die T precies is:\n// in punt.h template\u0026lt;typename T\u0026gt; class Punt { Punt(T theX, T theY); } // in punt.cpp template\u0026lt;typename T\u0026gt; Punt\u0026lt;T\u0026gt;::Punt(T theX, T theY) : x(theX), y(theY) { } Type en non-type arguments typename staat voor \u0026ldquo;dit is type T\u0026rdquo; en kan eender welk type zijn. Een constante expressie zoals 5 of een string \u0026quot;hallo\u0026quot; aanvaarden gaat zo ook: dat zijn immers ook types.\nConstante expressies met unsigned in de template definitie kunnen pointers, value references of integrale types zijn. In ons voorbeeld is het niet aangewezen om dit toe te passen: Punt\u0026lt;3, 4\u0026gt; pt; slaat enkel op iets als dit punt nooit kan muteren.\nHerhaling vermijden met typedef Kan op twee manieren:\n typedef Punt\u0026lt;int\u0026gt; iPunt;: iPunt p; template\u0026lt;typename T\u0026gt; using pt = Punt\u0026lt;T\u0026gt;;: pt\u0026lt;int\u0026gt; p;  Waarbij optie twee meestal gebruikt wordt om verschillende template types te linken: nu heeft dit niet bijzonder veel nut. typedef kan niet refereren naar een template type.\nTemplate default arguments Als ik een template type wil van een klasse aangeven, maar dit in 80% van de gevallen een int gaat zijn kan ik deze defaulten:\ntemplate\u0026lt;typename T = int\u0026gt; class Punt; Punt\u0026lt;\u0026gt; pt; // \u0026lt;\u0026gt; nog steeds verplicht. Zonder \u0026lt;\u0026gt; krijg je \u0026ldquo;error: use of class template \u0026lsquo;Punt\u0026rsquo; requires template arguments\u0026rdquo;.\nVoor functies probeert de compiler automatisch het type te deduceren gebaseerd op het meegegeven argument (p.678). Dat wil zeggen dat we het type niet moeten meegeven en ook niet hoeven te defaulten:\ntemplate\u0026lt;typename T\u0026gt; T puntFn(T t) { return t; } int pt = puntFn\u0026lt;int\u0026gt;(5); // geldig int pt = puntFn(5); // ook geldig! auto pt = puntFn(5); // ook geldig! Template variable arguments: packs Wat nu als je verschillende argumenten nodig hebt die allemaal verschillende types hebben, waarvan je het type niet op voorhand weet? De altijd-aanwezige flexibiliteit in C++ lost dit probleem even voor je op met variadic templates:\ntemplate \u0026lt;typename... Ts\u0026gt; void som(Ts... args) {} Dankzij compiler deductie hoeven we niet alle templates aan te vullen als we het aanroepen: som(1, 2.0, true); zou hetzelfde zijn als som\u0026lt;int, double, bool\u0026gt;(1, 2.0, true);. Om dit voorbeld te laten werken hebben we echter recursie nodig: een functie voor een basisgeval, en een functie voor de rest. Daarom heet dit \u0026ldquo;packing\u0026rdquo; en is ... het unpacken van de template arguments.\ntemplate\u0026lt;typename T\u0026gt; T som(T t) { return t; } template\u0026lt;typename T, typename... TRest\u0026gt; T som(T first, TRest... args) { return first + som(args...); } auto result = som(1, 2.0, 3); Zie docs.\nLabo oefeningen  Implementeer de volgende business criteria. Werk eerst een snel model uit op papier. Elke schuin gedrukte term verwacht ik terug te zien als een klasse of methode:  Een vacature bevat een onderwerp, een lijst van vereisten in de vorm van diploma\u0026rsquo;s. Een sollicitant heeft een naam en ook diploma\u0026rsquo;s: een universitair heeft een bepaald diploma en een doctor een andere. Een sollicitant kan solliciteren op een bepaalde vacature. Hij komt in aanmerking of niet (bool is OK), gebaseerd op de matchende diploma\u0026rsquo;s. We hebben een manier nodig om het aantal sollicitanten van een vacature op te vragen (naar stdout). We hebben een manier nodig om voor elke sollicitant snel zijn gegevens (naam en aantal diploma\u0026rsquo;s) af te drukken.  Breid de Punt klasse uit met de volgende vereisten:  Er kunnen 2D of 3D punten bestaan De punten kunnen gehele of rationale getallen bevatten. Ik kan punten converteren van 2D naar 3D of omgekeerd (met verlies) Ik kan punten met elkaar optellen.  Extra: Denk terug aan je dierentuin van labo 5. Dieren moeten gevoed worden met de bool voeder(const Voedsel \u0026amp;voedsel) methode op dierentuin. De functie geeft TRUE terug indien het voedsel voldoende is voor alle dieren en FALSE indien het onvoldoende is. Voedsel heeft een voedingswaarde. Elk dier eet even veel in voedingswaarde als zijn gewicht. Verzin voedsel subklassen om alle edge cases te kunnen testen! Extra: Dieren zijn carnivoren, herbivoren of omnivoren. Voedsel is ofwel plant- ofwel vleesgebaseerd. Wat doe je als je een carnivoor sla geeft, of een herbivoor een stukje kip? Hoe implementeer je deze specificaties? Extra: Dieren zijn allergisch aan bepaald voedsel. Wat doe je als je een dier eten geeft dat het niet verdraagd? Wat doe je in je voeder() implementatie? Voorzie een methode bool isAllergischAan(const Voedsel \u0026amp;voedsel) in je Dier klasse.  Tips: denk aan het thema: subklassen, operators, templates.\nDenkvragen  Welke operatoren buiten -\u0026gt; overload je best niet, en waarom? Geef een voorbeeld. Hoe kan je Punt uitbreiden tot X dimensies? Wat is het fundamentele verschil tussen Generics in Java en Templates in C++? Wat is polymorfisme in je eigen woorden? Hoe pas je dit toe in C++?  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/cpp/labo-7/",
	"title": "Labo 7: Software ontwerpen",
	"tags": [],
	"description": "",
	"content": " Een programmeertaal als C++ leren vereist het achteroverslaan van heel wat syntaxtische cryptologie als decltype(), template\u0026lt;typename T\u0026gt; en *(x-\u0026gt;o). Met programmeren alleen kom je er echter niet: software ontwerpen vereist heel wat meer inzicht dan de juiste code op de juiste plaats typen.\nSoftware Modelleren Als software ontwikkelaar ben jij de uitvoerende kracht die vereisten van de klant implementeert in het software systeem. Een analist staat tussen de klant en de ontwikkelaar in die de vertaalslag tussen de grillen van klanten en vereisten in de vorm van business regels maakt.\nHet is onze taak als ontwikkelaar om die regels met succes te verwerken in de code. Een software ontwikkelteam bestaat uit meer dan één ontwikkelaar, daarom is het belangrijk dat alles op een uniforme manier geïmplementeerd wordt. Collega\u0026rsquo;s moeten eenvoudig concepten kunnen localiseren. De source files veranderen immers dagelijks, vaak jaren aan één stuk.\nBusiness rules analyseren Een analyse document van software uit de interimsector zou er zo kunnen uit zien:\n STR006. Gebruikers kiezen zelf het werknemernummer Beschrijving: Als een uitzendkracht over 2 werknemernummers beschikt voor één statuut (statuut is 2x toegevoegd aan de persoonsfiche) dan kan de gebruiker zelf kiezen welk werknemernummer gebruikt moet worden op het contract in kwestie zodat het systeem geen blokkerende melding geeft bij het berekenen van de lonen Context: (meer achtergrond informatie ...) Acceptatiecriteria: - Achter de waarde die nu getoond wordt in het veld statuut op een contract wordt tussen haakjes het werknemernummer toegevoegd dat gekoppeld is aan deze persoon in dit statuut - Wanneer een gebruiker 2x hetzelfde statuut heeft toegevoegd aan zijn persoonsfiche, dan wordt dit statuut 2x getoond in het lijstje met statuten bij de aanmaak van een contract - Bij het kopiëren van het contract wordt het werknemernummer overgenomen van het broncontract - ...  Het is jouw taak als ontwikkelaar om dit document te bestuderen en de criteria te vertalen naar concrete code. Welke aspecten zijn hierin van groot belang?\n Entiteiten: belangrijke concepten die herhaaldelijk terugkomen in de criteria zijn opmerkelijk genoeg om hun eigen klasse te verdienen. Relaties tussen entiteiten. Die bepalen of object#1 in object#2 leeft of andersom, of object#3 een collectie van object#2 heeft, \u0026hellip; Acties tussen entiteiten. Welke mogelijkheden zijn er?  Welke entiteiten leiden we af uit bovenstaande analyse?\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[Statuut] B[Werknemer] C[Contract]  Als woorden als \u0026ldquo;werknemer\u0026rdquo; en \u0026ldquo;persoon\u0026rdquo; (\u0026ldquo;persoonsfiche\u0026rdquo;) door elkaar gebruikt worden zal je de analist hierop moeten aanspreken en dit uitklaren. Iedereen moet bij het woord \u0026ldquo;werknemer\u0026rdquo; onmiddellijk aan hetzelfde denken.\nWelke relaties hebben de entiteiten?\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[Statuut] B[Werknemer] C[Contract] B --|heeft meerdere|A C --|is voor een|B C --|in context van één|A  Welke acties kan men met de entiteiten uitvoeren?\nmermaid.initialize({ startOnLoad: true, flowchart: { useMaxWidth: true } });  graph TD; A[Statuut] B[Werknemer] C[Contract] D{Kopiëren} E{Aanmaken} F{Koppelen aan} C -- E C -- D B -- E A -- E A -- F F -.- B  Gegeven bovenstaande modellen extraheren we de volgende C++ klassen definities en methodes:\nclass Statuut { public: Statuut(); } class Werknemer { private: std::vector\u0026lt;Statuut\u0026gt; statuten; int nummer; public: Werknemer(); void koppelAan(const Statuut\u0026amp; statuut); } class Contract { public: Contract(); Contract Kopieer() {} } Software Onderhouden Productie code leeft véél langer dan je gemiddeld project op de universiteit, afhankelijk van de sector en de grootte van het project. Het kan goed zijn dat er nog 10 jaar lang verder gewerkt wordt aan één pakket. Dat betekent dat het van enorm belang is om ordelijk en doordacht tewerk te gaan.\nBesef dat doorheen de jaren compilers komen en gaan en standaarden komen en gaan. C++11 is van 2011 geleden, De C++17 standaard introduceert weer een hele hoop nieuwigheden, en C++20 is onderweg, die we niet gaan behandelen maar misschien wel in dat project kunnen toegevoegd worden.\nFlexibiliteit naar onderhoud toe is belangrijk voor de succes van een project op lange termijn.\nCode stockeren Source Control is een sleutelbegrip voor ontwikkelteams. Het stelt iedereen in staat om aan dezelfde source file te werken zonder bestanden op- en neer te sturen, voorziet backups, maakt het mogelijk om releases en branches uit te rollen, \u0026hellip;\nVanaf nu wordt verondersteld dat labo oefeningen gecommit worden in git op Github: een zeer populair open source software ontwikkelingsplatform dat gebruiksvriendelijk is. Het Pro Git handboek leert je alles over de werking van git. Een typische workflow is als volgt:\n git clone [url]: Maakt een lokale repository aan die je op Github hebt gecreëerd. Het commando maakt een subdirectory aan. Doe je programmeerwerk. git status en git diff: Bekijk lokale changes voordat ze naar de server gaan. git add [.]: Geef aan welke changes staged worden voor commit git commit -m [comment]: commit naar je lokale repository. git push: push lokale commits naar de Github server. git pull: pull remote changes naar je lokale repository.  De output van git status ziet er zo uit:\n Wouters-MacBook-Air:brainbaking wgroenev$ git status On branch master Your branch is up-to-date with 'origin/master'. Changes not staged for commit: (use \"git add/rm ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: content/teaching/cpp/labo-1.md modified: content/teaching/cpp/labo-2.md modified: content/teaching/cpp/labo-3.md modified: content/teaching/cpp/labo-4.md modified: content/teaching/cpp/labo-5.md modified: content/teaching/cpp/labo-6.md deleted: docs/CNAME deleted: docs/essays/i-am-jealous-of-my-dog/index.html  De output van git diff ziet er zo uit:\n Wouters-MacBook-Air:brainbaking wgroenev$ git diff diff --git a/content/teaching/cpp/labo-1.md b/content/teaching/cpp/labo-1.md index 654a4f6..11f0597 100644 --- a/content/teaching/cpp/labo-1.md +++ b/content/teaching/cpp/labo-1.md @@ -4,7 +4,7 @@ accent: \"#008eb3\" disableComments: true --- -\u0026laquo;\u0026nbsp;[Terug naar Software ontwerp in C/C++ met Qt](/teaching/cpp) +\u0026laquo;\u0026nbsp;[Terug naar Software ontwerp in C/C++](/teaching/cpp) \u0026raquo;\u0026nbsp;[Naar de labo opgave](#oef)  Clean Code Een quote uit het Clean Code boek van Robert C. Martin verduidelijkt het woordgebruik:\n Even bad code can function. But if code isn t clean, it can bring a development organization to its knees. Every year, countless hours and significant resources are lost because of poorly written code. But it doesn t have to be that way.\n Raadpleeg het boek Clean Code voor meer informatie.\nInderdaad, slechte code compileert ook en wordt ook uitgevoerd, maar dit komt onderhoudbaarheid helemaal niet ten goede. Er is voor \u0026ldquo;Modern C++\u0026rdquo; (C++11) zelfs een aparte clean-cpp blog toegeweid aan proper C++ gebruik.\nEen voorbeeld ter verduidelijking:\nvoid process(Cl \u0026amp;c, int times) { for(int i = 0; i \u0026lt; times; i++) { if(login(c.user, c.pass)) { break; } wait(); } } Dit is een simpele functie, maar zie jij op het eerste zicht wat dit doet?\nvoid tryToLoginAmountOfTimes(const User \u0026amp;user, int maxTimes) { for(int i = 0; i \u0026lt; maxTimes; i++) { if(user.tryToLogin()) { return; } wait(); } } Subtiele verschillen maken vaak een wereld van verschil:\n Naamgeving is zéér belangrijk. Objecten die niet gewijzigd mogen worden voorzie je van const. Bad practices als break worden vermeden. Formattering in code maakt het lezen aangenamer. Denk na over de juiste plaats: waarom parameters doorgeven als login bij de gebruiker klasse kan horen?  Kritisch denken brengt je een heel eind. Wees streng genoeg: stel constant de vraag \u0026ldquo;is dit wel nodig?\u0026rdquo;. maxTimes is bijvoorbeeld nutteloos als de methode altijd aangeroepen wordt met eenzelfde constante waarde.\nEen laatste voorbeeld uit de realiteit gegrepen:\nPermissionItem CreatePermission(const std::string\u0026amp; key, bool visible, const DBType type = DBType.Default) { } // gebruik: auto pi1 = CreatePermission(\u0026#34;some_key\u0026#34;, true); auto pi2 = CreatePermission(\u0026#34;bla_key\u0026#34;, false, DBType.Default); PermissionItem CreateVisiblePermission(const std::string\u0026amp; key) { } PermissionItem CreateInvisiblePermission(const std::string\u0026amp; key) { } // gebruik: auto pi1 = CreateVisiblePermission(\u0026#34;some_key\u0026#34;); auto pi2 = CreateInvisiblePermission(\u0026#34;bla_key\u0026#34;);  Het verschil is hemel en aarde:\n Het woord \u0026ldquo;visible\u0026rdquo; of \u0026ldquo;invisible\u0026rdquo; in de methodenaam verduidelijkt enorm veel. Vermijd altijd magische bool flags! Vergeet niet dat de methode definitie ergens in een header file leeft en er naar navigeren om te begrijpen wat welk argument doet véél tijd kost. Wees kritisch met parameters. Als een parameter altijd met default waardes wordt meegegeven kan je het net zo goed weglaten.  Zie ook de verkorte Clean Code cursus slides.\nSoftware Testen Hoe weet ik of mijn feature in de software wel werkt?  Door het te testen.\nAcceptatie testen De eenvoudigste manier waarop je tot nu toe altijd tewerk bent gegaan is een vorm van \u0026ldquo;acceptatie testen\u0026rdquo;: het programma simpelweg proberen opstarten en navigeren tot waar je de code wijziging hebt doorgevoerd. Dit werkt natuurlijk, maar brengt een aantal nadelen met zich mee:\n Tijdverlies. Constant moeten navigeren tot aan het scherm waar je aan gewerkt hebt kan minuten in beslag nemen bij grote programma\u0026rsquo;s. Vervelend. Je verliest je aandacht na een tijdje vanwege het herhaaldelijk werk dat eigenlijk geautomatiseerd kan worden.  Natuurlijk veronderstelt men dat je tenminste één keer je programma end-to-end hebt doorlopen om controles uit te voeren, maar niet constant bij het schrijven van elke nieuwe lijn code. Wat zijn de alternatieven?\nDebug statements Een mogelijkheid is cout \u0026lt;\u0026lt; var \u0026lt;\u0026lt; endl rondstrooien, hopelijk met een of andere vorm van #ifdef _DEBUG, maar zoals Peter Ritchie zegt: \u0026ldquo;If You’re Using “#if DEBUG”, You’re Doing it Wrong\u0026rdquo;.\nHerinner je de belangrijkheid van Clean Code. Je Code is alles behalve Clean als het vol staat met debug statements om te controleren of een variabele een bepaalde state heeft dat jij niet kan achterhalen. Daar dient de debugger zelf voor (zie later).\nUnit testen Met een \u0026ldquo;unit test\u0026rdquo; automatiseer je in feite een klein stuk van een acceptatie scenario dat je zelf samenstelt. Met frameworks als Google Test schrijf je in code wat je verwacht dat bepaalde functies teruggeven in termen van gedrag:\nint Factorial(int n); // Returns the factorial of n  // Tests factorial of 0. TEST(FactorialTest, HandlesZeroInput) { EXPECT_EQ(Factorial(0), 1); } // Tests factorial of positive numbers. TEST(FactorialTest, HandlesPositiveInput) { EXPECT_EQ(Factorial(1), 1); EXPECT_EQ(Factorial(2), 2); EXPECT_EQ(Factorial(3), 6); EXPECT_EQ(Factorial(8), 40320); } Google Test is deel van het xUnit framework dat we kennen in de Java wereld van JUnit. Zie bovenstaande link voor assertion documentatie. Download De laatste Google Test Release op Github.\nIn CLion Volg de volgende stappen:\n Download en compileer googletest:  Download een release of clone de github repository cd googletest Maak een build directory: mkdir build in de map googletest Build cmake: cd build \u0026amp;\u0026amp; cmake ./../ Build google test: make. Dit geeft libgtest.a en libgtest_main.a\n  Integreer googletest in je CLion project met CMake:  Include de gtest headers met include_directories() Link de libraries met target_link_libraries() En (voor later) voorzie een omgevingsvariabele $GTEST_DIR.   Het CMakeLists.txt ziet er dan als volgt uit:\n cmake_minimum_required(VERSION 3.10) project(unittest) SET(google_test_dir \"/Users/wgroenev/CLionProjects/googletest-release-1.8.0/googletest\") include_directories(${google_test_dir}/include) set(CMAKE_CXX_STANDARD 11) add_executable(unittest main.cpp test.cpp) target_link_libraries(unittest ${google_test_dir}/build/libgtest.a ${google_test_dir}/build/libgtest_main.a)  Merk op dat we googlemock achterwege laten, de repository bevat 2 test frameworks. Om testen uit te voeren heb je een main functie nodig die google test opstart:\n// main.cpp #include \u0026#34;gtest/gtest.h\u0026#34; int main(int argc, char *argv[]) { ::testing::InitGoogleTest(\u0026amp;argc, argv); return RUN_ALL_TESTS(); } De testen in de screenshot leven in test.cpp:\n// test.cpp #include \u0026#34;gtest/gtest.h\u0026#34; int add(int one, int two) { return one + two; } class SuiteName : public ::testing::Test { // setup en teardown hier }; // gebruik bovenstaande suite TEST_F(SuiteName, TrueIsTrue) { EXPECT_TRUE(true); } // losstaande test TEST(AddTest, ShouldAddOneAndTo) { EXPECT_EQ(add(1, 2), 5); } In commandline met CMake Bovenstaande procedure moet je ook volgen los van CLion. De binary die uit het build proces komt voert alle testen uit (zie main code). Testen worden commandline uitgevoerd:\n Wouters-MacBook-Air:unittest wgroenev$ ./cmake-build-debug/unittest [==========] Running 2 tests from 2 test cases. [----------] Global test environment set-up. [----------] 1 test from SuiteName [ RUN ] SuiteName.TrueIsTrue [ OK ] SuiteName.TrueIsTrue (0 ms) [----------] 1 test from SuiteName (0 ms total) [----------] 1 test from AddTest [ RUN ] AddTest.ShouldAddOneAndTo /Users/wgroenev/CLionProjects/unittest/test.cpp:18: Failure Expected: add(1, 2) Which is: 3 To be equal to: 5 [ FAILED ] AddTest.ShouldAddOneAndTo (0 ms) [----------] 1 test from AddTest (0 ms total) [----------] Global test environment tear-down [==========] 2 tests from 2 test cases ran. (0 ms total) [ PASSED ] 1 test. [ FAILED ] 1 test, listed below: [ FAILED ] AddTest.ShouldAddOneAndTo 1 FAILED TEST  Enkele verbeterpunten:\n Het is vervelend dat je de gtest libraries manueel moet builden. CMake kan dit ook automatisch Je main binary voert nu testen uit in plaats van productie code. Een typisch C++ project is opgesplitst in een map src en een map test, en build 2 binaries. Download hier een voorbeeld met opgesplitste CMake files.  Regressie tegen gaan met testen Een bug oplossen betekent niet dat deze bug nooit meer kan voorkomen. Zeker wanneer je met meerdere mensen aan dezelfde source code werkt, kan het zijn dat per ongeluk bepaalde wijzigingen de bug laten terugkomen. Dit noemt men \u0026ldquo;regressie\u0026rdquo; en is een hel voor klanten die betalen voor software!\nRegressie is eenvoudig tegen te gaan met unit testen. Een test die faalt alarmeert onmiddellijk iemand dat bepaalde verwachte functionaliteit niet meer werkt. Een geïntegreerde build server zorgt voor het automatisch opvolgen van die testen.\nGegeven de volgende klasse:\nclass Interval { private: int begin, einde; public: Interval(int begin, int einde) : begin(begin), einde(einde) {} bool inclusief(int ander) { return ander \u0026gt; begin \u0026amp;\u0026amp; ander \u0026lt;= einde; } }; We verwachten dat voor een interval [5-10] de getallen 5 en 10 ook nog in die range zitten. Dit zijn de testen voor de functie inclusief():\nclass IntervalSuite : public ::testing::Test { protected: Interval *interval; protected: virtual void TearDown() { delete interval; } virtual void SetUp() { interval = new Interval(5, 10); } }; TEST_F(IntervalSuite, BeginZitInInterval) { ASSERT_TRUE(interval-\u0026gt;inclusief(5)); } TEST_F(IntervalSuite, EindeZitInInterval) { ASSERT_TRUE(interval-\u0026gt;inclusief(10)); } TEST_F(IntervalSuite, GetalTussenBeginEnEindeZitInInterval) { ASSERT_TRUE(interval-\u0026gt;inclusief(7)); } TEST_F(IntervalSuite, GetalGroterDanEindeZitNietInInterval) { ASSERT_FALSE(interval-\u0026gt;inclusief(70)); } TEST_F(IntervalSuite, GetalKleinerDanBeginZitNietInInterval) { ASSERT_FALSE(interval-\u0026gt;inclusief(2)); } Waarvan BeginZitInInterval faalt. Verander in de implementatie \u0026gt; door \u0026gt;= en de suite zorgt er voor dat deze code altijd correct is.\nDebuggen in C++ De stack bekijken, lokale variabelen inspecteren, \u0026hellip; kennen we van IDEs als NetBeans of IntelliJ. In CLion is dit exact hetzelfde. Zet een breakpoint in productie code en stap er door met de ingebouwde debugging tools:\nHandmatig De compiler toolchain voorziet een commandline debugger gdb. Daarvoor moet je debug informatie genereren bij compilatie met g++ flag -g. De tool is vrij rudimentair in gebruik. Zie documentatie voor informatie rond commando\u0026rsquo;s.\nLabo oefeningen Er wordt verwacht aan unit testen te denken voor (simpele) logica. Experimenteer dus eerst met Google Test en probeer de voorbeelden op deze pagina zelf. Maak voor de oefeningen een nieuwe Github repository aan, of een nieuwe submap in een bestaande als dat al gebeurd is.\n Gegeven het volgende analyse document: werk een implementatie uit. Begin met een model te tekenen en denk aan de relaties! Compileer Google Test volgens de instructies. Download het CMake startproject - open dit in CLion. Voorzie de operator + methode, die een nieuw interval berekent door de som te nemen van beide intervallen. Dus: [3, 7] + [4, 9] = [3, 9]. Schrijf eerst unit testen in GTest hiervoor, en denk aan alle mogelijke gevallen (elk geval is een nieuwe test). Wat met dezelfde beginwaardes? Of met negatieve waardes? Gegeven de vervolganalyse. Herwerk je implementatie en breid uit.  Denkvragen  Hoe komt het dat bij TEST_F(Suite, TestNaam) de test naam niet tussen quotes moet? Waarom is in het test suite voorbeeld *Interval een pointer en geen gewone instance van de klasse Interval? In dat geval hoeven we toch geen delete uit te voeren en is de tear down methode irrelevant\u0026hellip; Bouw een repliek op tegen de stelling \u0026ldquo;code is code: kwaliteit is enkel ijdelheid\u0026rdquo;. Beargumenteer met minstens 3 voorbeelden.  "
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/extra/poll/",
	"title": "Poll: Ben ik klaar voor mijn examen?",
	"tags": [],
	"description": "",
	"content": " Ga naar pollev.com/woutergroene532 om mee te doen. De mogelijke antwoorden zijn voor elke snippet hetzelfde:\n Compileert NIET. (Fouten bij gcc commando) Compileert, maar runtime ERROR. (Fouten bij uitvoeren: segfaults e.d.) Runt, maar ONGEWENST gedrag. (Geen fouten maar bugs in gedrag) WERKT zoals verwacht.  Includes en namespaces worden buiten beschouwing gelaten.\nKlik op de snippet headers om de snippet te tonen.\nSnippet 1 class Student; class Teacher { private: std::vector\u0026lt;Student*\u0026gt; students; public: Teacher() { students.push_back(new Student()); } };  Antwoord: Compile fout; forward definition van Student klasse kan, maar new() niet.\nSnippet 2 class Student; class Teacher { private: std::vector\u0026lt;Student*\u0026gt; students; public: Teacher() { students.push_back(NULL); } };  Antwoord: Werkt. NULL toevoegen werkt omdat het een pointer naar \u0026lsquo;niets\u0026rsquo; is.\nSnippet 3 void maths(int* x) { x++; } int main() { int one = 0; maths(\u0026one); return one == 1; }  Antwoord: Onverwacht gedrag. x++ verhoogt het adres van de pointer, niet de eigenlijke waarde: we moeten hier nog dereferencen.\nSnippet 4 void swap(int* x, int* y) { int z = *x; *x = *y; *y = z; } int main() { int two = 1, one = 2; swap(\u0026one, \u0026two); }  Antwoord: Werkt. Tekstboek voorbeeld van waardes swappen.\nSnippet 5 class X { public: int i; X(int i) : i(i) {} }; bool setToOne(const X\u0026 x) { x.i = 1; return x.i == 1; } int main() { X x(2); std::cout Antwoord: Compile fout. const betekent dat de waarde van x niet kan wijzigen, dus x.i = 1 geeft een fout.\nSnippet 6 struct dinges { void* x; void* y; }; int main() { int *a; dinges iets = { (void*) a, (void*) a }; delete a; std::cout Antwoord: Runtime error. Na de delete de pointer \u0026lsquo;volgen\u0026rsquo; geeft (onverwachte) problemen.\nSnippet 7 template\u0026lt;typename T\u0026gt; class Punt { private: T x, y; public: Punt(T theX, T theY) : x(theX), y(theY) {} }; int main() { Punt\u0026lt;double\u0026gt; pt(1.2, 3.4); Punt\u0026lt;int\u0026gt; pt2(3, 5); }  Antwoord: Werkt. Een voorbeeld template klasse.\nSnippet 8 // in punt.h template\u0026lt;typename T\u0026gt; class Punt { private: T x, y; public: Punt(T theX, T theY); T getX() { return x; }; }; // in punt.cpp Punt\u0026lt;T\u0026gt;::Punt(T theX, T theY) : x(theX), y(theY) { } int main() { Punt\u0026lt;int\u0026gt; x(1, 2); std::cout Antwoord: Compile fout. T herhalen in punt.cpp vereist opnieuw de definitie van de template: template\u0026lt;typename T\u0026gt;.\nSnippet 9 int main() { int hoeveel = 0; scanf(\"%d\", hoeveel); printf(\"echt zoveel? %d\\n\", hoeveel); }  Antwoord: Runtime error. scanf() verwacht een correct adres, niet de waarde 0, dat buiten het bereik van het programma valt.\nSnippet 10 class Inception {}; int main() { vector\u0026lt;Inception**\u0026gt; *v; Inception *x = new Inception(); v = new vector\u0026lt;Inception**\u0026gt;(); Inception** y = new Inception*[10]; y[1] = x; v-push_back(y); }  Antwoord: Werkt. Dubbele pointers zijn Arrays van pointers. Vectoren van dubbele pointers zijn tweedimensionele arrays.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/",
	"title": "Software ontwerp in C/C++",
	"tags": [],
	"description": "",
	"content": " Laatste aanpassingen voor academiejaar 2020 - 2021.\nCursus notities De hoorcolleges en labo\u0026rsquo;s lopen door elkaar. De theorie die aangeraakt wordt in de slides van de hoorcolleges vindt zijn weg in de tekst van de verschillende labo\u0026rsquo;s.\nHoorcolleges Index pagina met videos van opgenomen colleges.\n Introductie in C/C++: context, ecosysteem Pointers in C, dynamisch geheugen in C++ Introductie in Object-Georiënteerd denken in C++ Een introductie in GUI ontwerp met Qt, Samenvatting, examen info  Labo noties  Introductie in C Pointers in C en C++ GBA Programming in C: een introductie GBA Programming in C: tilesets, een simpel spel Introductie in C++ C++ Class Inheritance, operators en templates Software ontwerpen: denken en testen voor coderen GBA Programming in C++: een abstractielaag GBA Programming in C++: scrolling backgrounds  Optioneel  GUI ontwerp met C++ in Qt: een introductie GUI ontwerp met C++ in Qt: een GBA spel porten naar Qt  Extra informatie  Poll: Ben ik klaar voor mijn examen? Hulp, iets werkt niet! Raadpleeg de FAQ. Een introductie in C(++) Build Systemen Installatieinstructies Tools Project opdracht Evaluatiecriteria schriftelijk examen  Syllabus  Lesgevers: Coördinerend Verantwoordelijke: prof. dr. Kris Aerts - kris.aerts@kuleuven.be Onderwijsassistent: Wouter Groeneveld - wouter.groeneveld@kuleuven.be Kantoor: Technologiecentrum Diepenbeek, Groep ACRO, D.0.35. Verplicht handboek: C++ Primer, Stanley B. Lippman  Cursusbeschrijving C is oorspronkelijk ontwikkeld om hardware heel gericht te kunnen aansturen. Later, en zeker met de toevoeging van C++, is C/C++ ook gebruikt voor gewone software. Tegenwoordig wordt die rol eerder overgenomen door Java en .NET en is het belang van C en C++ (terug) verschoven naar de ingebedde systemen.\nVanuit die optiek is het niet meer dan logisch om studenten elektronica/ict vaardigheden in C/C++ te laten verwerven. Vanuit dezelfde verbredende visie doen we dit met Linux als (cross-platform) ontwikkelplatform en met embedded systemen als doelplatform.\nC++ wordt aangebracht vanuit de kennis van Java, zoals verworven in eerdere opleidingsonderdelen. Er wordt dan ook geregeld gewezen op de verschillen en gelijkenissen tussen C++ en Java. Een aantal concepten zijn gelijkaardig met (lichtjes) andere syntax, maar er zijn ook fundamenteel andere dingen, zoals pointers, friends, virtuele functies, operator overloading, destructors, STL, \u0026hellip; Voor de GUI wordt gewerkt met QT.\nIn een latere faze van de oefeningen maakt de student kennis met crosscompilatie zodat de oefening kan draaien op een single board \u0026ldquo;computer\u0026rdquo; zoals een Gameboy Advance.\n Imperatief programmeren in C  Controlestructuren, functies, arrays Pointers en reference variabelen.  Object-Georiënteerd programmeren C++  Operatoren, virtuele functie, abstracte klasse, uitzonderingen, sjablonen, containers. De STL bibliotheek C++ 11 lambda\u0026rsquo;s  Het gehele C/C++ Ecosysteem: makefiles, builden, linken. Software ontwerpen met domein modellen. Vergelijking tussen C/C++ en Java. Cross-platform-ontwikkeling voor Single Board Computers. Kennismaking met het Qt framework voor GUI ontwerp in C++.  Vereiste voorkennis  Basiskennis van een Object-Geörienteerde programmeertaal als Java of C# Basiskennis van het UNIX systeem, werken met commandline  Doelstellingen Zie ook Studiegids UHasselt\nDe context en het overzicht worden aangereikt in het hoorcollege.\nAls practicum wordt een grotere probleemstelling als project uitgewerkt. Alle aan te leren aspecten van C++ komen in dit project aan bod. Studenten kunnen facultatief buiten het practicum extra thematische oefeningen oplossen.\nBeoordeling en evaluatie Zowel in de eerste als de tweede examenkans is er een project (thuiswerk) en een schriftelijk examen. De verdeling tussen beide is afhankelijk van de omvang van de taak en wordt meegedeeld wanneer de taak wordt opgegeven.\nOverdracht van het punt op de taak naar de tweede examenkans en een volgend academiejaar vanaf 12\u0026frasl;20.\nOverdracht van het punt op het examen naar de tweede examenkans vanaf 10\u0026frasl;20. Er is geen overdracht naar een volgend academiejaar.\nMeer leermiddelen Een interessante vergelijkende cursus met nadruk op computer architectuur: Computer Systems and Architecture aan de Universiteit Mary Washington.\nC in-depth  The C Programming Language  Embedded GBA Programming in C  Tonc: principles of GBA programming GBA Programming for beginners  C++ in-depth  Effective Modern C++ Bjarne Stroustrup\u0026rsquo;s C++ Style and Technique FAQ  Qt GUI Programming  Qt Examples and Tutorials Qt Class reference  Build Tools  Pro Git Book CMake Documentation  Kalender Zie collegeroosters UHasselt.\n"
},
{
	"uri": "https://kuleuven-diepenbeek.github.io/cpp-course/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]